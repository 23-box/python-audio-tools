#!/usr/bin/python

#Audio Tools, a module and set of tools for manipulating audio data
#Copyright (C) 2007-2009  Brian Langenberger

#This program is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA


import audiotools
import optparse
import sys
import os
import os.path
import subprocess

if (__name__ == '__main__'):
    parser = optparse.OptionParser(
        '%prog [-t track type] ' + \
        '[-o output] [-q quality] ' + \
        '<track 1> [track 2] ...',
        version="Python Audio Tools %s" % (audiotools.VERSION))

    parser.add_option('-q','--quality',
                      action='store',
                      type='string',
                      dest='quality',
                      help='the quality to store audio values at')

    parser.add_option('-t','--type',
                      action='store',
                      dest='type',
                      choices=audiotools.TYPE_MAP.keys(),
                      help='the type of audio value to convert to')

    parser.add_option('-o','--output',dest='filename',
                      metavar='FILE',
                      help='the output file')

    parser.add_option('--cue',
                      action='store',
                      type='string',
                      dest='cuesheet',
                      metavar='FILENAME',
                      help='a cuesheet to embed in the output file')

    (options,args) = parser.parse_args()

    if (options.filename == None):
        print >>sys.stderr,'*** You must specify an output filename'
        sys.exit(1)

    #get the AudioFile class we are converted to
    if (options.type is not None):
        AudioType = audiotools.TYPE_MAP[options.type]
    else:
        try:
            AudioType = audiotools.filename_to_type(options.filename)
        except audiotools.UnknownAudioType,exp:
            print >>sys.stderr,exp.error_msg()
            sys.exit(1)

    #ensure the selected compression is compatible with that class
    if (options.quality == 'help'):
        if (len(AudioType.COMPRESSION_MODES) > 1):
            print >>sys.stderr,"*** Available compression types for %s:" % \
                  (AudioType.NAME)
            for mode in AudioType.COMPRESSION_MODES:
                print >>sys.stderr,mode
        else:
            print >>sys.stderr,"*** Audio type %s has no compression modes" % \
                  (AudioType.NAME)
        sys.exit(0)
    elif (options.quality == None):
        options.quality = AudioType.DEFAULT_COMPRESSION
    elif (options.quality not in AudioType.COMPRESSION_MODES):
        print >>sys.stderr,"*** \"%s\" is not a supported compression " % \
              (options.quality) + "mode for type \"%s\"" % \
              (AudioType.NAME)
        sys.exit(1)

    #grab the list of AudioFile objects we are converting from
    audiofiles = audiotools.open_files(args)
    if (len(audiofiles) < 1):
        print >>sys.stderr,"*** You must specify at least 1 supported audio file"
        sys.exit(1)

    if (len(set([f.sample_rate() for f in audiofiles])) != 1):
        print >>sys.stderr,"*** All audio files must have the same sample rate"
        sys.exit(1)

    if (len(set([f.channels() for f in audiofiles])) != 1):
        print >>sys.stderr,"*** All audio files must have the same channel count"
        sys.exit(1)

    if (len(set([f.bits_per_sample() for f in audiofiles])) != 1):
        print >>sys.stderr,"*** All audio files must have the same bits per sample"
        sys.exit(1)

    #if embedding a cuesheet, try to read it before doing any work
    if (options.cuesheet is not None):
        try:
            cuesheet = audiotools.read_sheet(options.cuesheet)
        except audiotools.SheetException,msg:
            print >>sys.stderr,"*** %s: %s" % (options.cuesheet,str(msg))
            sys.exit(1)
    else:
        cuesheet = None

    #constuct a MetaData object from our audiofiles
    track_metadatas = [f.get_metadata() for f in
                       audiofiles if (f.get_metadata() is not None)]

    if (len(track_metadatas) > 0):
        track_fields = dict([(field,
                              set([getattr(m,field) for m in track_metadatas]))
                             for field in audiotools.MetaData.__FIELDS__])

        metadata = audiotools.MetaData(**dict([(field,list(values)[0])
                                               for (field,values) in
                                               track_fields.items()
                                               if (len(values) == 1)]))

        #port over non-duplicate images
        images = []
        for m in track_metadatas:
            for i in m.images():
                if (i not in images):
                    images.append(i)
        for i in images:
            metadata.add_image(i)
    else:
        metadata = None

    quality = options.quality

    pcmdata = audiotools.PCMCat(iter([af.to_pcm() for af in audiofiles]))

    try:
        encoded = AudioType.from_pcm(options.filename,
                                     pcmdata,
                                     quality)

        encoded.set_metadata(metadata)

        if (cuesheet is not None):
            #set_metadata() will sometimes transfer a cuesheet automatically
            #in that case, don't transfer it again via set_cuesheet()
            existing_cuesheet = encoded.get_cuesheet()
            if (existing_cuesheet is None):
                encoded.set_cuesheet(cuesheet)

    except audiotools.InvalidFormat,msg:
        print >>sys.stderr,"*** %s: %s" % (options.filename,str(msg))
        sys.exit(1)


