#!/usr/bin/python

#Audio Tools, a module and set of tools for manipulating audio data
#Copyright (C) 2007-2012  Brian Langenberger

#This program is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA


import sys
import os
import os.path
import audiotools
from audiotools.text import (USAGE_TRACKCAT,
                             OPT_CAT_ENCODING,
                             OPT_TYPE,
                             OPT_QUALITY,
                             OPT_OUTPUT_TRACKCAT,
                             OPT_VERBOSE,
                             OPT_CUESHEET_TRACKCAT,
                             ERR_NO_OUTPUT_FILE,
                             LAB_AVAILABLE_COMPRESSION_TYPES,
                             ERR_NO_COMPRESSION_MODES,
                             ERR_UNSUPPORTED_COMPRESSION_MODE,
                             ERR_OUTPUT_IS_INPUT,
                             ERR_FILES_REQUIRED,
                             ERR_SAMPLE_RATE_MISMATCH,
                             ERR_CHANNEL_COUNT_MISMATCH,
                             ERR_CHANNEL_MASK_MISMATCH,
                             ERR_BPS_MISMATCH,
                             ERR_ENCODING_ERROR)

if (__name__ == '__main__'):
    parser = audiotools.OptionParser(
        usage=USAGE_TRACKCAT,
        version="Python Audio Tools %s" % (audiotools.VERSION))

    conversion = audiotools.OptionGroup(parser, OPT_CAT_ENCODING)

    conversion.add_option('-t', '--type',
                          action='store',
                          dest='type',
                          choices=audiotools.TYPE_MAP.keys(),
                          help=OPT_TYPE)

    conversion.add_option('-q', '--quality',
                          action='store',
                          type='string',
                          dest='quality',
                          help=OPT_QUALITY)

    conversion.add_option('-o', '--output', dest='filename',
                          metavar='FILE',
                          help=OPT_OUTPUT_TRACKCAT)

    parser.add_option_group(conversion)

    parser.add_option('--cue',
                      action='store',
                      type='string',
                      dest='cuesheet',
                      metavar='FILENAME',
                      help=OPT_CUESHEET_TRACKCAT)

    parser.add_option('-V', '--verbose',
                      action='store',
                      dest='verbosity',
                      choices=audiotools.VERBOSITY_LEVELS,
                      default=audiotools.DEFAULT_VERBOSITY,
                      help=OPT_VERBOSE)

    (options, args) = parser.parse_args()
    msg = audiotools.Messenger("trackcat", options)

    if (options.filename is None):
        msg.error(ERR_NO_OUTPUT_FILE)
        sys.exit(1)

    #get the AudioFile class we are converted to
    if (options.type is not None):
        AudioType = audiotools.TYPE_MAP[options.type]
    else:
        try:
            AudioType = audiotools.filename_to_type(options.filename)
        except audiotools.UnknownAudioType, exp:
            exp.error_msg(msg)
            sys.exit(1)

    #ensure the selected compression is compatible with that class
    if (options.quality == 'help'):
        if (len(AudioType.COMPRESSION_MODES) > 1):
            msg.info(LAB_AVAILABLE_COMPRESSION_TYPES %
                     (AudioType.NAME))
            for mode in AudioType.COMPRESSION_MODES:
                msg.new_row()
                if (mode == audiotools.__default_quality__(AudioType.NAME)):
                    msg.output_column(msg.ansi(mode.decode('ascii'),
                                               [msg.BOLD,
                                                msg.UNDERLINE]), True)
                else:
                    msg.output_column(mode.decode('ascii'), True)
                if (mode in AudioType.COMPRESSION_DESCRIPTIONS):
                    msg.output_column(u" : ")
                else:
                    msg.output_column(u"   ")
                msg.output_column(
                    AudioType.COMPRESSION_DESCRIPTIONS.get(mode, u""))
            msg.info_rows()
        else:
            msg.error(ERR_NO_COMPRESSION_MODES % (AudioType.NAME))
        sys.exit(0)
    elif (options.quality is None):
        options.quality = audiotools.__default_quality__(AudioType.NAME)
    elif (options.quality not in AudioType.COMPRESSION_MODES):
        msg.error(ERR_UNSUPPORTED_COMPRESSION_MODE %
                  {"quality": options.quality,
                   "type": AudioType.NAME})
        sys.exit(1)

    #grab the list of AudioFile objects we are converting from
    output_filename = audiotools.Filename(options.filename)
    opened_files = set([])
    if (options.cuesheet is not None):
        opened_files.add(audiotools.Filename(options.cuesheet))
    audiofiles = audiotools.open_files(args,
                                       messenger=msg,
                                       warn_duplicates=True,
                                       opened_files=opened_files)

    #perform some option sanity checking
    if (output_filename in opened_files):
        msg.error(ERR_OUTPUT_IS_INPUT % (output_filename,))
        sys.exit(1)

    if (len(audiofiles) < 1):
        msg.error(ERR_FILES_REQUIRED)
        sys.exit(1)

    if (len(set([f.sample_rate() for f in audiofiles])) != 1):
        msg.error(ERR_SAMPLE_RATE_MISMATCH)
        sys.exit(1)

    if (len(set([f.channels() for f in audiofiles])) != 1):
        msg.error(ERR_CHANNEL_COUNT_MISMATCH)
        sys.exit(1)

    if (len(set([int(f.channel_mask()) for f in audiofiles])) != 1):
        msg.error(ERR_CHANNEL_MASK_MISMATCH)
        sys.exit(1)

    if (len(set([f.bits_per_sample() for f in audiofiles])) != 1):
        msg.error(ERR_BPS_MISMATCH)
        sys.exit(1)

    #if embedding a cuesheet, try to read it before doing any work
    if (options.cuesheet is not None):
        try:
            cuesheet = audiotools.read_sheet(options.cuesheet)
        except audiotools.SheetException, err:
            msg.error(unicode(err))
            sys.exit(1)
    else:
        cuesheet = None

    #constuct a MetaData object from our audiofiles
    track_metadatas = [f.get_metadata() for f in
                       audiofiles if (f.get_metadata() is not None)]

    if (len(track_metadatas) > 0):
        track_fields = dict([(field,
                              set([getattr(m, field)
                                   for m in track_metadatas]))
                             for field in audiotools.MetaData.FIELDS])

        metadata = audiotools.MetaData(**dict([(field, list(values)[0])
                                               for (field, values) in
                                               track_fields.items()
                                               if (len(values) == 1)]))

        #port over non-duplicate images
        images = []
        for m in track_metadatas:
            for i in m.images():
                if (i not in images):
                    images.append(i)
        for i in images:
            metadata.add_image(i)
    else:
        metadata = None

    progress = audiotools.SingleProgressDisplay(
        msg, unicode(output_filename))

    try:
        encoded = AudioType.from_pcm(
            str(output_filename),
            audiotools.PCMReaderProgress(
                audiotools.PCMCat(iter([af.to_pcm() for af in audiofiles])),
                sum([af.total_frames() for af in audiofiles]),
                progress.update),
            options.quality)

        encoded.set_metadata(metadata)

        progress.clear()

        if (cuesheet is not None):
            #set_metadata() will sometimes transfer a cuesheet automatically
            #in that case, don't transfer it again via set_cuesheet()
            existing_cuesheet = encoded.get_cuesheet()
            if (existing_cuesheet is None):
                encoded.set_cuesheet(cuesheet)

    except audiotools.EncodingError, err:
        msg.error(ERR_ENCODING_ERROR % (output_filename,))
        sys.exit(1)
    except audiotools.InvalidFormat, err:
        msg.error(unicode(err))
        sys.exit(1)
