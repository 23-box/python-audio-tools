#!/usr/bin/python

#Audio Tools, a module and set of tools for manipulating audio data
#Copyright (C) 2007-2012  Brian Langenberger

#This program is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA


import sys
import os.path

def check_binaries(msg, binary_list):
    from audiotools import BIN
    import audiotools.text as _

    for binary in binary_list:
        msg.new_row()
        if (BIN.can_execute(audiotools.BIN[binary])):
            msg.output_column(u"+ ")
            msg.output_column(_.LAB_AT_CONFIG_FOUND, True)
            msg.output_column(u" : ")
            msg.output_column(binary.decode('ascii'))
        else:
            msg.output_column(u"- ")
            msg.output_column(_.LAB_AT_CONFIG_NOT_FOUND, True)
            msg.output_column(u" : ")
            msg.output_column(binary.decode('ascii'))
    msg.output_rows()


class FormatSummary:
    def __init__(self, format, quality, binaries, replaygain):
        """format and quality are unicode.  The rest are list of unicode.

        All should be formatted for output."""

        self.format = format
        self.quality = quality
        self.binaries = binaries
        self.replaygain = replaygain

    @classmethod
    def headers(cls, messenger):
        import audiotools.text as _

        messenger.new_row()
        messenger.output_column(u" ")
        messenger.output_column(u" ")
        messenger.output_column(u" ")
        messenger.output_column(u" ")
        messenger.output_column(u" default ")
        messenger.output_column(u" ")
        messenger.output_column(u" ")

        messenger.new_row()
        messenger.output_column(_.LAB_AT_CONFIG_TYPE)
        messenger.output_column(u" ")
        messenger.output_column(_.LAB_AT_CONFIG_BINARIES)
        messenger.output_column(u" ")
        messenger.output_column(_.LAB_AT_CONFIG_QUALITY)
        messenger.output_column(u" ")
        messenger.output_column(_.LAB_AT_CONFIG_REPLAY_GAIN)
        messenger.divider_row([u"-", u"+", u"-",
                                   u"+", u"-", u"+", u"-"])

    def output_rows(self, messenger):
        #first, put our rows of data into lists of columns

        format_col = [self.format]
        quality_col = [self.quality]
        binaries_col = self.binaries[:]
        replaygain_col = self.replaygain[:]

        #then, make our columns consistently-sized
        total_rows = max(map(len, [format_col,
                                   quality_col,
                                   binaries_col,
                                   replaygain_col]))

        for col in [format_col, quality_col, binaries_col, replaygain_col]:
            col.extend([u""] * (total_rows - len(col)))

        #finally, output our rows to the Messenger
        for (format, quality, binary, replaygain) in zip(format_col,
                                                         quality_col,
                                                         binaries_col,
                                                         replaygain_col):
            messenger.new_row()
            messenger.output_column(u" %s " % (format), True)
            messenger.output_column(u"|")
            messenger.output_column(u" %s " % (binary))
            messenger.output_column(u"|")
            messenger.output_column(u" %s " % (quality))
            messenger.output_column(u"|")
            messenger.output_column(u" %s " % (replaygain))
        messenger.divider_row([u"-", u"+", u"-",
                               u"+", u"-", u"+", u"-"])

    @classmethod
    def from_audiofile(cls, messenger, audiofile, binaries):
        if (audiofile.has_binaries(binaries)):
            code = [messenger.FG_GREEN]
        else:
            code = [messenger.FG_RED]

        if (audiofile.NAME == audiotools.DEFAULT_TYPE):
            code.append(messenger.BOLD)
            code.append(messenger.UNDERLINE)

        format = messenger.ansi(audiofile.NAME.decode('ascii'), code)

        binaries_list = []
        for binary in audiofile.BINARIES:
            if (binaries.can_execute(binaries[binary])):
                code = [messenger.FG_GREEN]
            else:
                code = [messenger.FG_RED]
            binaries_list.append(messenger.ansi(binaries[binary], code))

        replaygain = []
        if (len(audiofile.REPLAYGAIN_BINARIES) > 0):
            for binary in audiofile.REPLAYGAIN_BINARIES:
                if (binaries.can_execute(binaries[binary])):
                    code = [messenger.FG_GREEN]
                else:
                    code = [messenger.FG_RED]
                replaygain.append(messenger.ansi(binaries[binary], code))
        elif (audiofile.supports_replay_gain()):
            replaygain.append(messenger.ansi("YES", [messenger.FG_GREEN]))
        else:
            replaygain.append("N/A")

        return cls(format,
                   audiotools.__default_quality__(
                audiofile.NAME).decode('ascii'),
                   binaries_list,
                   replaygain)


def display_defaults(msg):
        FormatSummary.headers(msg)
        for audiotype in sorted(audiotools.AVAILABLE_TYPES,
                                lambda x, y: cmp(x.NAME, y.NAME)):
            FormatSummary.from_audiofile(
                msg, audiotype, audiotools.BIN).output_rows(msg)
        msg.output_rows()

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_CD_BURNING, True)
        msg.output_column(u" : ")
        burning_options = []
        if (audiotools.BIN.can_execute(audiotools.BIN["cdrecord"])):
            burning_options.append(_.LAB_AT_CONFIG_WITHOUT_CUE)
        if (audiotools.BIN.can_execute(audiotools.BIN["cdrdao"])):
            burning_options.append(_.LAB_AT_CONFIG_WITH_CUE)
        if (len(burning_options) == 0):
            burning_options.append(_.LAB_AT_CONFIG_NO)
        msg.output_column(u", ".join([s.decode('ascii')
                                      for s in burning_options]))
        msg.output_rows()
        check_binaries(msg, ["cdrecord", "cdrdao"])

        msg.output(u"-" * 30)

        msg.output(_.LAB_AT_CONFIG_SYS_CONFIG)
        msg.output(u"")

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_USE_MUSICBRAINZ, True)
        msg.output_column(u" : ")
        msg.output_column({True: _.LAB_AT_CONFIG_YES,
                           False: _.LAB_AT_CONFIG_NO}[
                audiotools.MUSICBRAINZ_SERVICE])

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_MUSICBRAINZ_SERVER, True)
        msg.output_column(u" : ")
        msg.output_column(audiotools.MUSICBRAINZ_SERVER.decode('ascii',
                                                               'replace'))
        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_MUSICBRAINZ_PORT, True)
        msg.output_column(u" : ")
        msg.output_column(unicode(audiotools.MUSICBRAINZ_PORT))
        msg.blank_row()

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_USE_FREEDB, True)
        msg.output_column(u" : ")
        msg.output_column({True: _.LAB_AT_CONFIG_YES,
                           False: _.LAB_AT_CONFIG_NO}[audiotools.FREEDB_SERVICE])

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_FREEDB_SERVER, True)
        msg.output_column(u" : ")
        msg.output_column(audiotools.FREEDB_SERVER.decode('ascii',
                                                          'replace'))
        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_FREEDB_PORT, True)
        msg.output_column(u" : ")
        msg.output_column(unicode(audiotools.FREEDB_PORT))

        msg.blank_row()

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_DEFAULT_CDROM, True)
        msg.output_column(u" : ")
        msg.output_column(audiotools.DEFAULT_CDROM.decode(
                audiotools.FS_ENCODING))

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_CDROM_READ_OFFSET, True)
        msg.output_column(u" : ")
        msg.output_column(
            unicode(audiotools.config.getint_default("System",
                                                     "cdrom_read_offset", 0)))

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_CDROM_WRITE_OFFSET, True)
        msg.output_column(u" : ")
        msg.output_column(
            unicode(audiotools.config.getint_default("System",
                                                     "cdrom_write_offset", 0)))

        msg.blank_row()

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_JOBS, True)
        msg.output_column(u" : ")
        msg.output_column(unicode(audiotools.MAX_JOBS))

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_VERBOSITY, True)
        msg.output_column(u" : ")
        msg.output_column(audiotools.DEFAULT_VERBOSITY.decode('ascii'))

        output_options = []
        for player in audiotools.player.AUDIO_OUTPUT:
            if (player.available()):
                if (len(output_options) == 0):
                    output_options.append(msg.ansi(player.NAME.decode('ascii'),
                                                   [msg.BOLD,
                                                    msg.UNDERLINE]))
                else:
                    output_options.append(player.NAME.decode('ascii'))

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_AUDIO_OUTPUT, True)
        msg.output_column(u" : ")
        msg.output_column(u", ".join(output_options))

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_FS_ENCODING, True)
        msg.output_column(u" : ")
        msg.output_column(audiotools.FS_ENCODING.decode('ascii'))

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_IO_ENCODING, True)
        msg.output_column(u" : ")
        msg.output_column(audiotools.IO_ENCODING.decode('ascii'))

        msg.blank_row()

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_ID3V2_VERSION, True)
        msg.output_column(u" : ")
        msg.output_column({"id3v2.2":_.LAB_AT_CONFIG_ID3V2_ID3V22,
                           "id3v2.3":_.LAB_AT_CONFIG_ID3V2_ID3V23,
                           "id3v2.4":_.LAB_AT_CONFIG_ID3V2_ID3V24,
                           "none":_.LAB_AT_CONFIG_ID3V2_NONE}.get(
                audiotools.config.get_default("ID3", "id3v2", "id3v2.3"),
                u"ID3v2.3"))
        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_ID3V2_PADDING, True)
        msg.output_column(u" : ")
        msg.output_column({True:_.LAB_AT_CONFIG_ID3V2_PADDING_YES,
                           False:_.LAB_AT_CONFIG_ID3V2_PADDING_NO}[
                audiotools.config.getboolean_default("ID3", "pad", False)])
        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_ID3V1_VERSION, True)
        msg.output_column(u" : ")
        msg.output_column({"id3v1.1":_.LAB_AT_CONFIG_ID3V1_ID3V11,
                           "none":_.LAB_AT_CONFIG_ID3V1_NONE}.get(
                audiotools.config.get_default("ID3", "id3v1", "id3v1.1"),
                u"ID3v1.1"))
        msg.blank_row()

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_ADD_REPLAY_GAIN, True)
        msg.output_column(u" : ")
        msg.output_column(
            {True: _.LAB_AT_CONFIG_YES,
             False: _.LAB_AT_CONFIG_NO}[audiotools.ADD_REPLAYGAIN])

        msg.blank_row()
        msg.output_rows()

        msg.output(_.LAB_AT_CONFIG_FORMAT %
                   (audiotools.FILENAME_FORMAT.decode('ascii', 'replace')))


def apply_options(options, config):
    """given an OptionParser's options dict
    and audiotools.RawConfigParser object
    applies the options to the config"""

    #apply transcoding options
    if (options.filename_format is not None):
        config.set_default("Filenames", "format", options.filename_format)

    if (options.quality is None):
        #not setting no --quality value
        if (options.type is None):
            #do nothing
            pass
        else:
            #set new default output type
            config.set_default("System", "default_type", options.type)
    else:
        #setting new --quality value
        if (options.type is None):
            #set new quality value for current default type
            AudioType = audiotools.TYPE_MAP[audiotools.DEFAULT_TYPE]
        else:
            #set new quality value for given type
            AudioType = audiotools.TYPE_MAP[options.type]
        config.set_default("Quality", AudioType.NAME, options.quality)

    if (options.system_maximum_jobs is not None):
        config.set_default("System", "maximum_jobs",
                           str(options.system_maximum_jobs))

    #apply CD lookup options
    if (options.use_musicbrainz is not None):
        config.set_default("MusicBrainz", "service",
                           True if (options.use_musicbrainz == "yes")
                           else False)

    if (options.musicbrainz_server is not None):
        config.set_default("MusicBrainz", "server", options.musicbrainz_server)

    if (options.musicbrainz_port is not None):
        config.set_default("MusicBrainz", "port", options.musicbrainz_port)

    if (options.use_freedb is not None):
        config.set_default("FreeDB", "service",
                           True if (options.use_freedb == "yes")
                           else False)

    if (options.freedb_server is not None):
        config.set_default("FreeDB", "server", options.freedb_server)

    if (options.freedb_port is not None):
        config.set_default("FreeDB", "port", options.freedb_port)

    #apply ID3 options
    if (options.id3v2_version is not None):
        config.set_default("ID3", "id3v2", options.id3v2_version)

    if (options.id3v1_version is not None):
        config.set_default("ID3", "id3v1", options.id3v1_version)

    if (options.id3_digit_padding is not None):
        config.set_default("ID3", "pad",
                           True if (options.id3_digit_padding == "yes")
                           else False)

    #apply ReplayGain options
    if (options.add_replaygain is not None):
        config.set_default("ReplayGain", "add_by_default",
                           True if (options.add_replaygain == "yes")
                           else False)

    #apply system options
    if (options.system_cdrom is not None):
        config.set_default("System", "cdrom", options.system_cdrom)

    if (options.system_cdrom_read_offset is not None):
        config.set_default("System", "cdrom_read_offset",
                           options.system_cdrom_read_offset)

    if (options.system_cdrom_write_offset is not None):
        config.set_default("System", "cdrom_write_offset",
                           options.system_cdrom_write_offset)

    if (options.system_fs_encoding is not None):
        config.set_default("System", "fs_encoding", options.system_fs_encoding)

    if (options.system_io_encoding is not None):
        config.set_default("System", "io_encoding", options.system_io_encoding)

    #apply binaries options
    bins = set([])
    for audioclass in audiotools.AVAILABLE_TYPES:
        for binary in audioclass.BINARIES:
            bins.add(binary)

    for binary in bins:
        setting = getattr(options, "binary_" + binary)
        if (setting is not None):
            config.set_default("Binaries", binary, setting)


if (__name__ == '__main__'):
    #There's no good way to make these dynamic
    #since the configurable text comes from the audiotools.text module
    #which we can't load because the module isn't installed correctly.
    try:
        import audiotools
        import audiotools.ui
    except ImportError:
        print "* audiotools Python module not found!"
        print "Perhaps you should re-install the Python Audio Tools"
        sys.exit(1)
    try:
        import audiotools.player
    except ImportError:
        print "* audiotools.player Python module not found!"
        print "Perhaps you should re-install the Python Audio Tools"
        sys.exit(1)

    import audiotools.text as _

    parser = audiotools.OptionParser(
        usage=_.USAGE_AT_CONFIG,
        version="Python Audio Tools %s" % (audiotools.VERSION))

    system = audiotools.OptionGroup(parser, _.OPT_CAT_SYSTEM)

    system.add_option('-c', '--cdrom',
                      action='store',
                      dest='system_cdrom',
                      metavar='PATH')

    system.add_option('--cdrom-read-offset',
                      action='store',
                      type='int',
                      metavar='INT',
                      dest='system_cdrom_read_offset',
                      help=_.OPT_AT_CONFIG_READ_OFFSET)

    system.add_option('--cdrom-write-offset',
                      action='store',
                      type='int',
                      metavar='INT',
                      dest='system_cdrom_write_offset',
                      help=_.OPT_AT_CONFIG_WRITE_OFFSET)

    system.add_option(
        '--fs-encoding',
        action='store',
        metavar='ENCODING',
        dest='system_fs_encoding',
        help=_.OPT_AT_CONFIG_FS_ENCODING)

    system.add_option(
        '--io-encoding',
        action='store',
        metavar='ENCODING',
        dest='system_io_encoding',
        help=_.OPT_AT_CONFIG_IO_ENCODING)

    parser.add_option_group(system)

    transcoding = audiotools.OptionGroup(parser, _.OPT_CAT_TRANSCODING)

    transcoding.add_option(
        '-t', '--type',
        action='store',
        dest='type',
        choices=sorted(audiotools.TYPE_MAP.keys() + ['help']),
        help=_.OPT_TYPE_AT_CONFIG)

    transcoding.add_option(
        '-q', '--quality',
        action='store',
        type='string',
        dest='quality',
        help=_.OPT_QUALITY_AT_CONFIG)

    transcoding.add_option(
        '--format',
        action='store',
        metavar='FORMAT',
        dest='filename_format',
        help=_.OPT_FORMAT)

    transcoding.add_option(
        '-j', '--joint',
        action='store',
        type='int',
        metavar='MAX_PROCESSES',
        dest='system_maximum_jobs',
        help=_.OPT_JOINT)

    parser.add_option_group(transcoding)

    lookup = audiotools.OptionGroup(parser, _.OPT_CAT_CD_LOOKUP)

    lookup.add_option(
        '--use-musicbrainz',
        metavar='yes/no',
        choices=("yes", "no"),
        dest='use_musicbrainz')

    lookup.add_option(
        '--musicbrainz-server',
        action='store',
        metavar='HOSTNAME',
        dest='musicbrainz_server')

    lookup.add_option(
        '--musicbrainz-port',
        action='store',
        metavar='PORT',
        type='int',
        dest='musicbrainz_port')

    lookup.add_option(
        '--use-freedb',
        metavar='yes/no',
        choices=("yes", "no"),
        dest='use_freedb')

    lookup.add_option(
        '--freedb-server',
        action='store',
        metavar='HOSTNAME',
        dest='freedb_server')

    lookup.add_option(
        '--freedb-port',
        action='store',
        metavar='PORT',
        type='int',
        dest='freedb_port')

    parser.add_option_group(lookup)

    id3 = audiotools.OptionGroup(parser, _.OPT_CAT_ID3)

    id3.add_option(
        '--id3v2-version',
        action='store',
        type='choice',
        choices=('id3v2.2', 'id3v2.3', 'id3v2.4', 'none'),
        dest='id3v2_version',
        metavar='VERSION',
        help=_.OPT_AT_CONFIG_ID3V2_VERSION)

    id3.add_option(
        '--id3v1-version',
        action='store',
        type='choice',
        choices=('id3v1.1', 'none'),
        dest='id3v1_version',
        metavar='VERSION',
        help=_.OPT_AT_CONFIG_ID3V1_VERSION)

    id3.add_option(
        '--id3v2-pad',
        action='store',
        type='choice',
        choices=('yes', 'no'),
        dest='id3_digit_padding',
        metavar='yes / no',
        help=_.OPT_AT_CONFIG_ID3V2_PAD)

    parser.add_option_group(id3)

    replaygain = audiotools.OptionGroup(parser, _.OPT_CAT_REPLAYGAIN)

    replaygain.add_option(
        '--replay-gain',
        action='store',
        type='choice',
        choices=('yes', 'no'),
        dest='add_replaygain',
        metavar='yes / no',
        help=_.OPT_REPLAY_GAIN)

    parser.add_option_group(replaygain)

    binaries = audiotools.OptionGroup(parser, _.OPT_CAT_BINARIES)

    bins = set([])
    for audioclass in audiotools.AVAILABLE_TYPES:
        for binary in audioclass.BINARIES:
            bins.add(binary)

    for binary in sorted(list(bins)):
        binaries.add_option('--' + binary,
                            action='store',
                            metavar='PATH',
                            dest='binary_' + binary)

    parser.add_option_group(binaries)

    parser.add_option(
        '-I', '--interactive',
        action='store_true',
        default=False,
        dest='interactive',
        help=_.OPT_INTERACTIVE_OPTIONS)

    parser.add_option(
        '-V', '--verbose',
        action='store',
        dest='verbosity',
        choices=audiotools.VERBOSITY_LEVELS,
        default=audiotools.DEFAULT_VERBOSITY,
        help=_.OPT_VERBOSE_AT_CONFIG)

    (options, args) = parser.parse_args()

    msg = audiotools.Messenger("audiotools-config", None)

    if (len(sys.argv) < 2):
        #no arguments at all so display current default

        display_defaults(msg)
    elif (options.interactive):
        #update options interactively

        if (not audiotools.ui.AVAILABLE):
            audiotools.ui.not_available_message(msg)
            sys.exit(1)
        else:
            #run interactive widget here
            #and apply options if widget isn't cancelled
            #FIXME
            raise NotImplementedError()
    else:
        #update options non-interactively

        #verify --format is valid, if present
        if (options.filename_format is not None):
            try:
                audiotools.AudioFile.track_name(
                    file_path="",
                    track_metadata=audiotools.MetaData(),
                    format=options.filename_format)
            except audiotools.UnsupportedTracknameField, err:
                err.error_msg(msg)
                sys.exit(1)
            except audiotools.InvalidFilenameFormat, err:
                msg.error(unicode(err))
                sys.exit(1)

        #verify --type is valid, if present
        if (options.type == 'help'):
            audiotools.ui.show_available_formats(msg)
            sys.exit(0)
        elif (options.type is not None):
            AudioType = audiotools.TYPE_MAP[options.type]
        else:
            AudioType = audiotools.TYPE_MAP[audiotools.DEFAULT_TYPE]

        #verify --quality is valid for type, if present
        if (options.quality == 'help'):
            audiotools.ui.show_available_qualities(msg, AudioType)
            sys.exit(0)
        elif ((options.quality is not None) and
              (options.quality not in AudioType.COMPRESSION_MODES)):
            msg.error(_.ERR_UNSUPPORTED_COMPRESSION_MODE %
                      {"quality": options.quality,
                       "type": AudioType.NAME})
            sys.exit(1)

        #verify --joint is positive, if present
        if ((options.system_maximum_jobs is not None) and
            (options.system_maximum_jobs < 1)):
            msg.error(_.ERR_INVALID_JOINT)
            sys.exit(1)

        #apply options non-interactively
        apply_options(options, audiotools.config)

        configpath = os.path.expanduser('~/.audiotools.cfg')
        try:
            configfile = open(configpath, 'w')
            audiotools.config.write(configfile)
            configfile.close()
            msg.info(_.LAB_AT_CONFIG_FILE_WRITTEN %
                     (audiotools.Filename(configpath),))
        except IOError, err:
            msg.error(_.ERR_OPEN_IOERROR % (audiotools.Filename(configpath),))
            sys.exit(1)
