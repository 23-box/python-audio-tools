%This work is licensed under the
%Creative Commons Attribution-Share Alike 3.0 United States License.
%To view a copy of this license, visit
%http://creativecommons.org/licenses/by-sa/3.0/us/ or send a letter to
%Creative Commons,
%171 Second Street, Suite 300,
%San Francisco, California, 94105, USA.

\chapter{Meridian Lossless Packing}

An MLP file is comprised of a series of frames.
Each frame contains one or two substreams, each storing a different
set of channels (e.g. $\text{Substream}_1$ may have channels 1-2,
$\text{Substream}_2$ may have channels 3-6, and so on).
Each substream contains one or more blocks.
Finally, each block contains \VAR{Block Data} residuals
and, optionally, decoding information.
\begin{figure}[h]
\includegraphics{figures/mlp_stream.pdf}
\end{figure}
\par
\noindent
\VAR{Total Frame Size} is the size of the entire frame,
including the header, in bytes.
\par
The first frame will contain a \VAR{Major Sync} with information
such as sample rate, bits-per-sample, substream count and so forth.
This information will be constant throughout the stream,
so most of the subsequent MLP frames will not have a sync.

\section{MLP Decoding}

The basic principle of MLP decoding is that we read in a
set of decoding parameters for the first block and use those
as arguments for decoding the block data itself.
Subsequent blocks may may contain truncated parameters
indicating only which arguments have changed so that the
next block can be decoded.

Decoded blocks are concatenated into a stream of PCM frames,
each with one or more channels which comprise an entire substream.

The channels of all decoded substreams
(each with an identical number of PCM frames) are then combined
into a single set of PCM frames and returned.

\clearpage

\subsection{The Major Sync}
\VAR{Major Sync} is an optional frame header:
\begin{figure}[h]
\includegraphics{figures/mlp_major_sync.pdf}
\end{figure}
\par
\noindent
We detect a \VAR{Major Sync} by reading a 24-bit \VAR{Sync Words} value
and 8-bit \VAR{Stream Type} value from the stream.
If \texttt{0xF8726F} and \texttt{0xBB}, respectively, we can
read the remainder of the sync.
Otherwise, we must `back up' 32 bits and continue reading substream size
and substream data values from the stream.
If a \VAR{Major Sync} is not present in a frame,
we use the values from the previous sync.
\vskip .25in
\par
\noindent
\begin{tiny}
\begin{tabular}{|c|r|r||c|r||c|r|}
\hline
Value & Bits per Sample & Sample Rate & Value & Channels & Value & Channels \\
\hline
\texttt{0000} & 16 & 48000 & \texttt{00000} & 1 & \texttt{10000} & 5 \\
\texttt{0001} & 20 & 96000 & \texttt{00001} & 2 & \texttt{10001} & 6 \\
\texttt{0010} & 24 & 192000 & \texttt{00010} & 3 & \texttt{10010} & 5 \\
\texttt{0011} & & 384000 & \texttt{00011} & 4 & \texttt{10011} & 5 \\
\texttt{0100} & & 768000 & \texttt{00100} & 3 & \texttt{10100} & 6 \\
\texttt{0101} & & 1536000 & \texttt{00101} & 4 & & \\
\texttt{0110} & & 3072000 & \texttt{00110} & 5 & & \\
\texttt{0111} & & & \texttt{00111} & 3 & & \\
\texttt{1000} & & 44100 & \texttt{01000} & 4 & & \\
\texttt{1001} & & 88200 & \texttt{01001} & 5 & & \\
\texttt{1010} & & 176400 & \texttt{01010} & 4 & & \\
\texttt{1011} & & 352800 & \texttt{01011} & 5 & & \\
\texttt{1100} & & 705600 & \texttt{01100} & 6 & & \\
\texttt{1101} & & 1411200 & \texttt{01101} & 4 & & \\
\texttt{1110} & & 2822400 & \texttt{01110} & 5 & & \\
\texttt{1111} & & & \texttt{01111} & 4 & & \\
\hline
\end{tabular}
\end{tiny}

\subsection{Substream Size}
There is one \VAR{Substream Size} header per frame substream
(as indicated in the \VAR{Major Sync}).
\begin{figure}[h]
\includegraphics{figures/mlp_substream_size.pdf}
\end{figure}
\par
\noindent
\VAR{Substream Size} is the size of the entire substream,
\textit{not} including the header.

\clearpage

\subsection{Substream Data}

\begin{figure}[h]
\includegraphics{figures/mlp_substream.pdf}
\end{figure}
We continue to read blocks until a block's \VAR{Last} bit is set.
Each block is prefixed by a \VAR{Parameters Present} bit.
If set, the block has an optional \VAR{Restart Header} block
(indicated by the prefixed \VAR{Header Present} bit)
and required \VAR{Decoding Parameters} block.
If \VAR{Parameters Present} is not set, we continue directly to
\VAR{Block Data} - using the most recently read set of parameters for
decoding.

Once all the blocks have been read, we align the stream to a
mulitple of 16-bits.
Then, if \VAR{Checkdata Present} has been indicated in the
\VAR{Substream Size} header, we read a 16-bit checksum.

\subsection{Restart Header}
\begin{figure}[h]
\includegraphics{figures/mlp_restart_header.pdf}
\end{figure}
\par
\noindent
There are \VAR{Max Matrix Channel} + 1 number of
unsigned 6-bit \VAR{Channel Assignment} values.
\VAR{Min Channel} and \VAR{Max Channel} indicate the substream's
range of channels.
The total number of channels in a given substream is:
\begin{equation*}
(\text{Max Channel} - \text{Min Channel}) + 1
\end{equation*}

Once a restart header is seen, the \VAR{Decoding Parameters} are
immediately reset to their default values.

\clearpage

\subsection{Decoding Parameters}

Reading the decoding parameters requires 8, 1-bit
\VAR{Parameter Presence Flags}.
If the flag for a particular parameter is set,
\textit{and} the parameter's prefixed \VAR{Present}
bit is set, we go ahead and read that parameter.
Note that the first decoding parameter is the \VAR{Parameter Presence Flags}
value itself.

\begin{figure}[h]
\includegraphics{figures/mlp_decoding_params.pdf}
\end{figure}
\par
\noindent
There is one optional \VAR{Channel Parameters} block per
substream channel.
Again, each is prefixed by a single \VAR{Present} bit.

\subsubsection{Parameter Presence Flags}

\begin{figure}[h]
\includegraphics{figures/mlp_parameter_presence_flags.pdf}
\end{figure}
\par
\noindent
By default, all 8 flags are all set.
The \VAR{Huffman Offset}, \VAR{IIR Filter Parameters} and
\VAR{FIR Filter Parameters} flags are checked while
reading \VAR{Channel Parameters}.

\subsubsection{Block Size}

This is the size of the block in PCM frames.
Its value is 8 by default.

\clearpage

\subsubsection{Matrix Parameters}

%% If \VAR{Matrix Parameters} is indicated during parameter decoding:

\begin{figure}[h]
\includegraphics{figures/mlp_matrix_params.pdf}
\end{figure}
\par
\noindent
There are \VAR{Matrix Count} number of matrices.
There is one coefficient per \VAR{Max Matrix Channel} + 3.
The size of each signed matrix coefficient is \VAR{Fractional Bits} + 2
and its value is calculated as:
\begin{equation*}
\text{Matrix Coefficient}_i = \text{Signed Value}_i \times 2 ^ {14 - \text{Fractional Bits}}
\end{equation*}
If the preceding \VAR{Present} bit is \textit{not} set,
the value of $\text{Matrix Coefficient}_i$ is 0.
If \VAR{Matrix Parameters} is \textit{not} indicated during parameter decoding,
treat \VAR{Matrix Count} as 0 by default.

\subsubsection{Output Shifts}

%% If \VAR{Output Shifts} is indicated during parameter decoding:

\begin{figure}[h]
\includegraphics{figures/mlp_output_shifts.pdf}
\end{figure}
\par
\noindent
There are \VAR{Max Matrix Channel} + 1 number of shift values
(from the restart header).
Each is a signed, 4-bit value.
\par
If \VAR{Output Shifts} is \textit{not} indicated during parameter
decoding, all $\text{Output Shift}_i$ values are 0 by default.


\subsubsection{Quant Step Sizes}

%% If \VAR{Quant Step Sizes} is indicated during parameter decoding:
\begin{figure}[h]
\includegraphics{figures/mlp_quant_steps.pdf}
\end{figure}
\par
\noindent
There is one \VAR{Quant Step Size} value per substream channel.
Each is an unsigned, 4-bit value.
\par
If \VAR{Quant Step Sizes} is \textit{not} indicated during parameter
decoding, all $\text{Quant Step Size}_i$ values are 0 by default.

\clearpage

\subsubsection{Channel Parameters}

\begin{figure}[h]
\includegraphics{figures/mlp_channel_parameters.pdf}
\end{figure}
\par
\noindent
Remember that the optional \VAR{FIR Filter Parameters},
\VAR{IIR Filter Parameters} and \VAR{Huffman Offset}
values are read only if the corresponding \VAR{Parameter Presence Flag}
is set.

\VAR{Codebook} and \VAR{Huffman Least-Significant Bits} are unsigned values.
\VAR{Huffman Offset} is a signed value.
\VAR{Signed Huffman Offset} is calculated as follows:
\begin{align*}
\intertext{If $\text{Codebook} > 0$:}
\text{LSB Bits} &= \text{Huffman Least-Significant Bits} - \text{Quant Step Size}_{\text{channel}} \\
\text{Sign Shift} &= \text{LSB Bits} + 2 - \text{Codebook} \\
\text{Signed Huffman Offset} &=
\begin{cases}
\text{Huffman Offset} - 7 \times 2 ^ {\text{LSB Bits}} - 2 ^ {\text{Sign Shift}} & \text{if Sign Shift} \geq 0 \\
\text{Huffman Offset} - 7 \times 2 ^ {\text{LSB Bits}} & \text{if Sign Shift} < 0
\end{cases}
\intertext{If $\text{Codebook} = 0$:}
\text{LSB Bits} &= \text{Huffman Least-Significant Bits} - \text{Quant Step Size}_{\text{channel}} \\
\text{Sign Shift} &= \text{LSB Bits} - 1 \\
\text{Signed Huffman Offset} &=
\begin{cases}
\text{Huffman Offset} - 2 ^ {\text{Sign Shift}} & \text{if Sign Shift} \geq 0 \\
\text{Huffman Offset} & \text{if Sign Shift} < 0
\end{cases}
\end{align*}
The \VAR{Signed Huffman Offset} will be added to each decoded residual
during block decoding.

By default, \VAR{Signed Huffman Offset} is $-2 ^ {23}$, \VAR{Codebook} is 0
and \VAR{Huffman Least-Significant Bits} is 23.

\clearpage

\subsubsection{FIR Filter Parameters}
\begin{figure}[h!]
\includegraphics{figures/mlp_filter_params_fir.pdf}
\end{figure}
\par
\noindent
If \VAR{Order} is 0, we forego reading the rest of the filter parameters.
Otherwise, \VAR{Shift}, \VAR{Coefficient Bits} and \VAR{Coefficient Shift}
are unsigned values - the latter two are used for reading
\VAR{Order} number of signed values
which we convert to filter coefficients as follows:
\begin{equation*}
\text{FIR Filter Coefficient}_i = \text{Signed Coeff}_i \times 2 ^ {\text{Coefficient Shift}}
\end{equation*}
We're primarily interested in the \VAR{Shift} and \VAR{FIR Filter Coefficient}
values, which will be used for filtering decoded residuals.

Note that the \VAR{Set State} value must be 0.  By default,
\VAR{Shift} is 0 and the signed coefficient list is empty.

\subsubsection{IIR Filter Parameters}
\begin{figure}[h]
\includegraphics{figures/mlp_filter_params_iir.pdf}
\end{figure}

As with FIR, if \VAR{Order} is 0, we forego reading the rest of the
filter parameters.
Otherwise, \VAR{Shift}, \VAR{Coefficient Bits} and \VAR{Coefficient Shift}
are unsigned values - the latter two are used for reading
\VAR{Order} number of signed coefficient values
which we convert to filter coefficients as follows:
\begin{equation*}
\text{IIR Filter Coefficient}_i = \text{Signed Coeff}_i \times 2 ^ {\text{Coefficient Shift}}
\end{equation*}
If \VAR{Set State} is 1, we also read \VAR{Order} number of signed state
values which we convert as follows:
\begin{equation*}
\text{State}_i = \text{Signed State}_i \times 2 ^ {\text{State Shift}}
\end{equation*}
We're primarily interested in the \VAR{Shift} and \VAR{IIR Filter Coefficient}
and \VAR{State} values which will be used for filtering decoded residuals.

By default, \VAR{Shift} is 0 and the signed coefficient list is empty.

\clearpage

\subsection{Block Data}

The block data of a given substream block is the residuals
from which our original samples will be reconstructed.
Residuals are interleaved between substream channels.
That is, given a 2 channel substream, $\text{Residual}_1$ is
on $\text{Channel}_1$, $\text{Residual}_2$ is on $\text{Channel}_2$,
$\text{Residual}_3$ is on $\text{Channel}_1$ and so forth.
Furthermore, for each \VAR{Matrix Parameter} in the substream,
if \VAR{LSB Bypass} is set in that parameter,
one must read a \VAR{Bypassed LSB} bit per PCM frame's worth of
residuals prior to reading the residuals themselves.

\begin{figure}[h]
\includegraphics{figures/mlp_residuals.pdf}
\end{figure}

Decoding a given residual value requires the
\VAR{Codebook}, \VAR{Huffman Least-Significant Bits} and
\VAR{Signed Huffman Offset} values from its \VAR{Channel Parameters},
as well as the \VAR{Quant Step Size} for that residual's channel.
First, given a positive \VAR{Codebook} value, we decode a Huffman value
from the bit stream as indiciated by the trees on page
\pageref{mlp_codebooks}.
This value is our \VAR{Most-Signicant Bits} (MSB).
If \VAR{Codebook} is 0, our \VAR{Most-Significant Bits} are also 0.

We then calculate our least-significant bit count as:
\begin{equation*}
\text{LSB Count}_c = \text{Huffman Least-Significant Bits}_c - \text{Quant Step Size}_c
\end{equation*}
We read this number of bits from the stream as
our \VAR{Least-Significant Bits} (LSB) value.
If $\text{LSB Count}_c$ is 0, we read no bits from the stream and our
\VAR{Least-Significant Bits} value is also 0.

Our final residual value is calculated as follows:
\begin{equation*}
\text{Residual}_i = ((\text{MSB}_i \times 2 ^ {\text{LSB Count}_i}) + \text{LSB}_i + \text{Signed Huffman Offset}_c) \times 2 ^ {\text{Quant Step Size}_c}
\end{equation*}

Note that if \VAR{Codebook} is 0 \textit{and} our $\text{LSB Count}_c$ is 0,
we read no bits from the stream and $\text{Residual}_i$ is 0.
This is how MLP stores large runs of 0 residuals.

\clearpage

\begin{figure}[h]
\label{mlp_codebooks}
\includegraphics{figures/mlp_codebook1.pdf}
\caption{Codebook 1}
\includegraphics{figures/mlp_codebook2.pdf}
\caption{Codebook 2}
\includegraphics{figures/mlp_codebook3.pdf}
\caption{Codebook 3}
\end{figure}

%% \subsubsection{Codebooks}
%% \begin{table}[h]
%% \begin{tabular}{|r|r||r|r||r|r|}
%% \hline
%% \multicolumn{2}{|c||}{Codebook 1} &
%% \multicolumn{2}{c||}{Codebook 2} &
%% \multicolumn{2}{c|}{Codebook 3} \\
%% Pattern & Value & Pattern & Value & Pattern & Value \\
%% \hline
%% \texttt{000000001} & 0 &
%% \texttt{000000001} & 0 &
%% \texttt{000000001} & 0 \\
%% \texttt{00000001} & 1 &
%% \texttt{00000001} & 1 &
%% \texttt{00000001} & 1 \\
%% \texttt{0000001} & 2 &
%% \texttt{0000001} & 2 &
%% \texttt{0000001} & 2 \\
%% \texttt{000001} & 3 &
%% \texttt{000001} & 3 &
%% \texttt{000001} & 3 \\
%% \texttt{00001} & 4 &
%% \texttt{00001} & 4 &
%% \texttt{00001} & 4 \\
%% \texttt{0001} & 5 &
%% \texttt{0001} & 5 &
%% \texttt{0001} & 5 \\
%% \texttt{001} & 6 &
%% \texttt{001} & 6 &
%% \texttt{001} & 6 \\
%% \texttt{100} & 7 &
%% \texttt{10} & 7 &
%% \texttt{1} & 7 \\
%% \texttt{101} & 8 &
%% \texttt{11} & 8 &
%% \texttt{011} & 8 \\
%% \texttt{110} & 9 &
%% \texttt{011} & 9 &
%% \texttt{0101} & 9 \\
%% \texttt{111} & 10 &
%% \texttt{0101} & 10 &
%% \texttt{01001} & 10 \\
%% \texttt{011} & 11 &
%% \texttt{01001} & 11 &
%% \texttt{010001} & 11 \\
%% \texttt{0101} & 12 &
%% \texttt{010001} & 12 &
%% \texttt{0100001} & 12 \\
%% \texttt{01001} & 13 &
%% \texttt{0100001} & 13 &
%% \texttt{01000001} & 13 \\
%% \texttt{010001} & 14 &
%% \texttt{01000001} & 14 &
%% \texttt{010000001} & 14 \\
%% \texttt{0100001} & 15 &
%% \texttt{010000001} & 15 &
%% & \\
%% \texttt{01000001} & 16 &
%% & & & \\
%% \texttt{010000001} & 17 &
%% & & & \\
%% \hline
%% \end{tabular}
%% \end{table}

\clearpage

\subsection{Channel Filtering}

Given a channel's decoded block residuals, we then filter those residuals
with the channel's FIR and IIR filters from its \VAR{Decoding Parameters}.
In particular, we'll need the \VAR{FIR Order}, \VAR{FIR Coefficients},
\VAR{IIR Order}, \VAR{IIR Coefficients}, \VAR{IIR State} and
\VAR{Shift}\footnote{If both both FIR filter and IIR filter
have a positive number of coefficients, their \VAR{Shift} values must be
identical}
parameters.

Note that the \VAR{Filtered} values below 0 are taken from the previously
decoded block while \VAR{Residual} values below 0 are taken from
\VAR{IIR State}.
\begin{align*}
\text{FIR Sum}_i &= \overset{\text{FIR Order} - 1}{\underset{j = 0}{\sum}}{\text{FIR Coefficient}_j \times \text{Filtered}_{i - j - 1}} \\
\text{IIR Sum}_i &= \overset{\text{IIR Order} - 1}{\underset{k = 0}{\sum}}{\text{IIR Coefficient}_k \times \text{Residual}_{i - k - 1}} \\
\text{Filtered}_i &= \left\lfloor\frac{\text{FIR Sum}_i + \text{IIR Sum}_i}{2 ^ {\text{Shift}}}\right\rfloor + \text{Residual}_i
\end{align*}
For instance, given the values:
\par
\noindent
\begin{tabular}{l c r l c r l c r}
FIR Order & = & 4 &
IIR Order & = & 3 &
$\text{Filtered}_{-4}$ & = & -40 \\
$\text{FIR Coefficient}_0$ & = & 556 &
$\text{IIR Coefficient}_0$ & = & -122 &
$\text{Filtered}_{-3}$ & = & -39 \\
$\text{FIR Coefficient}_1$ & = & -493 &
$\text{IIR Coefficient}_1$ & = & 102 &
$\text{Filtered}_{-2}$ & = & 0 \\
$\text{FIR Coefficient}_2$ & = & 288 &
$\text{IIR Coefficient}_2$ & = & -192 &
$\text{Filtered}_{-1}$ & = & 18 \\
$\text{FIR Coefficient}_3$ & = & -96 &
$\text{IIR State}_0$ & = & 12 &
$\text{Residual}_0$ & = & 34 \\
$\text{Shift}$ & = & 8 &
$\text{IIR State}_1$ & = & 20 &
$\text{Residual}_1$ & = & 9 \\
& & &
$\text{IIR State}_2$ & = & -8 &
$\text{Residual}_2$ & = & -23 \\
\end{tabular}
\par
\noindent
Our filtered values are as follows:
\begin{align*}
\text{FIR Sum}_0 &= (556 \times 18) + (-493 \times 0) + (288 \times -39) + (-96 \times -40) = 2616 \\
\text{IIR Sum}_0 &= (-122 \times 12) + (102 \times 20) + (-192 \times -8) = 2112 \\
\text{Filtered}_0 &= \left\lfloor\frac{2616 + 2112}{2 ^ 8}\right\rfloor + 34 = \textbf{52} \\
\text{FIR Sum}_1 &= (556 \times 52) + (-493 \times 18) + (288 \times 0) + (-96 \times -39) = 23782 \\
\text{IIR Sum}_1 &= (-122 \times 34) + (102 \times 12) + (-192 \times 20) = -6764 \\
\text{Filtered}_1 &= \left\lfloor\frac{23782 - 6764}{2 ^ 8}\right\rfloor + 9 = \textbf{75} \\
\text{FIR Sum}_2 &= (556 \times 75) + (-493 \times 52) + (288 \times 18) + (-96 \times 0) = 21248 \\
\text{IIR Sum}_2 &= (-122 \times 9) + (102 \times 34) + (-192 \times 12) = 66 \\
\text{Filtered}_2 &= \left\lfloor\frac{21248 + 66}{2 ^ 8}\right\rfloor - 23 = \textbf{60} \\
\end{align*}

\clearpage

\subsection{Channel Rematrixing}

Finally, given our filtered channel values and a set of matrix parameters,
we ``rematrix'' those values into the final PCM values.
This is a form of cross-channel decorrelation, roughly analagous
to FLAC's mid-side channel assignment.

\subsubsection{Noise Channels}

First, we generate two noise channels, each containing
\VAR{Block Size} number of noise samples, using the
\VAR{Noise Gen Seed} and \VAR{Noise Shift} (all taken from the
current \VAR{Restart Header}).
This requires a simple crop function:
\begin{equation*}
\text{crop}(x) =
\begin{cases}
x \bmod{256} & \text{if } \lfloor (x \bmod{256}) \div 128\rfloor = 0 \\
(x \bmod{128}) - 2 ^ 7 & \text{if } \lfloor (x \bmod{256}) \div 128\rfloor > 0
\end{cases}
\end{equation*}

\begin{align*}
\text{Shifted}_i &= \lfloor\text{Seed}_i \div 2 ^ 7\rfloor \bmod{\texttt{0x10000}} \\
\text{Noise}_{i~1} &= \text{crop}(\lfloor\text{Seed}_i \div 2 ^ {15}\rfloor) \times 2 ^ {\text{Noise Shift}} \\
\text{Noise}_{i~2} &= \text{crop}(\text{Shifted}_i) \times 2 ^ {\text{Noise Shift}} \\
\text{Seed}_{i + 1} &= ((\text{Seed}_i \times 2 ^ {16}) \bmod{\texttt{0x100000000}}) \xor \text{Shifted}_i \xor \text{Shifted}_i \times 2 ^ 5
\end{align*}
For example, given a \VAR{Noise Gen Seed} of 7855724 and a
\VAR{Noise Shift} of 0, our first couple of noise samples are
as follows:
\begin{align*}
\text{Seed}_0 &= 7855724 \\
\text{Shifted}_0 &= \lfloor 7855724 \div 2 ^ 7\rfloor \bmod{\texttt{0x10000}} = 61372 \\
\text{Noise}_{0~1} &= \text{crop}(\lfloor 7855724 \div 2 ^ {15}\rfloor) \times 2 ^ 0 = \text{crop}(239) \times 1 = \textbf{-17} \\
\text{Noise}_{0~2} &= \text{crop}(61372) \times 2 ^ 0 = \textbf{-68} \\
\text{Seed}_1 &= ((7855724 \times 2 ^ {16}) \bmod{\texttt{0x100000000}}) \xor 61372 \xor 61372 \times 2 ^ 5 \\
&= 3731619840 \xor 61372 \xor 1963904 = 3731953724 \\
\text{Shifted}_1 &= \lfloor 3731953724 \div 2 ^ 7 \rfloor \bmod{\texttt{0x10000}} = 57904 \\
\text{Noise}_{1~1} &= \text{crop}(\lfloor 3731953724 \div 2 ^ {15}\rfloor) \times 2 ^ 1 = \text{crop}(113890) \times 1 = \textbf{-30} \\
\text{Noise}_{1~2} &= \text{crop}(57904) \times 2 ^ 0 = \textbf{48} \\
\text{Seed}_2 &= ((3731953724 \times 2 ^ {16}) \bmod{\texttt{0x100000000}}) \xor 57904 \xor 57904 \times 2 ^ 5 \\
&= 406585344 \xor 57904 \xor 1852928 = 404792368
\end{align*}

\clearpage

\subsubsection{Rematrixing}

Performing the actual rematrixing requires appending the two
noise channels to the end of each PCM frame of filtered residual data.
That is, for a 2 channel stream:
\par
\noindent
\begin{tabular}{r c r}
$\text{Frame}_{i~1}$ & = & $\text{Filtered}_{i~1}$ \\
$\text{Frame}_{i~2}$ & = & $\text{Filtered}_{i~2}$ \\
$\text{Frame}_{i~3}$ & = & $\text{Noise}_{i~1}$ \\
$\text{Frame}_{i~4}$ & = & $\text{Noise}_{i~2}$
\end{tabular}
\par
\noindent
The calculation for the matrix's output sample is then as follows:
\begin{equation*}
\text{Frame}_{i~\text{Channel}} = \left\lfloor\frac{\overset{\text{Channel Count + 2}}{\underset{j = 1}{\sum}}{\text{Frame}_{i~j} \times \text{Matrix Coefficient}_j}}{2 ^ {14}}\right\rfloor + \text{Bypassed LSB}_i
\end{equation*}
Note that the two noise channels are the reason we read
\VAR{Max Matrix Channel} + 3 number of matrix coefficients
instead of one coefficient per channel as one might expect.
Also note that the \VAR{Bypassed LSB} bit we read in the
\VAR{Block Data} for each PCM frame reappears at this point.
So, given the following values:
\par
\noindent
\begin{tabular}{r c r r c r}
$\text{Filtered}_{0~1}$ & = & -54372 &
$\text{Matrix Coefficient}_1$ & = & -16384 \\
$\text{Filtered}_{0~2}$ & = & 169057 &
$\text{Matrix Coefficient}_2$ & = & 6144 \\
$\text{Noise}_{0~1}$ & = & -17 &
$\text{Matrix Coefficient}_3$ & = & 0 \\
$\text{Noise}_{0~2}$ & = & -68 &
$\text{Matrix Coefficient}_4$ & = & 0 \\
$\text{Filtered}_{1~1}$ & = & -92558 &
$\text{Bypassed LSB}_0$ & = & 0 \\
$\text{Filtered}_{1~2}$ & = & 118830 &
$\text{Bypassed LSB}_1$ & = & 0 \\
$\text{Noise}_{1~1}$ & = & -30 &
Channel Count & = & 2 \\
$\text{Noise}_{1~2}$ & = & -48 &
Out Channel & = & 0
\end{tabular}
\par
\noindent
Our new values for channel 1 (\VAR{Out Channel} + 1) are calculated as follows:
\begin{align*}
\text{Frame}_{0~1} &= \left\lfloor\frac{(-54372 \times -16384) + (169057 \times 6144) + (-17 \times 0) + (-68 \times 0)}{2 ^ {14}}\right\rfloor + 0 \\
&= \left\lfloor\frac{1929517056}{16384}\right\rfloor = \textbf{117768} \\
\text{Frame}_{1~1} &= \left\lfloor\frac{(-92558 \times -16384) + (118830 \times 6144) + (-30 \times 0) + (-48 \times 0)}{2 ^ {14}}\right\rfloor + 0 \\
&= \left\lfloor\frac{2246561792}{16384}\right\rfloor = \textbf{137119} \\
\end{align*}
The values for channel 2 remain unchanged as 169057 and 118830, respectively.
\par
Note that because the top 2 \VAR{Matrix Coefficient} values are 0,
the values from the 2 noise channels don't actually affect the
calculation whatsoever.
This is not an unusual case.
