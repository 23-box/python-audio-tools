%This work is licensed under the
%Creative Commons Attribution-Share Alike 3.0 United States License.
%To view a copy of this license, visit
%http://creativecommons.org/licenses/by-sa/3.0/us/ or send a letter to
%Creative Commons,
%171 Second Street, Suite 300,
%San Francisco, California, 94105, USA.

\chapter{Ogg Vorbis}
\label{vorbis}
Ogg Vorbis is a set of Vorbis audio packets
in an \hyperref[ogg]{Ogg container}.
All of the fields within Ogg Vorbis are little-endian.

\begin{figure}[h]
\includegraphics{figures/vorbis/stream.pdf}
\end{figure}

\clearpage

\subsection{the Identification Packet}
The first packet within a Vorbis stream is the \VAR{Identification} packet.
This contains the sample rate and number of channels.
Vorbis does not have a bits-per-sample field, as samples
are stored internally as floating point values and are
converted into a certain number of bits in the decoding process.
To find the total samples, use the \VAR{Granule Position} value
in the stream's final Ogg page.
\par
\noindent
{\relsize{-1}
\ALGORITHM{the first Ogg packet}{Vorbis identification information}
\SetKwData{CHANNELS}{channels}
\SetKwData{SAMPLERATE}{sample rate}
\SetKwData{BITRATEMAX}{bitrate maximum}
\SetKwData{BITRATENOM}{bitrate nominal}
\SetKwData{BITRATEMIN}{bitrate minimum}
\SetKwData{BLOCKSIZE}{block size}
\ASSERT $(\text{\READ 8 unsigned bits}) = 1$\tcc*[r]{packet type}
\ASSERT $(\text{\READ 6 bytes}) = \texttt{"vorbis"}$\;
\BlankLine
\ASSERT $(\text{\READ 32 unsigned bits}) = 0$\tcc*[r]{Vorbis version}
$\CHANNELS \leftarrow$ \READ 8 unsigned bits\;
\ASSERT $\CHANNELS > 0$\;
$\SAMPLERATE \leftarrow$ \READ 32 unsigned bits\;
\ASSERT $\SAMPLERATE > 0$\;
$\BITRATEMAX \leftarrow$ \READ 32 signed bits\;
$\BITRATENOM \leftarrow$ \READ 32 signed bits\;
$\BITRATEMIN \leftarrow$ \READ 32 signed bits\;
$\text{\BLOCKSIZE}_0 \leftarrow 2 ^ {(\text{\READ 4 unsigned bits)}}$\;
\ASSERT $\text{\BLOCKSIZE}_0$ \IN \texttt{[64, 128, 256, 512, 1024, 2048, 4096, 8192]}\;
$\text{\BLOCKSIZE}_1 \leftarrow 2 ^ {(\text{\READ 4 unsigned bits})}$\;
\ASSERT $\text{\BLOCKSIZE}_1$ \IN \texttt{[64, 128, 256, 512, 1024, 2048, 4096, 8192]}\;
\ASSERT $\text{\BLOCKSIZE}_0 \leq \text{\BLOCKSIZE}_1$\;
\ASSERT $\text{(\READ 1 unsigned bit)} = 1$\tcc*[r]{framing bit}
\BlankLine
\Return $\left\lbrace\begin{tabular}{l}
\CHANNELS \\
\SAMPLERATE \\
\BITRATEMAX \\
\BITRATENOM \\
\BITRATEMIN \\
\BLOCKSIZE \\
\end{tabular}\right.$\;
\EALGORITHM
}
\begin{figure}[h]
\includegraphics{figures/vorbis/identification.pdf}
\end{figure}

\clearpage

\subsection{the Comment Packet}
\label{vorbiscomment}
The second packet within a Vorbis stream is the Comment packet.
\par
\noindent
{\relsize{-1}
\ALGORITHM{the second Ogg packet}{Vorbis comment information}
\SetKwData{VENLENGTH}{vendor string length}
\SetKwData{VENSTRING}{vendor string}
\SetKwData{COMCOUNT}{commment string count}
\SetKwData{LEN}{comment string length}
\SetKwData{COMMENT}{comment string}
\ASSERT $(\text{\READ 8 unsigned bits}) = 3$\tcc*[r]{packet type}
\ASSERT $(\text{\READ 6 bytes}) = \texttt{"vorbis"}$\;
\BlankLine
$\VENLENGTH \leftarrow$ \READ 32 unsigned bits\;
$\VENSTRING \leftarrow$ \READ (\VENLENGTH) bytes as UTF-8 string\;
$\COMCOUNT \leftarrow$ \READ 32 unsigned bits\;
\For{$i \leftarrow 0$ \emph{\KwTo}\COMCOUNT}{
  $\text{\LEN}_i \leftarrow$ \READ 32 unsigned bits\;
  $\text{\COMMENT}_i \leftarrow$ \READ ($\text{\LEN}_i$) bytes as UTF-8 string\;
}
\ASSERT $\text{(\READ 1 unsigned bit)} = 1$\tcc*[r]{framing bit}
\BlankLine
\Return $\left\lbrace\begin{tabular}{l}
\VENSTRING \\
\COMMENT \\
\end{tabular}\right.$\;
\EALGORITHM
}

\begin{figure}[h]
\includegraphics{figures/vorbis/comment.pdf}
\end{figure}
\par
\noindent
Comment strings are \texttt{"KEY=value"} pairs
where \texttt{KEY} is an ASCII value in the range \texttt{0x20}
through \texttt{0x7D}, excluding \texttt{0x3D},
is case-insensitive and may occur in multiple comment strings.
\texttt{value} is a UTF-8 value.
\begin{table}[h]
{\relsize{-1}
  \begin{tabular}{rlrl}
    \texttt{ALBUM} & album name &
    \texttt{ARTIST} & artist name \\
    \texttt{CATALOG} & CD spine number &
    \texttt{COMPOSER} & the work's author \\
    \texttt{COMMENT} & a short comment &
    \texttt{CONDUCTOR} & performing ensemble's leader \\
    \texttt{COPYRIGHT} & copyright attribution &
    \texttt{DATE} & recording date \\
    \texttt{DISCNUMBER} & disc number for multi-volume work &
    \texttt{DISCTOTAL} & disc total for multi-volume work \\
    \texttt{GENRE} & a short music genre label &
    \texttt{ISRC} & ISRC number for the track \\
    \texttt{PERFORMER} & performer name, orchestra, actor, etc. &
    \texttt{PUBLISHER} & album's publisher \\
    \texttt{SOURCE MEDIUM} & CD, radio, cassette, vinyl LP, etc. &
    \texttt{TITLE} & track name \\
    \texttt{TRACKNUMBER} & track number &
    \texttt{TRACKTOTAL} & total number of tracks \\
  \end{tabular}
}
\end{table}

\clearpage

\subsection{the Setup Packet}

The third packet in the Vorbis stream is the Setup packet.

\begin{figure}[h]
\includegraphics{figures/vorbis/setup_packet.pdf}
\end{figure}

It contains six sections of data required for decoding.

\clearpage

\subsubsection{Codebooks}

The \VAR{Codebooks} section of the setup packet stores
the Huffman lookup trees.

\begin{figure}[h]
\includegraphics{figures/vorbis/codebooks.pdf}
\end{figure}
\par
\noindent
This section contains two optional sets of data,
a list of Huffman table entry lengths
and the lookup table values each entry length may resolve to.
\VAR{Total Entries} indicates the total number of entry lengths present.
These lengths may be stored in one of three ways:
unordered without sparse entries, unordered with sparse entries
and ordered.

Unordered without sparse entries is the simplest method;
each entry length is stored as a 5 bit value, plus one.
Unordered with sparse entries is almost as simple;
each 5 bit length is prefixed by a single bit indicating
whether it is present or not.

Ordered entries are more complicated.
The initial length is stored as a 5 bit value, plus one.
The number of entries with that length are stored as a series of
\VAR{Length Count} values in the bitstream, whose sizes
are determined by the number of remaining entries.
\begin{align*}
\text{Length Count}_i \text{ Size} &= \lfloor\log_2 (\text{Remaining Entries}_i)\rfloor + 1
\intertext{For example, given a \VAR{Total Entries} value of 8 and an
\VAR{Initial Length} value of 2:}
\text{Length Count}_0 \text{ Size} &= \lfloor\log_2 8\rfloor + 1 = 4 \text{ bits}
\end{align*}
which means we read a 4 bit value to determine how many
\VAR{Entry Length} values are 2 bits long.
Therefore, if $\text{Length Count}_0$ is read from the bitstream as 2,
our \VAR{Entry Length} values are:
\begin{align*}
\text{Entry Length}_0 &= 2 \\
\text{Entry Length}_1 &= 2
\end{align*}
and the next set of lengths are 3 bits long.
Since we still have remaining entries, we read another \VAR{Length Count}
value of the length:
\begin{equation*}
\text{Length Count}_1 \text{ Size} = \lfloor\log_2 6\rfloor + 1 = 3 \text{ bits}
\end{equation*}
Thus, if $\text{Length Count}_1$ is also a value of 2 from the bitstream,
our \VAR{Entry Length} values are:
\begin{align*}
\text{Entry Length}_2 &= 3 \\
\text{Entry Length}_3 &= 3
\end{align*}
and the next set of lengths are 4 bits long.
We then read one more \VAR{Length Count} value:
\begin{equation*}
\text{Length Count}_2 \text{ Size} = \lfloor\log_2 4\rfloor + 1 = 3 \text{ bits}
\end{equation*}
Finally, if $\text{Length Count}_2$ is 4 from the bitstream,
our \VAR{Entry Length} values are:
\begin{align*}
\text{Entry Length}_4 &= 4 \\
\text{Entry Length}_5 &= 4 \\
\text{Entry Length}_6 &= 4 \\
\text{Entry Length}_7 &= 4
\end{align*}
At this point, we've assigned lengths to all the values
indicated by \VAR{Total Entries}, so the process is complete.

\clearpage

\subsubsection{Transforming Entry Lengths to Huffman Tree}

Once a set of entry length values is parsed from the stream,
transforming them into a Huffman decision tree
is performed by taking our entry lengths from
$\text{Entry Length}_0$ to $\text{Entry Length}_{total - 1}$
and placing them in the tree recursively such that the 0 bit
branches are populated first.
For example, given the parsed entry length values:
\begin{align*}
\text{Entry Length}_0 &= 2 & \text{Entry Length}_1 &= 4 & \text{Entry Length}_2 &= 4 & \text{Entry Length}_3 &= 4 \\
\text{Entry Length}_4 &= 4 & \text{Entry Length}_5 &= 2 & \text{Entry Length}_6 &= 3 & \text{Entry Length}_7 &= 3
\end{align*}
\par
\noindent
We first place $\text{Entry Length}_0$ into the Huffman tree as a 2 bit value.
Since the zero bits are filled first when adding a node 2 bits deep,
it initially looks like:

\begin{figure}[h]
\includegraphics{figures/vorbis/huffman_example1.pdf}
\caption{$\text{Entry Length}_0$ placed with 2 bits}
\end{figure}
\par
\noindent
We then place $\text{Entry Length}_1$ into the Huffman tree as a 4 bit value.
Since the \texttt{0 0} branch is already populated by $\text{Entry Length}_0$,
we switch to the empty \texttt{0 1} branch as follows:
\begin{figure}[h]
\includegraphics{figures/vorbis/huffman_example2.pdf}
\caption{$\text{Entry Length}_1$ placed with 4 bits}
\end{figure}
\par
\noindent
The 4 bit $\text{Entry Length}_2$, $\text{Entry Length}_3$ and $\text{Entry Length}_4$
values are placed similarly along the \texttt{0 1} branch:
\begin{figure}[h]
\includegraphics{figures/vorbis/huffman_example3.pdf}
\caption{$\text{Entry Length}_2$, $\text{Entry Length}_3$ and $\text{Entry Length}_4$ placed with 4 bits}
\end{figure}
\par
\noindent
Finally, the remaining three entries are populated along the \texttt{1} branch:
\begin{figure}[h]
\includegraphics{figures/vorbis/huffman_example4.pdf}
\caption{$\text{Entry Length}_5$, $\text{Entry Length}_6$ and $\text{Entry Length}_7$ are placed}
\end{figure}

\subsubsection{The Lookup Table}

The lookup table is only present if \VAR{Lookup Type} is 1 or 2.
A \VAR{Lookup Type} of 0 indicates no lookup table, while anything
greater than 2 is an error.

\VAR{Minimum Value} and \VAR{Delta Value} are 32-bit floating point values
which can be parsed in the following way:
\begin{figure}[h]
\includegraphics{figures/vorbis/float32.pdf}
\end{figure}
\begin{equation*}
\text{Float} =
\begin{cases}
\text{Mantissa} \times 2 ^ {\text{Exponent} - 788} & \text{ if Sign = 0} \\
-\text{Mantissa} \times 2 ^ {\text{Exponent} - 788} & \text{ if Sign = 1}
\end{cases}
\end{equation*}
\par
\VAR{Value Bits} indicates the size of each value in bits, plus one.
\VAR{Sequence P} is a 1 bit flag.
The total number of multiplicand values depends on whether \VAR{Lookup Type}
is 1 or 2.
\begin{align*}
\intertext{if \VAR{Lookup Type} = 1:}
\text{Multiplicand Count} &= \text{max}(\text{Int}) ^ \text{Dimensions} \text{ where } \text{Int} ^ \text{Dimensions} \leq \text{Total Entries}
\intertext{if \VAR{Lookup Type} = 2:}
\text{Multiplicand Count} &= \text{Dimensions} \times \text{Total Entries}
\end{align*}
\par
The \VAR{Multiplicand} values themselves are a list of unsigned integers,
each \VAR{Value Bits} (+ 1) bits large.


\clearpage

\section{Channel Assignment}
\begin{table}[h]
{\relsize{-1}
\begin{tabular}{|c|r|r|r|r|r|r|r|r|}
\hline
channel & & & & & & & & \\
count & channel 1 & channel 2 & channel 3 & channel 4 & channel 5 & channel 6 & channel 7 & channel 8 \\
\hline
\multirow{2}{1em}{1} & front & & & & & & & \\
                     & center & & & & & & & \\
\hline
\multirow{2}{1em}{2} & front & front & & & & & & \\
                     & left  & right & & & & & & \\
\hline
\multirow{2}{1em}{3} & front & front & front & & & & & \\
                     & left  & center & right & & & & & \\
\hline
\multirow{2}{1em}{4} & front & front & back & back & & & & \\
                     & left  & right & left & right & & & & \\
\hline
\multirow{2}{1em}{5} & front & front  & front & back & back & & & \\
                     & left  & center & right & left & right & & & \\
\hline
\multirow{2}{1em}{6} & front & front  & front & back & back & & & \\
                     & left  & center & right & left & right & LFE & & \\
\hline
\multirow{2}{1em}{7} & front & front  & front & side & side  & back   & & \\
                     & left  & center & right & left & right & center & LFE& \\
\hline
\multirow{2}{1em}{8} & front & front  & front & side & side  & back   & back & \\
                     & left  & center & right & left & right & left & right & LFE \\
\hline
8+ & \multicolumn{8}{c|}{defined by application} \\
\hline
\end{tabular}
}
\end{table}
