\chapter{Shorten}
\begin{figure}[h]
\includegraphics{figures/shorten/stream.pdf}
\end{figure}
A Shorten file is almost entirely comprised of three variable-length
data types which we'll call \texttt{unsigned}, \texttt{signed} and
\texttt{long}.
\subsubsection{Reading \texttt{unsigned}}
{\relsize{-1}
  \ALGORITHM{the Shorten file stream, a bit count $c$}{an unsigned value}
  \SetKwData{MSB}{MSB}
  \SetKwData{LSB}{LSB}
  $\text{\MSB} \leftarrow$ \UNARY with stop bit 1\;
  $\text{\LSB} \leftarrow$ \READ $c$ unsigned bits\;
  \Return $\text{\MSB} \times 2 ^ c + \text{\LSB}$\;
  \EALGORITHM
}
\subsubsection{Reading \texttt{signed}}
{\relsize{-1}
  \ALGORITHM{the Shorten file stream, a bit count $c$}{a signed value}
  \SetKwData{UNSIGNED}{unsigned}
  $\text{\UNSIGNED} \leftarrow$ read \texttt{unsigned}($c + 1$)\;
  \eIf(\tcc*[f]{positive}){$\UNSIGNED \bmod 2 = 0$}{
    \Return $\lfloor\UNSIGNED \div 2\rfloor$\;
  }(\tcc*[f]{negative}){
    \Return $-\lfloor\UNSIGNED \div 2\rfloor - 1$\;
  }
  \EALGORITHM
}
\subsubsection{Reading \texttt{long}}
{\relsize{-1}
  \ALGORITHM{the Shorten file stream}{an unsigned value}
  \Return \texttt{unsigned}(\texttt{unsigned}(2))\;
  \EALGORITHM
}

\clearpage

\section{Shorten Decoding}
{\relsize{-1}
\ALGORITHM{a Shorten encoded file}{PCM samples}
\SetKwData{MAGIC}{magic number}
\SetKwData{VERSION}{version}
\SetKwData{FILETYPE}{file type}
\SetKwData{CHANNELS}{channels}
\SetKwData{BLOCKLENGTH}{block length}
\SetKwData{MAXLPC}{max LPC}
\SetKwData{MEANCOUNT}{mean count}
\SetKwData{SKIPBYTES}{bytes to skip}
\SetKwData{COMMAND}{command}
\SetKwData{SAMPLES}{samples}
$\MAGIC \leftarrow$ \READ 4 bytes\;
\ASSERT $\MAGIC = \texttt{"ajkg"}$\;
$\VERSION \leftarrow$ \READ 8 unsigned bits\;
\ASSERT $\VERSION = 2$\;
\BlankLine
\tcc{read Shorten header}
\begin{tabular}{r>{$}c<{$}l}
  \FILETYPE & \leftarrow & read \texttt{long}()\; \\
  \CHANNELS & \leftarrow & read \texttt{long}()\; \\
  \BLOCKLENGTH & \leftarrow & read \texttt{long}()\; \\
  \MAXLPC & \leftarrow & read \texttt{long}()\; \\
  \MEANCOUNT & \leftarrow & read \texttt{long}()\; \\
  \SKIPBYTES & \leftarrow & read \texttt{long}()\; \\
\end{tabular}\;
\SKIP $(\SKIPBYTES)$ bytes\;
\EALGORITHM
}

\begin{table}[h]
{\relsize{-1}
\begin{tabular}{|r|l||r|l|}
\hline
file type & format & file type & format \\
\hline
0 & lossless \textmu-Law &
7 & lossy \textmu-Law \\
1 & signed 8 bit &
8 & new \textmu-Law with zero mapping \\
2 & unsigned 8 bit &
9 & lossless a-Law \\
3 & signed 16 bit, big-endian &
10 & lossy a-Law \\
4 & unsigned 16 bit, big-endian &
11 & Microsoft .wav \\
5 & signed 16 bit, little-endian &
12 & Apple .aiff \\
6 & unsigned 16 bit, little-endian &
& \\
\hline
\end{tabular}
}
\end{table}
\par
\noindent
\VAR{channels} is the total number of channels in the stream
and \VAR{block length} is the number of PCM frames output
from the next command, which is typically constant
until the final set of commands in the stream.
\par
The \texttt{shnmean} function is defined as:
\begin{equation*}
  \texttt{shnmean}(values~,~count) =
  \left\lfloor
  \frac{\left\lfloor\frac{count}{2}\right\rfloor +
    \overset{count - 1}{\underset{i = 0}{\sum}}{values}_i }{count}
  \right\rfloor
\end{equation*}
where $values$ is a list and $count$ is the length of that list.

\clearpage

{\relsize{-1}
\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetKw{OR}{or}
  \SetKwData{CHANNELS}{channels}
  \SetKwData{BLOCKLENGTH}{block length}
  \SetKwData{COMMAND}{command}
  \SetKwData{LEFTSHIFT}{left shift}
  \SetKwData{SAMPLES}{samples}
  \SetKwData{MEANCOUNT}{mean count}
  \SetKwData{MEANS}{means}
  \SetKwData{SHIFTED}{unshifted}
  \tcc{setup initial variables}
  $i \leftarrow 0$\;
  $\LEFTSHIFT \leftarrow 0$\;
  \BlankLine
  \tcc{process commands}
  \Repeat{$\COMMAND = 4$}{
    $\COMMAND \leftarrow$ read \texttt{unsigned}(2)\;
    \eIf(\tcc*[f]{audio data commands}){$(0 \leq \COMMAND \leq 3)$ \OR $(7 \leq \COMMAND \leq 8)$}{
      $c \leftarrow i \bmod \CHANNELS$\tcc*{current channel}
      $m \leftarrow \lfloor i \div \CHANNELS\rfloor$\;
      \Switch{\COMMAND}{
        \uCase(\tcc*[f]{DIFF0}){0}{
          $\text{\SAMPLES}_c \leftarrow$ read \texttt{DIFF0} with \BLOCKLENGTH,
          and $\text{\MEANS}_{c~[m - \text{\MEANCOUNT} \IDOTS m - 1]}$\;
        }
        \uCase(\tcc*[f]{DIFF1}){1}{
          $\text{\SAMPLES}_c \leftarrow$ read \texttt{DIFF1} with \BLOCKLENGTH and
          previous $\text{\SAMPLES}_c$\;
        }
        \uCase(\tcc*[f]{DIFF2}){2}{
          $\text{\SAMPLES}_c \leftarrow$ read \texttt{DIFF2} with \BLOCKLENGTH and
          previous $\text{\SAMPLES}_c$\;
        }
        \uCase(\tcc*[f]{DIFF3}){3}{
          $\text{\SAMPLES}_c \leftarrow$ read \texttt{DIFF3} with \BLOCKLENGTH and
          previous $\text{\SAMPLES}_c$\;
        }
        \uCase(\tcc*[f]{QLPC}){7}{
          $\text{\SAMPLES}_c \leftarrow$ read \texttt{QLPC} with \BLOCKLENGTH,
          $\text{\MEANS}_{c~[m - \text{\MEANCOUNT} \IDOTS m - 1]}$\newline and previous $\text{\SAMPLES}_c$\;
        }
        \Case(\tcc*[f]{ZERO}){8}{
          \For{j = 0 \emph{\KwTo}\BLOCKLENGTH}{
            $\text{\SAMPLES}_{c~j} \leftarrow 0$\;
          }
        }
      }
      $\text{\MEANS}_{c~m} \leftarrow \texttt{shnmean}(\text{\SAMPLES}_c~,~\BLOCKLENGTH)$\;
      wrap $\text{\SAMPLES}_c$ for next set of channels\;
      $\text{\SHIFTED}_c \leftarrow$ apply \LEFTSHIFT to $\text{\SAMPLES}_c$\;
      $i \leftarrow i + 1$\;
      \If{$i \bmod \CHANNELS = 0$}{
        \Return \SHIFTED as a complete set of PCM frames\;
      }
    }(\tcc*[f]{non audio commands}){
      \Switch{\COMMAND}{
        \uCase(\tcc*[f]{QUIT}){4}{
          \tcc{do nothing}
        }
        \uCase(\tcc*[f]{BLOCKSIZE}){5}{
          $\BLOCKLENGTH \leftarrow$ read \texttt{long}()\;
        }
        \uCase(\tcc*[f]{BITSHIFT}){6}{
          $\LEFTSHIFT \leftarrow$ read \texttt{unsigned}(2)\;
        }
        \uCase(\tcc*[f]{VERBATIM}){9}{
          handle verbatim block of non-audio data\;
        }
        \Other{unknown command}
      }
    }
  }(\tcc*[f]{QUIT command})
\end{algorithm}
}

\clearpage

\subsection{Header Decoding Example}

\begin{figure}[h]
\includegraphics{figures/shorten/header_parse.pdf}
\end{figure}
In this example, \VAR{magic number} is \texttt{"ajkg"} and
\VAR{version} is 2.
Since \VAR{file type} is a \texttt{long}\footnote{which is defined as
\texttt{unsigned}(\texttt{unsigned}(2))}
it breaks down as follows:
\par
\noindent
\begin{wrapfigure}[3]{r}{140pt}
\includegraphics{figures/shorten/filetype.pdf}
\end{wrapfigure}
{\relsize{-1}
\begin{align*}
\text{MSB}_0 &\leftarrow 0
\text{ (number of \texttt{0} bits until next \texttt{1})} \\
\text{LSB}_0 &\leftarrow 3
\text{ (read 2 unsigned bits)} \\
\texttt{unsigned}(2) &\leftarrow 0 \times 2 ^ 2 + 3 = 3 \\
\text{MSB}_1 &\leftarrow 0
\text{ (number of \texttt{0} bits until next \texttt{1})} \\
\text{LSB}_1 &\leftarrow 5
\text{ (read 3 unsigned bits)} \\
\text{file type} &\leftarrow 0 \times 2 ^ 3 + 5 = 5 \\
\end{align*}
}
\par
\noindent
meaning our file consists of signed, 16-bit, little-endian data.
The remainding fields are determined as follows:
\begin{table}[h]
  \begin{tabular}{r>{$}c<{$}rr>{$}r<{$}rr>{$}r<{$}}
    & & $\text{MSB}_0$ & $\text{LSB}_0$ & $\texttt{unsigned}(2)$ &
    $\text{MSB}_1$ & $\text{LSB}_1$ & \texttt{long} \text{ value} \\
    \hline
    channels & \leftarrow & {\color{red} 0} & {\color{orange} 2} &
    {\color{red} 0} \times 2 ^ 2 + {\color{orange} 2} = {\color{fuchsia} 2} &
    {\color{blue} 0} & {\color{green} 2} &
    {\color{blue} 0} \times 2 ^ {\color{fuchsia} 2} + {\color{green} 2} =
    \textbf{2} \\
    block length & \leftarrow & {\color{red} 2} & {\color{orange} 1} &
    {\color{red} 2} \times 2 ^ 2 + {\color{orange} 1} = {\color{fuchsia} 9} &
    {\color{blue} 0} & {\color{green} 256} &
    {\color{blue} 0} \times 2 ^ {\color{fuchsia} 9} + {\color{green} 256} =
    \textbf{256} \\
    max LPC & \leftarrow & {\color{red} 0} & {\color{orange} 0} &
    {\color{red} 0} \times 2 ^ 2 + {\color{orange} 0} = {\color{fuchsia} 0} &
    {\color{blue} 0} & {\color{green} 0} &
    {\color{blue} 0} \times 2 ^ {\color{fuchsia} 0} + {\color{green} 0} =
    \textbf{0} \\
    bytes to skip & \leftarrow & {\color{red} 0} & {\color{orange} 0} &
    {\color{red} 0} \times 2 ^ 2 + {\color{orange} 0} = {\color{fuchsia} 0} &
    {\color{blue} 0} & {\color{green} 0} &
    {\color{blue} 0} \times 2 ^ {\color{fuchsia} 0} + {\color{green} 0} =
    \textbf{0} \\
\end{tabular}
\end{table}

\clearpage

\subsection{Handling Verbatim Data}

These are non-audio blocks designed to hold Wave/AIFF headers or footers.
They are expected to be in the Shorten file in the same order
they would be output to disk.
\par
\noindent
\ALGORITHM{Shorten stream}{1 or more bytes of non-audio file data}
$size \leftarrow$ read \texttt{unsigned}(5)\;
\For{i = 0 \emph{\KwTo}size}{
  $\text{bytes}_i \leftarrow$ read \texttt{unsigned}(8)\;
}
\Return bytes\;
\EALGORITHM
\begin{figure}[h]
\includegraphics{figures/shorten/verbatim.pdf}
\end{figure}

\clearpage

\subsection{Reading \texttt{DIFF0}}
{\relsize{-1}
\ALGORITHM{block length, previous \VAR{mean count} means for channel $c$}{decoded samples}
\SetKwData{BLOCKLENGTH}{block length}
\SetKwData{OFFSET}{offset}
\SetKwData{MEANS}{previous means}
\SetKwData{ENERGY}{energy}
\SetKwData{RESIDUAL}{residual}
\SetKwData{SAMPLES}{samples}
$\text{\OFFSET} \leftarrow \texttt{shnmean}(\text{\MEANS}_c~,~\text{mean count})$\;
$\ENERGY \leftarrow$ read \texttt{unsigned}(3)\;
\BlankLine
\For{i = 0 \emph{\KwTo}\BLOCKLENGTH}{
  $\text{\RESIDUAL}_i \leftarrow$ read \texttt{signed}(\ENERGY)\;
  $\text{\SAMPLES}_{c~i} \leftarrow \text{\RESIDUAL}_i + \OFFSET$\;
}
\Return $\text{\SAMPLES}_c$\;
\EALGORITHM
}

\subsection{Reading \texttt{DIFF1}}
{\relsize{-1}
\ALGORITHM{block length, previously decoded samples}{decoded samples}
\SetKwData{BLOCKLENGTH}{block length}
\SetKwData{ENERGY}{energy}
\SetKwData{RESIDUAL}{residual}
\SetKwData{SAMPLES}{samples}
$\ENERGY \leftarrow$ read \texttt{unsigned}(3)\;
\BlankLine
\For{i = 0 \emph{\KwTo}\BLOCKLENGTH}{
  $\text{\RESIDUAL}_i \leftarrow$ read \texttt{signed}(\ENERGY)\;
  $\text{\SAMPLES}_{c~i} \leftarrow \text{\SAMPLES}_{c~(i - 1)} + \text{\RESIDUAL}_i$\;
}
\Return $\text{\SAMPLES}_c$\;
\EALGORITHM
\par
\noindent
$\text{samples}_{c~(-1)}$ is from the previously
decoded samples on channel $c$,
or 0 if there are none
}

\subsection{Reading \texttt{DIFF2}}
{\relsize{-1}
  \ALGORITHM{block length, previously decoded samples}{decoded samples}
  \SetKwData{BLOCKLENGTH}{block length}
  \SetKwData{ENERGY}{energy}
  \SetKwData{RESIDUAL}{residual}
  \SetKwData{SAMPLES}{samples}
  $\ENERGY \leftarrow$ read \texttt{unsigned}(3)\;
  \BlankLine
  \For{i = 0 \emph{\KwTo}\BLOCKLENGTH}{
    $\text{\RESIDUAL}_i \leftarrow$ read \texttt{signed}(\ENERGY)\;
    $\text{\SAMPLES}_{c~i} \leftarrow (2 \times \text{\SAMPLES}_{c~(i - 1)}) - \text{\SAMPLES}_{c~(i - 2)} + \text{\RESIDUAL}_i$\;
  }
  \Return $\text{\SAMPLES}_c$\;
  \EALGORITHM
  \par
  \noindent
  $\text{samples}_{c~(-1)}$ and $\text{samples}_{c~(-2)}$ are from
  the previously decoded samples on channel $c$,
  or 0 if there are none
}

\subsection{Reading \texttt{DIFF3}}
{\relsize{-1}
  \ALGORITHM{block length, previously decoded samples}{decoded samples}
  \SetKwData{BLOCKLENGTH}{block length}
  \SetKwData{ENERGY}{energy}
  \SetKwData{RESIDUAL}{residual}
  \SetKwData{SAMPLES}{samples}
  $\ENERGY \leftarrow$ read \texttt{unsigned}(3)\;
  \BlankLine
  \For{i = 0 \emph{\KwTo}\BLOCKLENGTH}{
    $\text{\RESIDUAL}_i \leftarrow$ read \texttt{signed}(\ENERGY)\;
    $\text{\SAMPLES}_{c~i} \leftarrow (3 \times (\text{\SAMPLES}_{c~(i - 1)} - \text{\SAMPLES}_{c~(i - 2)})) + \text{\SAMPLES}_{c~(i - 3)} + \text{\RESIDUAL}_i$\;
  }
  \Return $\text{\SAMPLES}_c$\;
  \EALGORITHM
  \par
  \noindent
  $\text{samples}_{c~(-1)}$, $\text{samples}_{c~(-2)}$ and
  $\text{samples}_{c~(-3)}$ are from
  the previously decoded samples on channel $c$,
  or 0 if there are none
}

\clearpage

\subsection{\texttt{DIFF3} Parsing Example}
Given a \texttt{DIFF3} command issued with a current \VAR{block length} of 15
and the bytes:
\begin{figure}[h]
\includegraphics{figures/shorten/block1.pdf}
\end{figure}
\begin{equation*}
\text{energy} \leftarrow 0 \times 2 ^ 3 + 1 = 1
\end{equation*}
\begin{table}[h]
  {\relsize{-1}
    \renewcommand{\arraystretch}{1.25}
    \begin{tabular}{rrr>{$}r<{$}>{$}r<{$}>{$}r<{$}}
    $i$ & $\text{MSB}_i$ & $\text{LSB}_i$ &
    \text{unsigned}_i & \text{residual}_i & \text{sample}_i \\
    \hline
    -3 & & & & & 0 \\
    -2 & & & & & 0 \\
    -1 & & & & & 0 \\
    \hline
    0 &
    0 & 0 & 0 \times 2 ^ {2} + 0 = 0 &
    \lfloor 0 \div 2 \rfloor = 0 &
    (3 \times (0 - 0)) + 0 + 0 = 0 \\
    1 &
    8 & 0 & 8 \times 2 ^ {2} + 0 = 32 &
    \lfloor 32 \div 2 \rfloor = 16 &
    (3 \times (0 - 0)) + 0 + 16 = 16 \\
    2 &
    8 & 1 & 8 \times 2 ^ {2} + 1 = 33 &
    -\lfloor 33 \div 2 \rfloor - 1 = -17 &
    (3 \times (16 - 0)) + 0 - 17 = 31 \\
    3 &
    0 & 1 & 0 \times 2 ^ {2} + 1 = 1 &
    -\lfloor 1 \div 2 \rfloor - 1 = -1 &
    (3 \times (31 - 16)) + 0 - 1 = 44 \\
    4 &
    0 & 1 & 0 \times 2 ^ {2} + 1 = 1 &
    -\lfloor 1 \div 2 \rfloor - 1 = -1 &
    (3 \times (44 - 31)) + 16 - 1 = 54 \\
    5 &
    0 & 0 & 0 \times 2 ^ {2} + 0 = 0 &
    \lfloor 0 \div 2 \rfloor = 0 &
    (3 \times (54 - 44)) + 31 + 0 = 61 \\
    6 &
    0 & 1 & 0 \times 2 ^ {2} + 1 = 1 &
    -\lfloor 1 \div 2 \rfloor - 1 = -1 &
    (3 \times (61 - 54)) + 44 - 1 = 64 \\
    7 &
    0 & 0 & 0 \times 2 ^ {2} + 0 = 0 &
    \lfloor 0 \div 2 \rfloor = 0 &
    (3 \times (64 - 61)) + 54 + 0 = 63 \\
    8 &
    0 & 0 & 0 \times 2 ^ {2} + 0 = 0 &
    \lfloor 0 \div 2 \rfloor = 0 &
    (3 \times (63 - 64)) + 61 + 0 = 58 \\
    9 &
    0 & 0 & 0 \times 2 ^ {2} + 0 = 0 &
    \lfloor 0 \div 2 \rfloor = 0 &
    (3 \times (58 - 63)) + 64 + 0 = 49 \\
    10 &
    1 & 0 & 1 \times 2 ^ {2} + 0 = 4 &
    \lfloor 4 \div 2 \rfloor = 2 &
    (3 \times (49 - 58)) + 63 + 2 = 38 \\
    11 &
    0 & 1 & 0 \times 2 ^ {2} + 1 = 1 &
    -\lfloor 1 \div 2 \rfloor - 1 = -1 &
    (3 \times (38 - 49)) + 58 - 1 = 24 \\
    12 &
    0 & 2 & 0 \times 2 ^ {2} + 2 = 2 &
    \lfloor 2 \div 2 \rfloor = 1 &
    (3 \times (24 - 38)) + 49 + 1 = 8 \\
    13 &
    1 & 0 & 1 \times 2 ^ {2} + 0 = 4 &
    \lfloor 4 \div 2 \rfloor = 2 &
    (3 \times (8 - 24)) + 38 + 2 = -8 \\
    14 &
    0 & 0 & 0 \times 2 ^ {2} + 0 = 0 &
    \lfloor 0 \div 2 \rfloor = 0 &
    (3 \times (-8 - 8)) + 24 + 0 = -24 \\
    \hline
  \end{tabular}
    \renewcommand{\arraystretch}{1.0}
  }
\end{table}
\par
\noindent
Note that the negative $i$ samples are only used
for calculation and not re-output by the \texttt{DIFF} command.

\clearpage

\subsection{\texttt{DIFF3} Parsing Example 2}
Given a \texttt{DIFF3} command issued from the same channel as
the previous example with a current \VAR{block length} of 10
and the bytes:

\begin{figure}[h]
\includegraphics{figures/shorten/block2.pdf}
\end{figure}
\begin{equation*}
  \text{energy} \leftarrow 0 \times 2 ^ 3 + 0 = 0
\end{equation*}
\begin{table}[h]
  {\relsize{-1}
    \renewcommand{\arraystretch}{1.25}
    \begin{tabular}{rrr>{$}r<{$}>{$}r<{$}>{$}r<{$}}
      $i$ & $\text{MSB}_i$ & $\text{LSB}_i$ &
      \text{unsigned}_i & \text{residual}_i & \text{sample}_i \\
      \hline
      -3 & & & & & 8 \\
      -2 & & & & & -8 \\
      -1 & & & & & -24 \\
      \hline
      0 &
      2 & 0 & 2 \times 2 ^ {1} + 0 = 4 &
      \lfloor 4 \div 2 \rfloor = 2 &
      (3 \times (-24 + 8)) + 8 + 2 = -38 \\
      1 &
      1 & 0 & 1 \times 2 ^ {1} + 0 = 2 &
      \lfloor 2 \div 2 \rfloor = 1 &
      (3 \times (-38 + 24)) - 8 + 1 = -49 \\
      2 &
      0 & 1 & 0 \times 2 ^ {1} + 1 = 1 &
      -\lfloor 1 \div 2 \rfloor - 1 = -1 &
      (3 \times (-49 + 38)) - 24 - 1 = -58 \\
      3 &
      2 & 0 & 2 \times 2 ^ {1} + 0 = 4 &
      \lfloor 4 \div 2 \rfloor = 2 &
      (3 \times (-58 + 49)) - 38 + 2 = -63 \\
      4 &
      0 & 0 & 0 \times 2 ^ {1} + 0 = 0 &
      \lfloor 0 \div 2 \rfloor = 0 &
      (3 \times (-63 + 58)) - 49 + 0 = -64 \\
      5 &
      0 & 0 & 0 \times 2 ^ {1} + 0 = 0 &
      \lfloor 0 \div 2 \rfloor = 0 &
      (3 \times (-64 + 63)) - 58 + 0 = -61 \\
      6 &
      0 & 0 & 0 \times 2 ^ {1} + 0 = 0 &
      \lfloor 0 \div 2 \rfloor = 0 &
      (3 \times (-61 + 64)) - 63 + 0 = -54 \\
      7 &
      0 & 1 & 0 \times 2 ^ {1} + 1 = 1 &
      -\lfloor 1 \div 2 \rfloor - 1 = -1 &
      (3 \times (-54 + 61)) - 64 - 1 = -44 \\
      8 &
      0 & 0 & 0 \times 2 ^ {1} + 0 = 0 &
      \lfloor 0 \div 2 \rfloor = 0 &
      (3 \times (-44 + 54)) - 61 + 0 = -31 \\
      9 &
      0 & 1 & 0 \times 2 ^ {1} + 1 = 1 &
      -\lfloor 1 \div 2 \rfloor - 1 = -1 &
      (3 \times (-31 + 44)) - 54 - 1 = -16 \\
    \end{tabular}
    \renewcommand{\arraystretch}{1.0}
  }
\end{table}
\par
\noindent
Note that because this \texttt{DIFF} is issued on the same channel
as the previous \texttt{DIFF}:
\begin{table}[h]
\begin{tabular}{rcl}
  $\text{current sample}_{(-3)}$ & = & $\text{previous sample}_{12}$ \\
  $\text{current sample}_{(-2)}$ & = & $\text{previous sample}_{13}$ \\
  $\text{current sample}_{(-1)}$ & = & $\text{previous sample}_{14}$ \\
\end{tabular}
\end{table}
\par
\noindent
the samples have been ``wrapped around'' from one channel to the next.
But again, those negative samples are not re-output by
this \texttt{DIFF} command.

\clearpage

\subsection{Reading \texttt{QLPC}}
{\relsize{-1}
\ALGORITHM{block length, previous \VAR{mean count} means for channel $c$, previously decoded samples}{decoded samples}
\SetKwData{BLOCKLENGTH}{block length}
\SetKwData{OFFSET}{offset}
\SetKwData{MEANS}{previous means}
\SetKwData{ENERGY}{energy}
\SetKwData{LPCCOUNT}{LPC count}
\SetKwData{COEFF}{LPC coefficient}
\SetKwData{RESIDUAL}{residual}
\SetKwData{UNOFFSET}{unoffset}
\SetKwData{SAMPLES}{samples}
$\text{\OFFSET} \leftarrow \texttt{shnmean}(\text{\MEANS}_c~,~\text{mean count})$\;
$\ENERGY \leftarrow$ read \texttt{unsigned}(3)\;
$\LPCCOUNT \leftarrow$ read \texttt{unsigned}(2)\;
\For{i = 0 \emph{\KwTo}\LPCCOUNT}{
  $\text{\COEFF}_i \leftarrow$ read \texttt{signed}(5)\;
}
\For{i = 0 \emph{\KwTo}\BLOCKLENGTH}{
  $\text{\RESIDUAL}_i \leftarrow$ read \texttt{signed}(\ENERGY)\;
  $\text{sum} \leftarrow 2 ^ 5$\;
  \For{j = 0 \emph{\KwTo}\LPCCOUNT}{
    \eIf(\tcc*[f]{remove offset from warm-up samples}){$i - j - 1 < 0$}{
      $\text{sum} \leftarrow \text{sum} + \text{\COEFF}_j \times (\text{\SAMPLES}_{c~(i - j - 1)} - \OFFSET)$\;
    }{
      $\text{sum} \leftarrow \text{sum} + \text{\COEFF}_j \times \text{\UNOFFSET}_{(i - j - 1)}$\;
    }
  }
  $\text{\UNOFFSET}_{i} \leftarrow \left\lfloor\frac{\text{sum}}{2 ^ 5}\right\rfloor + \text{\RESIDUAL}_i$\;
}
\For(\tcc*[f]{add offset to output samples}){i = 0 \emph{\KwTo}\BLOCKLENGTH}{
  $\text{\SAMPLES}_{c~i} \leftarrow \text{\UNOFFSET}_i + \OFFSET$
}
\Return $\text{\SAMPLES}_c$\;
\EALGORITHM
}
\begin{figure}[h]
\includegraphics{figures/shorten/qlpc.pdf}
\end{figure}
\par
\noindent
As with the \texttt{DIFF} commands, negative samples are from the
previously decoded samples on channel $c$, or 0 if there are none.

In practice, encoded Shorten files typically contain no
\texttt{QLPC} commands at all.
Because the reference implementation uses a 32-bit
accumulator for the LPC sum,
calculation will overflow when using a nontrivial number of
coefficients.
Instead, files usually contain only \texttt{DIFF1}, \texttt{DIFF2},
\texttt{DIFF3}, and \texttt{ZERO} audio commands.

\clearpage

\subsection{Reading \texttt{QLPC} Example}
\begin{figure}[h]
\includegraphics{figures/shorten/qlpc1.pdf}
\end{figure}

In this example:
\begin{table}[h]
  \begin{tabular}{r>{$}c<{$}>{$}l<{$}}
    offset & \leftarrow & 0 \\
    $\text{LPC count}$ & \leftarrow & 1 \\
    $\text{LPC coefficient}_0$ & \leftarrow & 29 \\
  \end{tabular}
\end{table}
\begin{table}[h]
{\relsize{-1}
  \renewcommand{\arraystretch}{1.25}
  \begin{tabular}{rr>{$}r<{$}>{$}r<{$}||>{$}r<{$}}
    $i$ & $\text{residual}_i$ & \text{sum}_i & \text{unoffset}_i &
    \text{sample}_{c~i} \\
    \hline
    0 & -1 &
    2 ^ 5 + 29 \times (0 - 0) = 32 &
    \left\lfloor\frac{32}{2 ^ 5}\right\rfloor - 1 = 0 &
    0 + 0 = 0 \\
    1 & 15 &
    2 ^ 5 + 29 \times 0 = 32 &
    \left\lfloor\frac{32}{2 ^ 5}\right\rfloor + 15 = 16 &
    16 + 0 = 16 \\
    2 & 16 &
    2 ^ 5 + 29 \times 16 = 496 &
    \left\lfloor\frac{496}{2 ^ 5}\right\rfloor + 16 = 31 &
    31 + 0 = 31 \\
    3 & 15 &
    2 ^ 5 + 29 \times 31 = 931 &
    \left\lfloor\frac{931}{2 ^ 5}\right\rfloor + 15 = 44 &
    44 + 0 = 44 \\
    4 & 14 &
    2 ^ 5 + 29 \times 44 = 1308 &
    \left\lfloor\frac{1308}{2 ^ 5}\right\rfloor + 14 = 54 &
    54 + 0 = 54 \\
    5 & 12 &
    2 ^ 5 + 29 \times 54 = 1598 &
    \left\lfloor\frac{1598}{2 ^ 5}\right\rfloor + 12 = 61 &
    61 + 0 = 61 \\
    6 & 8 &
    2 ^ 5 + 29 \times 61 = 1801 &
    \left\lfloor\frac{1801}{2 ^ 5}\right\rfloor + 8 = 64 &
    64 + 0 = 64 \\
    7 & 4 &
    2 ^ 5 + 29 \times 64 = 1888 &
    \left\lfloor\frac{1888}{2 ^ 5}\right\rfloor + 4 = 63 &
    63 + 0 = 63 \\
    8 & 0 &
    2 ^ 5 + 29 \times 63 = 1859 &
    \left\lfloor\frac{1859}{2 ^ 5}\right\rfloor + 0 = 58 &
    58 + 0 = 58 \\
    9 & -4 &
    2 ^ 5 + 29 \times 58 = 1714 &
    \left\lfloor\frac{1714}{2 ^ 5}\right\rfloor - 4 = 49 &
    49 + 0 = 49 \\
    %% 10 & -7 &
    %% 2 ^ 5 + 29 \times 49 = 1453 &
    %% \left\lfloor\frac{1453}{2 ^ 5}\right\rfloor - 7 = 38 &
    %% 38 + 0 = 38 \\
    %% 11 & -11 &
    %% 2 ^ 5 + 29 \times 38 = 1134 &
    %% \left\lfloor\frac{1134}{2 ^ 5}\right\rfloor - 11 = 24 &
    %% 24 + 0 = 24 \\
    %% 12 & -14 &
    %% 2 ^ 5 + 29 \times 24 = 728 &
    %% \left\lfloor\frac{728}{2 ^ 5}\right\rfloor - 14 = 8 &
    %% 8 + 0 = 8 \\
    %% 13 & -16 &
    %% 2 ^ 5 + 29 \times 8 = 264 &
    %% \left\lfloor\frac{264}{2 ^ 5}\right\rfloor - 16 = -8 &
    %% -8 + 0 = -8 \\
    %% 14 & -17 &
    %% 2 ^ 5 + 29 \times -8 = -200 &
    %% \left\lfloor\frac{-200}{2 ^ 5}\right\rfloor - 17 = -24 &
    %% -24 + 0 = -24 \\
    %% 15 & -17 &
    %% 2 ^ 5 + 29 \times -24 = -664 &
    %% \left\lfloor\frac{-664}{2 ^ 5}\right\rfloor - 17 = -38 &
    %% -38 + 0 = -38 \\
    %% 16 & -15 &
    %% 2 ^ 5 + 29 \times -38 = -1070 &
    %% \left\lfloor\frac{-1070}{2 ^ 5}\right\rfloor - 15 = -49 &
    %% -49 + 0 = -49 \\
    %% 17 & -14 &
    %% 2 ^ 5 + 29 \times -49 = -1389 &
    %% \left\lfloor\frac{-1389}{2 ^ 5}\right\rfloor - 14 = -58 &
    %% -58 + 0 = -58 \\
    %% 18 & -11 &
    %% 2 ^ 5 + 29 \times -58 = -1650 &
    %% \left\lfloor\frac{-1650}{2 ^ 5}\right\rfloor - 11 = -63 &
    %% -63 + 0 = -63 \\
    %% 19 & -7 &
    %% 2 ^ 5 + 29 \times -63 = -1795 &
    %% \left\lfloor\frac{-1795}{2 ^ 5}\right\rfloor - 7 = -64 &
    %% -64 + 0 = -64 \\
  \end{tabular}
  \renewcommand{\arraystretch}{1.0}
}
\end{table}

\clearpage

\subsection{Applying Left Shift to Samples}
\ALGORITHM{a list of samples for a given channel $c$, a left shift value}{a list of unshifted samples}
\SetKwData{LEFTSHIFT}{left shift}
\SetKwData{SAMPLES}{samples}
\SetKwData{BLOCKLENGTH}{block length}
\SetKwData{UNSHIFTED}{unshifted}
\eIf{$\LEFTSHIFT = 0$}{
  \Return $\text{\SAMPLES}_c$\tcc*{no change}
}{
  \For{i = 0 \emph{\KwTo}\BLOCKLENGTH}{
    $\text{\UNSHIFTED}_{c~i} \leftarrow \text{\SAMPLES}_{c~i} \times 2 ^ {\LEFTSHIFT}$\;
  }
  \Return $\text{\UNSHIFTED}_{c}$\;
}
\EALGORITHM

\section{Shorten Encoding}
As with decoding, one needs \texttt{unsigned}, \texttt{signed} and \texttt{long}
functions:

\subsubsection{Writing \texttt{unsigned}}
{\relsize{-1}
  \ALGORITHM{a bit count $c$, an unsigned value}{a written \texttt{unsigned} value}
  \SetKwData{VALUE}{value}
  \SetKwData{MSB}{MSB}
  \SetKwData{LSB}{LSB}
  $\text{\MSB} \leftarrow \lfloor\text{\VALUE} \div 2 ^ c\rfloor$\;
  $\text{\LSB} \leftarrow \text{\VALUE} - \text{\MSB} \times 2 ^ c$\;
  \WUNARY \MSB with stop bit 1\;
  \WRITE \LSB in $c$ unsigned bits\;
  \EALGORITHM
}

\subsubsection{Writing \texttt{signed}}
{\relsize{-1}
  \ALGORITHM{a bit count $c$, a signed value}{a written \texttt{signed} value}
  \SetKwData{VALUE}{value}
  \eIf{$\text{\VALUE} \geq 0$}{
    write $\texttt{unsigned}(c + 1~,~\text{\VALUE} \times 2)$\;
  }{
    write $\texttt{unsigned}(c + 1~,~(-\text{\VALUE} - 1) \times 2 + 1)$\;
  }

  \EALGORITHM
}


\subsubsection{Writing \texttt{long}}
{\relsize{-1}
  \ALGORITHM{an unsigned value}{a written \texttt{long} value}
  \SetKwData{VALUE}{value}
  \eIf{$\text{\VALUE} = 0$}{
    write $\texttt{unsigned}(2~,~0)$\;
    write $\texttt{unsigned}(0~,~0)$\;
  }{
    $\text{LSBs} \leftarrow \lfloor\log_2(\text{\VALUE})\rfloor + 1$\;
    write $\texttt{unsigned}(2~,~\text{LSBs})$\;
    write $\texttt{unsigned}(\text{LSBs}~,~\text{\VALUE})$\;
  }
  \EALGORITHM
}

\clearpage

{\relsize{-1}
  \ALGORITHM{PCM frames, a block size parameter, a wave or aiff header and footer}{an encoded Shorten file}
  \SetKwData{BITSPERSAMPLE}{bits per sample}
  \SetKwData{CHANNELS}{channel count}
  \SetKwData{BLOCKSIZE}{block size}
  \WRITE \texttt{"ajkg"} in 4 bytes\;
  \WRITE 2 in 8 unsigned bits\;
  \uIf{$\BITSPERSAMPLE = 8$}{
    write \texttt{long}(2)\tcc*[r]{unsigned 8 bit}
  }
  \uElseIf{$\BITSPERSAMPLE = 16$}{
    write \texttt{long}(5)\tcc*[r]{signed 16 bit}
  }
  \Else{
    unsupported number of bits per sample\;
  }
  write \texttt{long}(\CHANNELS)\;
  write \texttt{long}(\BLOCKSIZE)\;
  write \texttt{long}(0)\tcc*[r]{maximum LPC}
  write \texttt{long}(0)\tcc*[r]{mean count}
  write \texttt{long}(0)\tcc*[r]{bytes to skip}
  \BlankLine
  write \texttt{unsigned}(2~,~9)\tcc*[r]{VERBATIM command}
  write \texttt{unsigned}(5~,~header byte count)\;
  \ForEach{byte \IN header}{
    write \texttt{unsigned}(8~,~\textit{byte})\;
  }
  encode PCM data to 1 or more audio commands\;
  \BlankLine
  \If{$\text{footer byte count} > 0$}{
    write \texttt{unsigned}(2~,~9)\tcc*[r]{VERBATIM command}
    write \texttt{unsigned}(5~,~footer byte count)\;
    \ForEach{byte \IN footer}{
      write \texttt{unsigned}(8~,~\textit{byte})\;
    }
  }
  \BlankLine
  write \texttt{unsigned}(2~,~5)\tcc*[r]{QUIT command}
  \BlankLine
  \tcc{Shorten output (not including 5 bytes of magic + version)
  must be a multiple of 4 bytes, or the reference decoder's
  bit stream reader will fail}
  byte align the stream\;
  \While{$(\text{total file size} - 5) \bmod 4 = 0$}{
    \WRITE 0 in 8 unsigned bits\;
  }
\EALGORITHM
}

\clearpage

\subsection{Encoding Audio Data to Commands}
{\relsize{-1}
  \begin{algorithm}[H]
    \SetKwData{SAMPLES}{samples}
    \SetKwData{BLOCKSIZE}{block size}
    \DontPrintSemicolon
    \While{PCM frames remain}{
      $\text{\SAMPLES} \leftarrow$ take \BLOCKSIZE PCM frames from input stream\;
      \If{$\text{\SAMPLES PCM frame count} \neq \BLOCKSIZE$}{
        $\text{\BLOCKSIZE} \leftarrow \textit{\SAMPLES PCM frame count}$\;
        write \texttt{unsigned}(2~,~5)\tcc*[r]{BLOCKSIZE command}
        write \texttt{long}(\BLOCKSIZE)\;
      }
    }
  \end{algorithm}
}
