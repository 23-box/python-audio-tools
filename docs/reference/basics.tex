\chapter{the Basics}
\section{Hexadecimal}
\paragraph
In order to understand hexadecimal, it's important to re-familiarize
oneself with decimal, which everyone reading this should be familiar with.
In ordinary decimal numbers, there are a total of ten characters per digit:
0, 1, 2, 3, 4, 5, 6, 7, 8 and 9.
Because there are ten, we'll call it base-10.
So the number 675 is made up of the digits 6, 7 and 5
and can be calculated in the following way:
\begin{equation}
( 6 \times 10 ^ 2 ) + ( 7 \times 10 ^ 1 ) + ( 5 \times 10 ^ 0 ) = 675
\end{equation}
In hexadecimal, there are sixteen characters per digit:
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E and F.
A, B, C, D, E and F correspond to the decimal numbers
10, 11, 12, 13, 14 and 15, respectively.
Because there are sixteen, we'll call it base-16.
So the number 2A3 is made up of the digits 2, A and 3
and can be calculated in the following way:
\begin{equation}
(2 \times 16 ^ 2 ) + (10 \times 16 ^ 1 ) + (3 \times 16 ^ 0 ) = 675
\end{equation}

Why use hexadecimal?
The reason brings us back to binary file formats, which are
made up of bytes.
Each byte is made up of 8 bits and can have a value from 0 to 255,
in decimal.
Representing a binary file in hexadecimal means a byte requires
exactly two digits with values from 0 to FF.
That saves us a lot of space versus trying to represent bytes
in decimal.

Hexadecimal has another important property when dealing with
binary data.
Because each digit has 16 possible values, each hexadecimal
digit represents exactly 4 bits ($16 = 2 ^ 4$).
This makes it very easy to go back and forth between hexadecimal
and binary.  For instance, let's take the byte 6A:

\parpic{\includegraphics{binary.pdf}}

\begin{tabular}{| c | c | c || c | c | c |}
\hline
Hex & Binary & Decimal & Hex & Binary & Decimal \\
\hline
0 & 0 0 0 0  & 0 & 8 &  1 0 0 0  & 8 \\
1 & 0 0 0 1 & 1 & 9 & 1 0 0 1 & 9 \\
2 & 0 0 1 0 & 2 & A & 1 0 1 0 & 10 \\
3 & 0 0 1 1 & 3 & B & 1 0 1 1 & 11 \\
4 & 0 1 0 0 & 4 & C & 1 1 0 0 & 12 \\
5 & 0 1 0 1 & 5 & D & 1 1 0 1 & 13 \\
6 & 0 1 1 0 & 6 & E & 1 1 1 0 & 14 \\
7 & 0 1 1 1 & 7 & F & 1 1 1 1 & 15 \\
\hline
\end{tabular}
\begin{flushleft}
Going from binary to hexadecimal is a simple matter of reversing
the process.
\end{flushleft}

\section{Endianness}
You will need to know about endianness anytime a single value spans
multiple bytes.
As an example, let's take the first 16 bytes of a small RIFF WAVE file:

\begin{Verbatim}[frame=single]
52 49 46 46 54 9b 12 00  57 41 56 45 66 6d 74 20
\end{Verbatim}
\noindent
The first four bytes are the ASCII string `RIFF' (\texttt{0x52 0x49 0x46 0x46}).
The next four bytes are a 32-bit unsigned integer which is a size value.
Reading from left to right, that value would be \texttt{0x549B1200}.
That's almost 1.5 gigabytes.
Since this file is nowhere near that large, we're clearly not
reading those bytes correctly.

The key is that RIFF WAVE files are `little endian'.
In plain English, that means we have to read in those bytes
from right to left.
Thus, the value is actually \texttt{0x00129B54}.
That's a little over 1 megabyte, which is closer to our expectations.

Remember that little endian reverses the bytes, not the hexadecimal
digits.  Simply reversing the string to \texttt{0x0021B945} is not correct.

\section{Character Encodings}

Many audio formats store metadata, which contains information about
the song's name, artist, album and so forth.
This information is stored as text, but it's important to know what
sort of text in order to read it and display it properly.

As an example, take the simple character \texttt{\'e}.
In latin-1 encoding, it is stored as a single byte \texttt{0xE9}.
In UTF-8 encoding, it is stored as the bytes \texttt{0xC3A9}.
In UTF-16BE encoding, it is stored as the bytes \texttt{0x00E9}.

Although decoding and encoding text is a complex subject beyond
the scope of this document, you must always be aware that
metadata may not be 7-bit ASCII text and should handle
it properly in whatever encoding is supported by the metadata
formats.
Look to your programming tools for libraries to assist in Unicode
text handling.
