%This work is licensed under the
%Creative Commons Attribution-Share Alike 3.0 United States License.
%To view a copy of this license, visit
%http://creativecommons.org/licenses/by-sa/3.0/us/ or send a letter to
%Creative Commons,
%171 Second Street, Suite 300,
%San Francisco, California, 94105, USA.

\chapter{DVD-Audio}
DVD-Audio is a format for delivering hi-fidelity, multichannel
audio on DVD media.
A DVD-Audio's \texttt{AUDIO\_TS} directory contains the
relevent data needed for decoding, spread into a lot of files
whose names are more than a little cryptic at first glance.

Unlike CD audio, which is simply a set of 1 to 99 identically-formatted
audio tracks (in terms of channel count, sample rate and bits per sample),
a DVD-Audio disc contains one or more titlesets.
Each titleset contains one or more titles, and each
title contains one or more tracks.
\begin{figure}[h]
  \includegraphics{figures/dvda/layout.pdf}
\end{figure}
\par
\noindent
Typically, a DVD-Audio disc will contain two titlesets,
one for audio and the other for video - which we can ignore.
The first titleset will often contain two titles,
one for 2 channel audio and the other for 5.1 channel audio.
Each title will usually contain a consistent number of tracks
as MLP or PCM encoded audio.
\par
With this in mind, we can now make some sense of
the \texttt{AUDIO\_TS} directory's contents:
\vskip .25in
$\texttt{\huge{AUDIO\_TS.IFO}}$
\hfill
information about the disc, including the number of titlesets
\vskip .25in
$\texttt{\huge{ATS\_}}\underbrace{\texttt{\huge{01}}}_{Titleset}\texttt{\huge{\_0.IFO}}$
\hfill
information about all the titles in a given titleset
\vskip .25in
$\texttt{\huge{ATS\_}}\underbrace{\texttt{\huge{01}}}_{Titleset}\texttt{\huge{\_}}\underbrace{\texttt{\huge{1}}}_{AOB~\#}\texttt{\huge{.AOB}}$
\hfill
audio data for one or more tracks in a given titleset
\vskip .25in
\par
All are binary files containing one or more, 2048 byte sectors.

\section{AUDIO\_TS.IFO}
Known as the ``Audio Manager'' or ``AMG'',
this is primarily a container of pointers to
other files on disc.
However, for our purposes, we're only interested
in the \VAR{Audio Titleset Count} value.
\begin{figure}[h]
  \includegraphics{figures/dvda/audio_ts_ifo.pdf}
\end{figure}

\clearpage

\section{ATS\_XX\_0.IFO}

\ALGORITHM{an \texttt{ATS\_XX\_0.IFO} file, a titleset number}{timestamps for each track in each title in the titleset, a list of sector pointers}
\SetKw{SEEK}{seek}
\SetKwData{IDENTIFIER}{identifier}
\SetKwData{TITLECOUNT}{title count}
\SetKwData{LASTADDRESS}{last byte address}
\SetKwData{TITLENUMBER}{title number}
\SetKwData{TITLEOFFSET}{title table offset}
\SetKwData{TRACKCOUNT}{track count}
\SetKwData{INDEXCOUNT}{index count}
\SetKwData{TITLELENGTH}{title PTS length}
\SetKwData{POINTERSOFFSET}{sector pointers offset}
\SetKwData{TRACKINDEX}{track index number}
\SetKwData{TRACKPTSINDEX}{track PTS index}
\SetKwData{TRACKPTSLENGTH}{track PTS length}
\SetKwData{INDEXID}{index ID}
\SetKwData{FIRSTSECTOR}{first sector}
\SetKwData{LASTSECTOR}{last sector}
$\IDENTIFIER \leftarrow$ \READ 12 bytes\;
\ASSERT $\IDENTIFIER = \texttt{"DVDAUDIO-ATS"}$\;
\SEEK to file position \texttt{0x800}\tcc*[r]{seek to the second sector in the file}
$\TITLECOUNT \leftarrow$ \READ 16 unsigned bits\;
\SKIP 16 bits\;
$\LASTADDRESS \leftarrow$ \READ 32 unsigned bits\;
\For{i = 0 \emph{\KwTo}\TITLECOUNT}{
  $\text{\TITLENUMBER}_i \leftarrow$ \READ 8 unsigned bits\;
  \SKIP 24 bits\;
  $\text{\TITLEOFFSET}_i \leftarrow$ \READ 32 unsigned bits\;
}
\For(\tcc*[f]{read title information}){i = 0 \emph{\KwTo}\TITLECOUNT}{
  \SEEK to file position $(\texttt{0x800} + \text{\TITLEOFFSET}_i)$\;
  \SKIP 16 bits\;
  $\text{\TRACKCOUNT}_i \leftarrow$ \READ 8 unsigned bits\;
  $\text{\INDEXCOUNT}_i \leftarrow$ \READ 8 unsigned bits\;
  $\text{\TITLELENGTH}_i \leftarrow$ \READ 32 unsigned bits\;
  \SKIP 32 bits\;
  $\text{\POINTERSOFFSET}_i \leftarrow$ \READ 16 unsigned bits\;
  \SKIP 16 bits\;
  \For(\tcc*[f]{read track information}){j = 0 \emph{\KwTo}$\text{\TRACKCOUNT}_i$}{
    \SKIP 32 bits\;
    $\text{\TRACKINDEX}_{i~j} \leftarrow$ \READ 8 unsigned bits\;
    \SKIP 8 bits\;
    $\text{\TRACKPTSINDEX}_{i~j} \leftarrow$ \READ 32 unsigned bits\;
    $\text{\TRACKPTSLENGTH}_{i~j} \leftarrow$ \READ 32 unsigned bits\;
    \SKIP 48 bits\;
  }
  \SEEK to file position $(\texttt{0x800} + \text{\TITLEOFFSET}_i + \text{\POINTERSOFFSET}_i)$\;
  \For(\tcc*[f]{read index information}){j = 0 \emph{\KwTo}$\text{\INDEXCOUNT}_i$}{
    $\text{\INDEXID}_{i~j} \leftarrow$ \READ 32 unsigned bits\;
    \ASSERT $\text{\INDEXID}_{i~j} = \texttt{0x01000000}$\;
    $\text{\FIRSTSECTOR}_{i~j} \leftarrow$ \READ 32 unsigned bits\;
    $\text{\LASTSECTOR}_{i~j} \leftarrow$ \READ 32 unsigned bits\;
  }
}
\Return \TITLECOUNT, \TRACKCOUNT, \INDEXCOUNT, \TITLELENGTH, \TRACKINDEX,
\TRACKPTSINDEX, \TRACKPTSLENGTH, \FIRSTSECTOR, \LASTSECTOR\;
\EALGORITHM

\clearpage

\subsubsection{ATS\_XX\_0.IFO Second Sector}
\begin{figure}[h]
\includegraphics{figures/dvda/ats_xx_0.pdf}
\end{figure}

\subsubsection{Title Table}
\begin{figure}[h]
  \includegraphics{figures/dvda/ats_title.pdf}
\end{figure}

\subsubsection{Sector Pointers Table}
\begin{figure}[h]
  \includegraphics{figures/dvda/ats_sectors.pdf}
\end{figure}

\clearpage

\section{ATS\_XX\_X.AOB}

All of a titleset's AOB files can be considered part of a
single, contiguous collection of sectors, each 2048 bytes long.
Thus, it's possible for the start and end sectors for a given track
(as indicated in the sector pointers table) to span two or more
AOB files.
Each sector contains one or more packets as part of a
``Packetized Elementary Stream''.

\begin{figure}[h]
  \includegraphics{figures/dvda/ats_xx_x.pdf}
\end{figure}
\par
\noindent
Packets with a \VAR{stream ID} of \texttt{0xBD} contain encoded audio data.
\VAR{Packet data length} is the length of all data after
the \VAR{packet data length} field to the end of the packet.
\par
\noindent
Each sector within an AOB file is prefixed by a \VAR{Pack Header},
as follows:
\begin{figure}[h]
  \includegraphics{figures/dvda/aob_pack_header.pdf}
\end{figure}
\par
\noindent
The three \VAR{Current PTS} values (3 bits, 15 bits and 15 bits, respectively)
combine to indicate the current position within the stream, in PTS ticks.
There are 90,000 PTS ticks per second.

\clearpage

\subsection{Packet Payload Extraction}

\begin{figure}[h]
  \includegraphics{figures/dvda/audio_packet.pdf}
\end{figure}

\clearpage

\section{MLP Decoding}
{\relsize{-1}
\ALGORITHM{packet data containing 1 or more MLP frames}{1 or more PCM frames}
\SetKwData{TOTALSIZE}{total frame size}
\While{MLP frames remain}{
  \SKIP 4 bits\;
  $\TOTALSIZE \leftarrow (\text{\READ 12 unsigned bits}) \times 2$\;
  \SKIP 16 bits\;
  decode next $(\TOTALSIZE - 4)$ bytes as MLP frame\;
}
\Return PCM frames\;
\EALGORITHM
}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_stream.pdf}
\end{figure}

\clearpage

\subsection{MLP Frame Decoding}
{\relsize{-1}
\ALGORITHM{MLP frame}{1 or more PCM frames}
\SetKw{OR}{or}
\SetKwData{BPS}{bits per sample}
\SetKwData{RATE}{sample rate}
\SetKwData{CHANNELCOUNT}{channel count}
\SetKwData{SUBSTREAMCOUNT}{substream count}
\SetKwData{CHECKDATA}{checkdata present}
\SetKwData{SUBSTREAMEND}{substream end}
\SetKwData{SUBSTREAM}{substream}
\SetKwData{PARITY}{parity}
\SetKwData{CRC}{CRC-8}
$\text{\SUBSTREAMCOUNT} \leftarrow$ read major sync\;
\ASSERT $(\SUBSTREAMCOUNT = 1)$ \OR $(\SUBSTREAMCOUNT = 2)$\;
\For{s = 0 \emph{\KwTo}\SUBSTREAMCOUNT}{
  $(\text{\CHECKDATA}_s~,~\text{\SUBSTREAMEND}_s) \leftarrow$ read substream info\;
}
\eIf{$\text{\CHECKDATA}_0 = 1$}{
  decode next $(\text{\SUBSTREAMEND}_0 - 2)$ bytes as $\text{\SUBSTREAM}_0$\;
  $\text{\PARITY}_0 \leftarrow$ \READ 8 unsigned bits\;
  $\text{\CRC}_0 \leftarrow$ \READ 8 unsigned bits\;
  verify $\text{\PARITY}_0$, $\text{\CRC}_0$ of $\text{\SUBSTREAM}_0$\;
}{
  decode next $\text{\SUBSTREAMEND}_0$ bytes as $\text{\SUBSTREAM}_0$\;
}
\uIf{$\SUBSTREAMCOUNT = 1$}{
  rematrix channels\;
}
\ElseIf{$\SUBSTREAMCOUNT = 2$}{
  \eIf{$\text{\CHECKDATA}_1 = 1$}{
    decode next $(\text{\SUBSTREAMEND}_1 - \text{\SUBSTREAMEND}_0 - 2)$ bytes as $\text{\SUBSTREAM}_1$\;
    $\text{\PARITY}_1 \leftarrow$ \READ 8 unsigned bits\;
    $\text{\CRC}_1 \leftarrow$ \READ 8 unsigned bits\;
    verify $\text{\PARITY}_1$, $\text{\CRC}_1$ of $\text{\SUBSTREAM}_1$\;
  }{
    decode next $(\text{\SUBSTREAMEND}_1 - \text{\SUBSTREAMEND}_0)$ bytes as $\text{\SUBSTREAM}_1$\;
  }
  combine substreams into single set of channels\;
  rematrix channels\;
}
\Return substream channels as PCM frames\;
\EALGORITHM
}

\clearpage

Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan nisl.



\clearpage

\subsubsection{Reading Major Sync}
This is a collection of information about the MLP stream
which occurs occasionally at the start of MLP frames.
Its values are consistent throughout the stream for any given track.
{\relsize{-1}
\ALGORITHM{MLP frame data}{substream count}
\SetKw{AND}{and}
\SetKw{OR}{or}
\SetKw{REWIND}{rewind stream}
\SetKwData{SYNCWORDS}{sync words}
\SetKwData{STREAMTYPE}{stream type}
\SetKwData{BPS}{bits per sample}
\SetKwFunction{BPSFUNC}{bps}
\SetKwData{RATE}{sample rate}
\SetKwFunction{RATEFUNC}{rate}
\SetKwData{CHANNELCOUNT}{channel count}
\SetKwData{CHANNELASSIGNMENT}{channel assignment}
\SetKwFunction{CHANNELFUNC}{channels}
\SetKwData{ISVBR}{is VBR}
\SetKwData{PEAKBITRATE}{peak bitrate}
\SetKwData{SUBSTREAMCOUNT}{substream count}
$\SYNCWORDS \leftarrow$ \READ 24 unsigned bits\;
$\STREAMTYPE \leftarrow$ \READ 8 unsigned bits\;
\eIf(\tcc*[f]{major sync found}){$(\SYNCWORDS = 16282223)$ \AND $(\STREAMTYPE = 187)$}{
  $\text{\BPS}_0 \leftarrow \BPSFUNC(\text{\READ 4 unsigned bits})$\;
  $\text{\BPS}_1 \leftarrow \BPSFUNC(\text{\READ 4 unsigned bits})$\;
  $\text{\RATE}_0 \leftarrow \RATEFUNC(\text{\READ 4 unsigned bits})$\;
  $\text{\RATE}_1 \leftarrow \RATEFUNC(\text{\READ 4 unsigned bits})$\;
  \SKIP 11 bits\;
  $(\text{\CHANNELCOUNT}~,~\text{\CHANNELASSIGNMENT}) \leftarrow \CHANNELFUNC(\text{\READ 5 unsigned bits})$\;
  \SKIP 48 bits\;
  $\text{\ISVBR} \leftarrow$ \READ 1 unsigned bit\;
  $\text{\PEAKBITRATE} \leftarrow$ \READ 15 unsigned bits\;
  $\text{\SUBSTREAMCOUNT} \leftarrow$ \READ 4 unsigned bits\;
  \ASSERT $(\text{\SUBSTREAMCOUNT} = 1)$ \OR $(\text{\SUBSTREAMCOUNT} = 2)$\;
  \SKIP 92 bits\;
  \Return $\text{\SUBSTREAMCOUNT}$\;
}(\tcc*[f]{major sync not found}){
  \REWIND 32 bits\;
  \Return substream count from previous major sync\;
}
\EALGORITHM
}
\begin{small}
  \begin{tabular}{|c|r|r|r|l|}
    \hline
    value & \texttt{bps} & \texttt{rate} & channels & channel assignment \\
    \hline
    \texttt{00000} & 16 & 48000 & 1 & front center \\
    \texttt{00001} & 20 & 96000 & 2 & front left, front right\\
    \texttt{00010} & 24 & 192000 & 3 & front left, front right, back center \\
    \texttt{00011} & & & 4 & front left, front right, back left, back right\\
    \texttt{00100} & & & 3 & front left, front right, LFE \\
    \texttt{00101} & & & 4 & front left, front right, LFE, back center \\
    \texttt{00110} & & & 5 & front left, front right, LFE, back left, back right \\
    \texttt{00111} & & & 3 & front left, front right, front center \\
    \texttt{01000} & & 44100 & 4 & front left, front right, front center, back center \\
    \texttt{01001} & & 88200 & 5 & front left, front right, front center, back left, back right \\
    \texttt{01010} & & 176400 & 4 & front left, front right, front center, LFE\\
    \texttt{01011} & & & 5 & front left, front right, front center, LFE, back center \\
    \texttt{01100} & & & 6 & front left, front right, front center, LFE back left, back right \\
    \texttt{01101} & & & 4 & front left, front right, front center, back center \\
    \texttt{01110} & & & 5 & front left, front right, front center, back left, back right \\
    \texttt{01111} & & & 4 & front left, front right, front center, LFE \\
    \texttt{10000} & & & 5 & front left, front right, front center, LFE, back center \\
    \texttt{10001} & & & 6 & front left, front right, front center, LFE, back left, back right \\
    \texttt{10010} & & & 5 & front left, front right, back left, back right, LFE \\
    \texttt{10011} & & & 5 & front left, front right, back left, back right, front center \\
    \texttt{10100} & & & 6 & front left, front right, back left, back right, front center, LFE \\
    \hline
  \end{tabular}
\end{small}

\clearpage

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_major_sync.pdf}
\end{figure}
\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_major_sync_parse.pdf}
\end{figure}
{\relsize{-1}
\begin{tabular}{rl}
  $\text{group}_0$ bits-per-sample & 24 \\
  $\text{group}_1$ bits-per-sample & 24 \\
  $\text{group}_0$ sample rate & 96000 Hz \\
  $\text{group}_1$ sample rate & 96000 Hz \\
  channel count & 5 \\
  channel assignment & front left, front right, LFE, back left, back right \\
  is VBR & yes \\
  peak bitrate & 1600 \\
  substream count & 2 \\
\end{tabular}
}

\clearpage

\subsubsection{Substream Info}
{\relsize{-1}
\ALGORITHM{MLP frame data}{checkdata present, substream end}
\SetKwData{EXTRAWORD}{extra word present}
\SetKwData{NONRESTART}{nonrestart substream}
\SetKwData{CHECKDATA}{checkdata present}
\SetKwData{SUBSTREAMEND}{substream end}
$\text{\EXTRAWORD} \leftarrow$ \READ 1 unsigned bit\;
\ASSERT $\text{\EXTRAWORD} = 0$\;
$\text{\NONRESTART} \leftarrow$ \READ 1 unsigned bit\;
$\text{\CHECKDATA} \leftarrow$ \READ 1 unsigned bit\;
\SKIP 1 bit\;
$\text{\SUBSTREAMEND} \leftarrow (\text{\READ 12 unsigned bits}) \times 2$\;
\Return $(\text{\CHECKDATA}~,~\text{\SUBSTREAMEND})$\;
\EALGORITHM
}
\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_substream_info.pdf}
\end{figure}
\par
\noindent
For example, given a frame with 2 substreams
and 2 substream info fields:
\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_substream_info_parse.pdf}
\end{figure}
\begin{table}[h]
\begin{tabular}{rrr}
& $\text{substream}_0$ & $\text{substream}_1$ \\
\hline
extra word present & 0 & 0 \\
nonrestart substream & 0 & 0 \\
checkdata present & 1 & 1 \\
pad & 1 & 0 \\
substream end & $72 \times 2 = 148$ & $159 \times 2 = 318$ \\
\end{tabular}
\end{table}
\par
\noindent
$\text{Substream Data}_0$ contains
the next 148 bytes following the $\text{Substream Info}_1$ field,
and $\text{Substream Data}_1$ contains 170 bytes
following $\text{Substream Data}_0$.
In addition, \VAR{checkdata present} values of 1
means both substreams will be followed by 8 bit parity and CRC-8 values.

\clearpage

\subsection{Decoding Substream}
{\relsize{-1}
\ALGORITHM{MLP substream data}{1 or more channels of PCM data, matrix parameters}
\SetKwData{PARAMSPRESENT}{parameters present}
\SetKwData{HEADERPRESENT}{restart header present}
\SetKwData{MINCHANNEL}{min channel}
\SetKwData{MAXCHANNEL}{max channel}
\SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
\SetKwData{NOISESHIFT}{noise shift}
\SetKwData{NOISEGENSEED}{noise gen seed}
\SetKwData{CHANNELASSIGNMENT}{channel assignment}
\SetKwData{LAST}{last block}
\SetKwData{BYPASSEDLSB}{bypassed LSB}
\SetKwData{RESIDUAL}{residual}
\SetKwData{FILTERED}{filtered}
\Repeat{$\text{\LAST}_s = 1$}{
  $\text{\PARAMSPRESENT}_s \leftarrow$ \READ 1 unsigned bit\;
  \eIf{$\text{\PARAMSPRESENT}_s = 1$}{
    $\text{\HEADERPRESENT}_s \leftarrow$ \READ 1 unsigned bit\;
    \eIf{$\text{\HEADERPRESENT}_s = 1$}{
      $(\text{\MINCHANNEL}_s~,~\text{\MAXCHANNEL}_s~,~\text{\MAXMATRIXCHANNEL}_s~,~\text{\NOISESHIFT}_s~,~\text{\NOISEGENSEED}_s~,\newline~\text{\CHANNELASSIGNMENT}_s) \leftarrow$ read restart header\;
    }{
      $(\text{\MINCHANNEL}_s~,~\text{\MAXCHANNEL}_s~,~\text{\MAXMATRIXCHANNEL}_s~,~\text{\NOISESHIFT}_s~,~\text{\NOISEGENSEED}_s~,\newline~\text{\CHANNELASSIGNMENT}_s) \leftarrow$ from previous block's restart header in substream\;
    }
    read decoding parameters with $\text{\HEADERPRESENT}_s$\;
  }{
    use substream's decoding parameters from previous block\; %%FIXME
  }
  \BlankLine
  $(\text{\BYPASSEDLSB}_{s}~,~\text{\RESIDUAL}_s) \leftarrow$ read block data based on decoding parameters\;
  \BlankLine
  \For{c = $\text{\MINCHANNEL}_s$ \emph{\KwTo}$\text{\MAXCHANNEL}_c$}{
    $\text{\FILTERED}_{s~c} \leftarrow$ filter $\text{\RESIDUAL}_s$ using FIR and IIR channel parameters\;
  }
  \BlankLine
  $\text{\LAST}_s \leftarrow$ \READ 1 unsigned bit\;
}
\BlankLine
\Return $(\text{\FILTERED}_{s}~,~\text{\MINCHANNEL}_s~,~\text{\MAXCHANNEL}_s~,~\text{\MAXMATRIXCHANNEL}_s~,~\text{\NOISESHIFT}_s~,~\text{\NOISEGENSEED}_s)$\;
\EALGORITHM
}

\clearpage

\subsection{Reading Restart Header}
{\relsize{-1}
\ALGORITHM{MLP substream data}{min channel, max channel, max matrix channel, noise shift, noise gen seed, channel assignments}
\SetKwData{HEADERSYNC}{header sync}
\SetKwData{NOISETYPE}{noise type}
\SetKwData{TIMESTAMP}{output timestamp}
\SetKwData{MINCHANNEL}{min channel}
\SetKwData{MAXCHANNEL}{max channel}
\SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
\SetKwData{NOISESHIFT}{noise shift}
\SetKwData{NOISEGENSEED}{noise gen seed}
\SetKwData{CHECKDATAPRESENT}{check data present}
\SetKwData{LOSSLESSCHECK}{lossless check}
\SetKwData{CHANNELASSIGNMENT}{channel assignment}
\SetKwData{CHECKSUM}{checksum}
$\text{\HEADERSYNC} \leftarrow$ \READ 13 unsigned bits\;
\ASSERT $\text{\HEADERSYNC} = \texttt{0x18F5}$\;
$\text{\NOISETYPE} \leftarrow$ \READ 1 unsigned bit\;
\ASSERT $\text{\NOISETYPE} = 0$\;
$\text{\TIMESTAMP} \leftarrow$ \READ 16 unsigned bits\;
$\text{\MINCHANNEL} \leftarrow$ \READ 4 unsigned bits\;
$\text{\MAXCHANNEL} \leftarrow$ \READ 4 unsigned bits\;
\ASSERT $\text{\MAXCHANNEL} \geq \text{\MINCHANNEL}$\;
$\text{\MAXMATRIXCHANNEL} \leftarrow$ \READ 4 unsigned bits\;
\ASSERT $\text{\MAXMATRIXCHANNEL} \geq \text{\MAXCHANNEL}$\;
$\text{\NOISESHIFT} \leftarrow$ \READ 4 unsigned bits\;
$\text{\NOISEGENSEED} \leftarrow$ \READ 23 unsigned bits\;
\SKIP 19 bits\;
$\text{\CHECKDATAPRESENT} \leftarrow$ \READ 1 unsigned bit\;
$\text{\LOSSLESSCHECK} \leftarrow$ \READ 8 unsigned bits\;
\SKIP 16 bits\;
\For{c = 0 \emph{\KwTo}$(\text{\MAXMATRIXCHANNEL} + 1)$}{
  $\text{\CHANNELASSIGNMENT}_{c} \leftarrow$ \READ 6 unsigned bits\;
  \ASSERT $\text{\CHANNELASSIGNMENT}_{c} \leq \text{\MAXMATRIXCHANNEL}$\;
}
$\text{\CHECKSUM} \leftarrow$ \READ 8 unsigned bits\;
\Return $(\text{\MINCHANNEL}~,~\text{\MAXCHANNEL}~,~\text{\MAXMATRIXCHANNEL}~,~\text{\NOISESHIFT}~,~\text{\NOISEGENSEED}~,\newline~\text{\CHANNELASSIGNMENT})$\;
\EALGORITHM
}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_restart_header.pdf}
\end{figure}

\clearpage

\subsubsection{Reading Restart Header Example}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_restart_header_parse1.pdf}
\end{figure}
\begin{table}[h]
{\relsize{-1}
  \begin{tabular}{rl}
    header sync & \texttt{0x18F5} \\
    noise type & 0 \\
    output timestamp & 0 \\
    min channel & 0 \\
    max channel & 1 \\
    max matrix channel & 1 \\
    noise shift & 0 \\
    noise gen seed & 1 \\
    check data present & 0 \\
    lossless check & 0 \\
    $\text{channel assignment}_0$ & 0 \\
    $\text{channel assignment}_1$ & 1 \\
    checksum & \texttt{0x11} \\
  \end{tabular}
}
\end{table}

\clearpage

\subsection{Decoding Parameters}

%%FIXME - offer breakdown of what parameters are for

Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan nisl.

\clearpage

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_decoding_params.pdf}
\end{figure}

\clearpage

\subsection{Reading Decoding Parameters}
{\relsize{-1}
\ALGORITHM{MLP substream data, restart header present flag, min channel, max channel, max matrix channel}{flags, block size, matrix parameters, output shifts, quant step sizes; FIR filter parameters, IIR filter parameters, Huffman parameters per channel}
\SetKw{OR}{or}
\SetKw{AND}{and}
\SetKwData{HEADERPRESENT}{restart header present}
\SetKwData{MINCHANNEL}{min channel}
\SetKwData{MAXCHANNEL}{max channel}
\SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
\SetKwData{PARAMSPRESENT}{parameters present}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{MATRIXCOUNT}{matrix count}
\SetKwData{MATRIXOUTCH}{matrix out channel}
\SetKwData{FRACTIONALBITS}{fractional bits}
\SetKwData{LSBBYPASS}{LSB bypass}
\SetKwData{MATRIXCOEFF}{matrix coeff}
\SetKwData{OUTPUTSHIFT}{output shift}
\SetKwData{QUANTSTEP}{quant step size}
\SetKwData{FLAGS}{flags}
\uIf(\tcc*[f]{parameter presence flags}){$\text{\HEADERPRESENT}_s = 1$}{
  \eIf{$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
    \For{f = 0 \emph{\KwTo}8}{
      $\text{\FLAGS}_{s~f} \leftarrow$ \READ 1 unsigned bit\;
    }
  }{
    $\text{\FLAGS}_s \leftarrow \texttt{[1, 1, 1, 1, 1, 1, 1, 1]}$\;
  }
}
\uElseIf{$(\text{\FLAGS}_{s~0} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  \For{f = 0 \emph{\KwTo}8}{
    $\text{\FLAGS}_{s~f} \leftarrow$ \READ 1 unsigned bit\;
  }
}
\Else{
  $\text{\FLAGS}_s \leftarrow$ from previous block in substream\;
}
\uIf(\tcc*[f]{block size}){$(\text{\FLAGS}_{s~7} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $\text{\BLOCKSIZE}_s \leftarrow$ \READ 9 unsigned bits\;
  \ASSERT $\text{\BLOCKSIZE}_s \geq 8$\;
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  $\text{\BLOCKSIZE}_s \leftarrow 8$\;
}
\Else{
  $\text{\BLOCKSIZE}_s \leftarrow$ from previous block in substream\;
}
\uIf(\tcc*[f]{matrix parameters}){$(\text{\FLAGS}_{s~6} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $(\text{\MATRIXCOUNT}_s~,~\text{\MATRIXOUTCH}_s~,~\text{\LSBBYPASS}_s~,~\text{\MATRIXCOEFF}_s) \leftarrow$ read matrix parameters\;
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  $(\text{\MATRIXCOUNT}_s~,~\text{\MATRIXOUTCH}_s~,~\text{\LSBBYPASS}_s~,~\text{\MATRIXCOEFF}_s) \leftarrow (0~,~\texttt{[]}~,~\texttt{[]}~,~\texttt{[]})$\;
}
\Else{
  $(\text{\MATRIXCOUNT}_s~,~\text{\MATRIXOUTCH}_s~,~\text{\LSBBYPASS}_s~,~\text{\MATRIXCOEFF}_s) \leftarrow$ from previous block\;
}
\uIf(\tcc*[f]{output shifts}){$(\text{\FLAGS}_{s~5} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  \For{c = 0 \emph{\KwTo}$(\text{\MAXMATRIXCHANNEL}_s + 1)$}{
    $\text{\OUTPUTSHIFT}_{s~c} \leftarrow$ \READ 4 signed bits\;
  }
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  \For{c = 0 \emph{\KwTo}$(\text{\MAXMATRIXCHANNEL}_s + 1)$}{
    $\text{\OUTPUTSHIFT}_{s~c} \leftarrow 0$\;
  }
}
\Else{
  $\text{\OUTPUTSHIFT}_{s} \leftarrow$ from previous block in substream\;
}
\uIf(\tcc*[f]{quant step sizes}){$(\text{\FLAGS}_{s~4} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  \For{c = $\text{\MINCHANNEL}_s$ \emph{\KwTo}$(\text{\MAXCHANNEL}_s + 1)$}{
    $\text{\QUANTSTEP}_{s~c} \leftarrow$ \READ 4 unsigned bits\;
  }
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  \For{c = $\text{\MINCHANNEL}_s$ \emph{\KwTo}$(\text{\MAXCHANNEL}_s + 1)$}{
    $\text{\QUANTSTEP}_{s~c} \leftarrow 0$\;
  }
}
\Else{
  $\text{\QUANTSTEP}_s \leftarrow$ from previous block in substream\;
}
\EALGORITHM
}

\clearpage

{\relsize{-1}
  \begin{algorithm}[H]
    \DontPrintSemicolon
    \SetKw{AND}{and}
    \SetKw{READ}{read}
    \SetKw{ASSERT}{assert}
    \SetKwData{BLOCKSIZE}{block size}
    \SetKwData{HEADERPRESENT}{restart header present}
    \SetKwData{MINCHANNEL}{min channel}
    \SetKwData{MAXCHANNEL}{max channel}
    \SetKwData{MATRIXCOUNT}{matrix count}
    \SetKwData{MATRIXOUTCH}{matrix out channel}
    \SetKwData{LSBBYPASS}{LSB bypass}
    \SetKwData{MATRIXCOEFF}{matrix coeff}
    \SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
    \SetKwData{OUTPUTSHIFT}{output shift}
    \SetKwData{QUANTSTEP}{quant step size}
    \SetKwData{FLAGS}{flags}
    \SetKwData{FIRORDER}{FIR order}
    \SetKwData{FIRSHIFT}{FIR shift}
    \SetKwData{FIRCOEFF}{FIR coeff}
    \SetKwData{FIRSTATE}{FIR state}
    \SetKwData{IIRORDER}{IIR order}
    \SetKwData{IIRSHIFT}{IIR shift}
    \SetKwData{IIRCOEFF}{IIR coeff}
    \SetKwData{IIRSTATE}{IIR state}
    \SetKwData{CODEBOOK}{codebook}
    \SetKwData{HUFFMANOFFSET}{Huffman offset}
    \SetKwData{HUFFMANLSBS}{Huffman LSBs}
    \SetKwFunction{LEN}{len}
    \For(\tcc*[f]{channel parameters}){c = $\text{\MINCHANNEL}_s$ \emph{\KwTo}$(\text{\MAXCHANNEL}_s + 1)$}{
      \uIf{$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
        \uIf(\tcc*[f]{FIR filter parameters}){$(\text{\FLAGS}_{s~3} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
          $(\text{\FIRORDER}_{s~c}~,~\text{\FIRSHIFT}_{s~c}~,~\text{\FIRCOEFF}_{s~c}~,~\text{\FIRSTATE}) \leftarrow$ read filter parameters\;
          \ASSERT $\LEN(\FIRSTATE) = 0$\tcc*[r]{FIR filter has no initial state}
        }
        \uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
          $(\text{\FIRORDER}_{s~c}~,~\text{\FIRSHIFT}_{s~c}~,~\text{\FIRCOEFF}_{s~c}~,~\text{\FIRSTATE}_{s~c}) \leftarrow (0~,~0~,~\texttt{[]}~,~\texttt{[]})$\;
        }
        \Else{
          $(\text{\FIRORDER}_{s~c}~,~\text{\FIRSHIFT}_{s~c}~,~\text{\FIRCOEFF}_{s~c}~,~\text{\FIRSTATE}_{s~c}) \leftarrow$ from previous block's corresponding channel in substream\;
        }
        \uIf(\tcc*[f]{IIR filter paramters}){$(\text{\FLAGS}_{s~2} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
          $(\text{\IIRORDER}_{s~c}~,~\text{\IIRSHIFT}_{s~c}~,~\text{\IIRCOEFF}_{s~c}~,~\text{\IIRSTATE}_{s~c}) \leftarrow$ read filter parameters\;
        }
        \uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
          $(\text{\IIRORDER}_{s~c}~,~\text{\IIRSHIFT}_{s~c}~,~\text{\IIRCOEFF}_{s~c}~,~\text{\IIRSTATE}_{s~c}) \leftarrow (0~,~0~,~\texttt{[]}~,~\texttt{[]})$\;
        }
        \Else{
          $(\text{\IIRORDER}_{s~c}~,~\text{\IIRSHIFT}_{s~c}~,~\text{\IIRCOEFF}_{s~c}~,~\text{\IIRSTATE}_{s~c}) \leftarrow$ from previous block's corresponding channel in substream\;
        }
        \uIf(\tcc*[f]{Huffman offset}){$(\text{\FLAGS}_{s~1} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
          $\text{\HUFFMANOFFSET}_{s~c} \leftarrow$ \READ 15 signed bits\;
        }
        \uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
          $\text{\HUFFMANOFFSET}_{s~c} \leftarrow 0$\;
        }
        \Else{
          $\text{\HUFFMANOFFSET}_{s~c} \leftarrow$ from previous block's corresponding channel in substream\;
        }
        $\text{\CODEBOOK}_{s~c} \leftarrow$ \READ 2 unsigned bits\;
        $\text{\HUFFMANLSBS}_{s~c} \leftarrow$ \READ 5 unsigned bits\;
        \ASSERT $\text{\HUFFMANLSBS}_{s~c} \leq 24$\;
      }
      \uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
        $(\text{\FIRORDER}_{s~c}~,~\text{\FIRSHIFT}_{s~c}~,~\text{\FIRCOEFF}_{s~c}~,~\text{\FIRSTATE}_{s~c}) \leftarrow (0~,~0~,~\texttt{[]}~,~\texttt{[]})$\;
        $(\text{\IIRORDER}_{s~c}~,~\text{\IIRSHIFT}_{s~c}~,~\text{\IIRCOEFF}_{s~c}~,~\text{\IIRSTATE}_{s~c}) \leftarrow (0~,~0~,~\texttt{[]}~,~\texttt{[]})$\;
        $\text{\HUFFMANOFFSET}_{s~c} \leftarrow 0$\;
        $\text{\CODEBOOK}_{s~c} \leftarrow 0$\;
        $\text{\HUFFMANLSBS}_{s~c} \leftarrow 23$\;
      }
      \Else{
        $(\text{\FIRORDER}_{s~c}~,~\text{\FIRSHIFT}_{s~c}~,~\text{\FIRCOEFF}_{s~c}~,~\text{\FIRSTATE}_{s~c}) \leftarrow$ from previous block's corresponding channel in substream\;
        $(\text{\IIRORDER}_{s~c}~,~\text{\IIRSHIFT}_{s~c}~,~\text{\IIRCOEFF}_{s~c}~,~\text{\IIRSTATE}_{s~c}) \leftarrow$ from previous block's corresponding channel in substream\;
        $\text{\HUFFMANOFFSET}_{s~c} \leftarrow$ from previous block's corresponding channel in substream\;
        $\text{\CODEBOOK}_{s~c} \leftarrow$ from previous block's corresponding channel in substream\;
        $\text{\HUFFMANLSBS}_{s~c} \leftarrow$ from previous block's corresponding channel in substream\;
      }
    }
    \Return
    \begin{tabular}{>{$}r<{$}>{$}r<{$}>{$}r<{$}>{$}r<{$}}
      \text{\FLAGS}_s & \text{\BLOCKSIZE}_s \\
      \text{\MATRIXCOUNT}_s & \text{\MATRIXOUTCH}_s & \text{\LSBBYPASS}_s & \text{\MATRIXCOEFF}_s \\
      \text{\OUTPUTSHIFT}_{s} & \text{\QUANTSTEP}_{s} \\
      \text{\FIRORDER}_{s} & \text{\FIRSHIFT}_{s} & \text{\FIRCOEFF}_{s} & \text{\FIRSTATE}_{s} \\
      \text{\IIRORDER}_{s} & \text{\IIRSHIFT}_{s} & \text{\IIRCOEFF}_{s} & \text{\IIRSTATE}_{s} \\
      \text{\HUFFMANOFFSET}_{s} & \text{\CODEBOOK}_{s} & \text{\HUFFMANLSBS}_{s} \\
    \end{tabular}
  \end{algorithm}
}

\clearpage

\subsubsection{Reading Matrix Parameters}
{\relsize{-1}
  \ALGORITHM{MLP substream data, max matrix channel}{matrix count, matrix out channels, LSB bypass values, matrix coefficients}
  \SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
  \SetKwData{MATRIXCOUNT}{matrix count}
  \SetKwData{MATRIXOUTCH}{matrix out channel}
  \SetKwData{FRACTIONALBITS}{fractional bits}
  \SetKwData{LSBBYPASS}{LSB bypass}
  \SetKwData{MATRIXCOEFF}{matrix coefficient}
  $\text{\MATRIXCOUNT} \leftarrow$ \READ 4 unsigned bits\;
  \For{m = 0 \emph{\KwTo}$\text{\MATRIXCOUNT}$}{
    $\text{\MATRIXOUTCH}_{m} \leftarrow$ \READ 4 unsigned bits\;
    \ASSERT $\text{\MATRIXOUTCH}_{m} \leq \text{\MAXMATRIXCHANNEL}_s$\;
    $\text{\FRACTIONALBITS}_{m} \leftarrow$ \READ 4 unsigned bits\;
    \ASSERT $\text{\FRACTIONALBITS}_{m} \leq 14$\;
    $\text{\LSBBYPASS}_{m} \leftarrow$ \READ 1 unsigned bit\;
    \For{c = 0 \emph{\KwTo}$(\text{\MAXMATRIXCHANNEL}_s + 3)$}{
      \eIf{$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
        $v_{m~c} \leftarrow $ \READ $(\text{\FRACTIONALBITS}_{m} + 2)$ signed bits\;
        $\text{\MATRIXCOEFF}_{m~c} \leftarrow v_{m~c} \times 2 ^ {14 - \text{\FRACTIONALBITS}_m}$\;
      }{
        $\text{\MATRIXCOEFF}_{m~c} \leftarrow 0$\;
      }
    }
  }
  \Return $(\text{\MATRIXCOUNT}~,~\text{\MATRIXOUTCH}~,~\text{\LSBBYPASS}~,~\text{\MATRIXCOEFF})$\;
  \EALGORITHM
}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_matrix_params.pdf}
\end{figure}

\clearpage

\subsubsection{Reading Filter Parameters}
{\relsize{-1}
  \ALGORITHM{MLP substream data}{order, shift, coefficients, state values}
  \SetKwData{ORDER}{order}
  \SetKwData{SHIFT}{shift}
  \SetKwData{COEFFBITS}{coeff bits}
  \SetKwData{COEFFSHIFT}{coeff shift}
  \SetKwData{COEFF}{coefficient}
  \SetKwData{STATEBITS}{state bits}
  \SetKwData{STATESHIFT}{state shift}
  \SetKwData{STATE}{state}
  $\text{\ORDER} \leftarrow$ \READ 4 unsigned bits\;
  \ASSERT $\text{\ORDER} \leq 4$\;
  \eIf{$\text{\ORDER} > 0$}{
    $\text{\SHIFT} \leftarrow$ \READ 4 unsigned bits\;
    $\text{\COEFFBITS} \leftarrow$ \READ 5 unsigned bits\;
    \ASSERT $1 < \text{\COEFFBITS} < 16$\;
    $\text{\COEFFSHIFT} \leftarrow$ \READ 3 unsigned bits\;
    \ASSERT $(\text{\COEFFBITS} + \text{\COEFFSHIFT}) \leq 16$\;
    \For{i = 0 \emph{\KwTo}$\text{\ORDER}$}{
      $v_{i} \leftarrow$ \READ $(\text{\COEFFBITS})$ signed bits\;
      $\text{\COEFF}_{i} \leftarrow v_{i} \times 2 ^ {\text{\COEFFSHIFT}}$\;
    }
    \eIf{$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
      $\text{\STATEBITS} \leftarrow$ \READ 4 unsigned bits\;
      $\text{\STATESHIFT} \leftarrow$ \READ 4 unsigned bits\;
      \For{i = 0 \emph{\KwTo}$\text{\ORDER}$}{
        $s_{i} \leftarrow$ \READ $(\text{\STATEBITS})$ signed bits\;
        $\text{\STATE}_{\text{\ORDER} - i - 1} \leftarrow s_{i} \times 2 ^ {\text{\STATESHIFT}}$\;
      }
    }{
      $\text{\STATE} \leftarrow \texttt{[]}$\;
    }
  }{
    $\text{\SHIFT} \leftarrow 0$\;
    $\text{\COEFF} \leftarrow \texttt{[]}$\;
    $\text{\STATE} \leftarrow \texttt{[]}$\;
  }
  \Return $(\text{\ORDER}~,~\text{\SHIFT}~,~\text{\COEFF}~,~\text{\STATE})$\;
  \EALGORITHM
}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_filter_params.pdf}
\end{figure}

\clearpage

\subsubsection{Reading Decoding Parameters Example}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_decoding_params_parse.pdf}
\end{figure}

\clearpage

For example, given that a restart header is present with the values:
\begin{table}[h]
  {\relsize{-1}
    \begin{tabular}{rl}
      min channel & 0 \\
      max channel & 1 \\
      max matrix channel & 1 \\
    \end{tabular}
  }
\end{table}
\par
\noindent
our decoding parameters for a given substream are:
\begin{table}[h]
{\relsize{-1}
  \begin{tabular}{rlrl}
    \hline
    flags present & 0 \\
    flags & \texttt{[1, 1, 1, 1, 1, 1, 1, 1]} \\
    \hline
    block size present & 0 \\
    block size & 8 PCM frames \\
    \hline
    matrix parameters present & 1 \\
    matrix count & 2 \\
    $\text{matrix out channel}_0$ & 1 &
    $\text{matrix out channel}_1$ & 0 \\
    $\text{fractional bits}_0$ & 13 &
    $\text{fractional bits}_1$ & 13 \\
    $\text{LSB bypass}_0$ & 0 &
    $\text{LSB bypass}_1$ & 0 \\
    $\text{matrix coeff. present}_{0~0}$ & 0 &
    $\text{matrix coeff. present}_{1~0}$ & 1 \\
    $\text{matrix coeff.}_{0~0}$ & 0 &
    $\text{matrix coeff.}_{1~0}$ & -2053 \\
    $\text{matrix coeff. present}_{0~1}$ & 1 &
    $\text{matrix coeff. present}_{1~1}$ & 0 \\
    $\text{matrix coeff.}_{0~1}$ & -2053 &
    $\text{matrix coeff.}_{1~1}$ & 0 \\
    $\text{matrix coeff. present}_{0~2}$ & 1 &
    $\text{matrix coeff. present}_{1~2}$ & 1 \\
    $\text{matrix coeff.}_{0~2}$ & -32 &
    $\text{matrix coeff.}_{1~2}$ & 32 \\
    $\text{matrix coeff. present}_{0~3}$ & 1 &
    $\text{matrix coeff. present}_{1~3}$ & 1 \\
    $\text{matrix coeff.}_{0~3}$ & 32 &
    $\text{matrix coeff.}_{1~3}$ & 32 \\
    \hline
    output shift present & 1 \\
    $\text{output shift}_0$ & 1 &
    $\text{output shift}_1$ & 1 \\
    \hline
    quantum step size present & 0 \\
    \hline
    $\text{channel parameters present}_0$ & 1 &
    $\text{channel parameters present}_1$ & 1 \\
    $\text{FIR parameters present}_0$ & 0 &
    $\text{FIR parameters present}_1$ & 0 \\
    $\text{IIR parameters present}_0$ & 0 &
    $\text{IIR parameters present}_1$ & 0 \\
    $\text{Huffman offset present}_0$ & 0 &
    $\text{Huffman offset present}_1$ & 0 \\
    $\text{codebook}_0$ & 0 &
    $\text{codebook}_1$ & 0 \\
    $\text{Huffman LSB}_0$ & 1 &
    $\text{Huffman LSB}_1$ & 1 \\
    \hline
  \end{tabular}
}
\end{table}

\clearpage

\subsection{Reading Block Data}
{\relsize{-1}
\ALGORITHM{block size, min channel, max channel, matrix count; LSB bypass for each matrix;\newline quant step size, Huffman LSB, codebook, Huffman offset for each channel}{bypassed LSBs for each matrix, residuals for each channel}
\SetKwData{MINCHANNEL}{min channel}
\SetKwData{MAXCHANNEL}{max channel}
\SetKwData{CODEBOOK}{codebook}
\SetKwData{LSBBITS}{LSB bits}
\SetKwData{HUFFMANLSBS}{Huffman LSBs}
\SetKwData{QUANTSTEP}{quant step size}
\SetKwData{SIGNSHIFT}{sign shift}
\SetKwData{HUFFMANOFFSET}{Huffman offset}
\SetKwData{SIGNEDHUFFMANOFFSET}{signed Huffman offset}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{MATRIXCOUNT}{matrix count}
\SetKwData{LSBBYPASS}{LSB bypass}
\SetKwData{BYPASSEDLSB}{bypassed LSB}
\SetKwData{MSB}{MSB}
\SetKwData{LSB}{LSB}
\SetKwData{RESIDUAL}{residual}
\For(\tcc*[f]{calculate signed Huffman offset}){c = $\text{\MINCHANNEL}_s$ \emph{\KwTo}$(\text{\MAXCHANNEL}_s + 1)$}{
  $\text{\LSBBITS}_{s~c} \leftarrow \text{\HUFFMANLSBS}_{s~c} - \text{\QUANTSTEP}_{s~c}$\;
  \eIf{$\text{\CODEBOOK}_{s~c} > 0$}{
    $\text{\SIGNSHIFT}_{s~c} \leftarrow \text{\LSBBITS}_{s~c} + 2 - \text{\CODEBOOK}_{s~c}$\;
    \eIf{$\text{\SIGNSHIFT}_{s~c} \geq 0$}{
      $\text{\SIGNEDHUFFMANOFFSET}_{s~c} \leftarrow \text{\HUFFMANOFFSET}_{s~c} - 7 \times 2 ^ {\text{\LSBBITS}_{s~c}} - 2 ^ {\text{\SIGNSHIFT}_{s~c}}$\;
    }{
      $\text{\SIGNEDHUFFMANOFFSET}_{s~c} \leftarrow \text{\HUFFMANOFFSET}_{s~c} - 7 \times 2 ^ {\text{\LSBBITS}_{s~c}}$\;
    }
  }{
    $\text{\SIGNSHIFT}_{s~c} \leftarrow \text{\LSBBITS}_{s~c} - 1$\;
    \eIf{$\text{\SIGNSHIFT}_{s~c} \geq 0$}{
      $\text{\SIGNEDHUFFMANOFFSET}_{s~c} \leftarrow \text{\HUFFMANOFFSET}_{s~c} - 2 ^ {\text{\SIGNSHIFT}_{s~c}}$\;
    }{
      $\text{\SIGNEDHUFFMANOFFSET}_{s~c} \leftarrow \text{\HUFFMANOFFSET}_{s~c}$\;
    }
  }
}
\BlankLine
\For{i = 0 \emph{\KwTo}$\text{\BLOCKSIZE}_s$}{
  \For(\tcc*[f]{read bypassed LSBs for each matrix}){m = 0 \emph{\KwTo}$\text{\MATRIXCOUNT}_s$}{
    \eIf{$\text{\LSBBYPASS}_{s~m} = 1$}{
      $\text{\BYPASSEDLSB}_{s~m~i} \leftarrow$ \READ 1 unsigned bit\;
    }{
      $\text{\BYPASSEDLSB}_{s~m~i} \leftarrow 0$\;
    }
  }
  \For(\tcc*[f]{read residuals for each channel}){c = $\text{\MINCHANNEL}_s$ \emph{\KwTo}$(\text{\MAXCHANNEL}_s + 1)$}{
    \uIf{$\text{\CODEBOOK}_{s~c} = 0$}{
      $\text{\MSB}_{s~c~i} \leftarrow 0$\;
    }
    \uElseIf{$1 \leq \text{\CODEBOOK}_{s~c} \leq 3$}{
      $\text{\MSB}_{s~c~i} \leftarrow$ read Huffman value from $\text{\CODEBOOK}_{s~c}$\;
    }
    \Else{$\text{\MSB}_{s~c~i} \leftarrow -1$}
    \ASSERT $\text{\MSB}_{s~c~i} \geq 0$\;
    \BlankLine
    $\text{\LSB}_{s~c~i} \leftarrow$ \READ $(\text{\LSBBITS}_{s~c})$ unsigned bits\;
    $\text{\RESIDUAL}_{s~c~i} \leftarrow ((\text{\MSB}_{s~c~i} \times 2 ^ {\text{\LSBBITS}_{s~c}}) + \text{\LSB}_{s~c~i} + \text{\SIGNEDHUFFMANOFFSET}_{s~c}) \times 2 ^ {\text{\QUANTSTEP}_{s~c}}$\;
  }
}
\BlankLine
\Return $(\text{\BYPASSEDLSB}_{s}~,~\text{\RESIDUAL}_s)$\;
\EALGORITHM
}

\clearpage

\begin{figure}[h]
  \label{mlp_codebooks}
  \includegraphics{figures/dvda/mlp_codebook1.pdf}
  \caption{Codebook 1}
  \vskip 2em
  \includegraphics{figures/dvda/mlp_codebook2.pdf}
  \caption{Codebook 2}
  \vskip 2em
  \includegraphics{figures/dvda/mlp_codebook3.pdf}
  \caption{Codebook 3}
\end{figure}

\clearpage

\subsubsection{Reading Block Data Example}
Given the channel parameters:
\begin{table}[h]
{\relsize{-1}
\begin{tabular}{rrr}
& channel 0 & channel 1 \\
\hline
$\text{Huffman offset}_c$ & 0 & 0 \\
$\text{codebook}_c$ & 1 & 2 \\
$\text{Huffman LSBs}_c$ & 2 & 2 \\
\hline
$\text{LSB bits}_c$ & 2 & 2 \\
$\text{sign shift}_c$ & $3$ & $2$ \\
$\text{signed Huffman offset}_c$ & $0 - 7 \times 2 ^ 2 - 2 ^ 3 = -36$ & $0 - 7 \times 2 ^ 2 - 2 ^ 2 = -32$ \\
\end{tabular}
}
\end{table}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_block_parse.pdf}
\end{figure}
{\relsize{-1}
  \begin{tabular}{r||rr>{$}r<{$}|rr>{$}r<{$}}
    $i$ & $\text{MSB}_{0~i}$ & $\text{LSB}_{0~i}$ & \text{residual}_{0~i} &
    $\text{MSB}_{1~i}$ & $\text{LSB}_{1~i}$ & \text{residual}_{1~i} \\
    \hline
    0 & 9 & 3 & 9 \times 2 ^ 2 + 3 - 36 = 3 &
    7 & 1 & 7 \times 2 ^ 2 + 1 - 32 = -3 \\
    1 & 11 & 2 & 11 \times 2 ^ 2 + 2 - 36 = 10 &
    7 & 2 & 7 \times 2 ^ 2 + 2 - 32 = -2 \\
    2 & 11 & 0 & 11 \times 2 ^ 2 + 0 - 36 = 8 &
    8 & 0 & 8 \times 2 ^ 2 + 0 - 32 = 0 \\
    3 & 8 & 3 & 8 \times 2 ^ 2 + 3 - 36 = -1 &
    9 & 3 & 9 \times 2 ^ 2 + 3 - 32 = 7 \\
    4 & 8 & 3 & 8 \times 2 ^ 2 + 3 - 36 = -1 &
    3 & 3 & 3 \times 2 ^ 2 + 3 - 32 = -17 \\
    5 & 11 & 0 & 11 \times 2 ^ 2 + 0 - 36 = 8 &
    4 & 1 & 4 \times 2 ^ 2 + 1 - 32 = -15 \\
    6 & 12 & 3 & 12 \times 2 ^ 2 + 3 - 36 = 15 &
    6 & 0 & 6 \times 2 ^ 2 + 0 - 32 = -8 \\
    7 & 11 & 1 & 11 \times 2 ^ 2 + 1 - 36 = 9 &
    6 & 3 & 6 \times 2 ^ 2 + 3 - 32 = -5 \\
    8 & 5 & 0 & 5 \times 2 ^ 2 + 0 - 36 = -16 &
    8 & 0 & 8 \times 2 ^ 2 + 0 - 32 = 0 \\
    9 & 7 & 0 & 7 \times 2 ^ 2 + 0 - 36 = -8 &
    8 & 3 & 8 \times 2 ^ 2 + 3 - 32 = 3 \\
  \end{tabular}
}

\clearpage

\subsection{Residual Filtering}
{\relsize{-1}
\ALGORITHM{block size, signed residual values, channel's quant step size,\newline FIR order, FIR shift, FIR coefficients, FIR state,\newline IIR order, IIR shift, IIR coefficients, IIR state}{filtered residual values, new FIR state, new IIR state}
\SetKw{AND}{and}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SHIFT}{shift}
\SetKwData{FIRORDER}{FIR order}
\SetKwData{FIRSHIFT}{FIR shift}
\SetKwData{FIRCOEFF}{FIR coeff}
\SetKwData{FIRSTATE}{FIR state}
\SetKwData{IIRORDER}{IIR order}
\SetKwData{IIRSHIFT}{IIR shift}
\SetKwData{IIRCOEFF}{IIR coeff}
\SetKwData{IIRSTATE}{IIR state}
\SetKwData{RESIDUAL}{residual}
\SetKwData{SUM}{sum}
\SetKwData{SHIFTEDSUM}{shifted sum}
\SetKwData{FILTERED}{filtered}
\SetKwFunction{MASK}{mask}
\SetKwData{QUANTSIZE}{quant step size}
\ASSERT $(\text{\FIRORDER} + \text{\IIRORDER}) \leq 8$\;
\uIf{$(\text{\FIRORDER} > 0)$ \AND $(\text{\IIRORDER} > 0)$}{
  \ASSERT $\text{\FIRSHIFT} = \text{\IIRSHIFT}$\;
  $\text{\SHIFT} \leftarrow \text{\FIRSHIFT}$\;
}
\uElseIf{$\text{\FIRORDER} > 0$}{
  $\text{\SHIFT} \leftarrow \text{\FIRSHIFT}$\;
}
\Else{
  $\text{\SHIFT} \leftarrow \text{\IIRSHIFT}$\;
}
\For{i = 0 \emph{\KwTo}$\text{\BLOCKSIZE}_s$}{
  $\text{\SUM}_i \leftarrow 0$\;
  \For(\tcc*[f]{calculate FIR sum}){j = 0 \emph{\KwTo}$\text{\FIRORDER}$}{
    \eIf{$(i - j - 1) < 0$}{
      $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\FIRCOEFF}_j \times \text{\FIRSTATE}_{\FIRORDER + (i - j - 1)}$\;
    }{
      $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\FIRCOEFF}_j \times \text{\FILTERED}_{i - j - 1}$\;
    }
  }
  \For(\tcc*[f]{calculate IIR sum}){k = 0 \emph{\KwTo}$\text{\IIRORDER}$}{
    $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\IIRCOEFF}_k \times \text{\IIRSTATE}_{\IIRORDER + (i - k - 1)}$\;
  }
  \BlankLine
  $\text{\SHIFTEDSUM}_i \leftarrow \lfloor\text{\SUM}_i \div 2 ^ {\SHIFT}\rfloor$\;
  \BlankLine
  $\text{\FILTERED}_i \leftarrow \MASK(\text{\SHIFTEDSUM}_i + \text{\RESIDUAL}_i~,~\text{\QUANTSIZE})$\;
  \BlankLine
  $\text{\IIRSTATE}_{i + \text{\IIRORDER}} \leftarrow \text{\FILTERED}_i - \text{\SHIFTEDSUM}_i$\;
}
\Return $(\text{\FILTERED}~,~\text{\FILTERED}_{[(\text{\BLOCKSIZE} - 8)\IDOTS\text{\BLOCKSIZE}]}~,~\text{\IIRSTATE}_{[(\text{\BLOCKSIZE} - 8)\IDOTS\text{\BLOCKSIZE}]})$\;
\EALGORITHM
}
\vskip .25in
\par
\noindent
where \texttt{mask} is defined as:
\begin{equation*}
\texttt{mask}(x~,~q) =\begin{cases}x & \text{ if } q = 0 \\
x - (x \bmod 2 ^ q) & \text{ if } q > 0
\end{cases}
\end{equation*}

%%FIXME - add residual filtering example

\clearpage

\subsection{Rematrixing Channels}
\ALGORITHM{block size, filtered residuals, noise shift, noise gen seed,\newline matrix count, max matrix channel, matrix out channels, matrix coefficients\newline quant step sizes, bypassed LSBs}{rematrixed channels, updated noise gen seed}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{NOISE}{noise}
\SetKwData{NOISESHIFT}{noise shift}
\SetKwData{SHIFTED}{shifted}
\SetKwData{NOISEGENSEED}{noise gen seed}
\SetKwData{MATRIXCOUNT}{matrix count}
\SetKwData{SUM}{sum}
\SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
\SetKwData{FILTERED}{filtered}
\SetKwData{MATRIXCOEFF}{matrix coefficient}
\SetKwData{REMATRIXED}{rematrixed}
\SetKwData{MATRIXOUTCHANNEL}{matrix out channel}
\SetKwData{QUANTSTEPSIZE}{quant step size}
\SetKwData{BYPASSEDLSB}{bypassed LSB}
\SetKwFunction{MASK}{mask}
\SetKwFunction{CROP}{crop}
\For(\tcc*[f]{generate noise channels}){i = 0 \emph{\KwTo}\BLOCKSIZE}{
  $\text{\SHIFTED}_i \leftarrow \lfloor\text{\NOISEGENSEED} \div 2 ^ 7\rfloor \bmod{2 ^ {16}}$\;
  $\text{\NOISE}_{0~i} \leftarrow \CROP(\lfloor\text{\NOISEGENSEED} \div 2 ^ {15}\rfloor) \times 2 ^ {\text{\NOISESHIFT}}$\;
  $\text{\NOISE}_{1~i} \leftarrow \CROP(\text{\SHIFTED}_i) \times 2 ^ {\text{\NOISESHIFT}}$\;
  $\text{\NOISEGENSEED} \leftarrow ((\text{\NOISEGENSEED} \times 2 ^ {16}) \bmod{2 ^ {32}}) \xor \text{\SHIFTED}_i \xor (\text{\SHIFTED}_i \times 2 ^ 5)$\;
}
\BlankLine
\For(\tcc*[f]{perform channel rematrixing}){m = 0 \emph{\KwTo}\MATRIXCOUNT}{
  $o \leftarrow \text{\MATRIXOUTCHANNEL}_m$\;
  \For{i = 0 \emph{\KwTo}\BLOCKSIZE}{
    $\text{\SUM}_i \leftarrow 0$\;
    \For{c = 0 \emph{\KwTo}$\MAXMATRIXCHANNEL + 1$}{
      $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\FILTERED}_{c~i} \times \text{\MATRIXCOEFF}_{m~c}$\;
    }
    $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\NOISE}_{0~i} \times \text{\MATRIXCOEFF}_{m~(\MAXMATRIXCHANNEL + 1)}$\;
    $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\NOISE}_{1~i} \times \text{\MATRIXCOEFF}_{m~(\MAXMATRIXCHANNEL + 2)}$\;
    $\text{\REMATRIXED}_{o~i} \leftarrow \MASK(\lfloor\text{\SUM}_i \div 2 ^ {14}\rfloor~,~\text{\QUANTSTEPSIZE}_{o}) + \text{\BYPASSEDLSB}_{m~i}$\;
  }
}
\Return $(\REMATRIXED~,~\NOISEGENSEED)$\;
\EALGORITHM
\vskip .25in
\par
\noindent
where \texttt{crop} is defined as:
\begin{align*}
  \texttt{crop}(x) &=
  \begin{cases}
    x \bmod{2 ^ 8} & \text{if } \lfloor (x \bmod{2 ^ 8}) \div 2 ^ 7\rfloor = 0 \\
    (x \bmod{2 ^ 7}) - 2 ^ 7 & \text{if } \lfloor (x \bmod{2 ^ 8}) \div 2 ^ 7\rfloor \neq 0
  \end{cases}
  \intertext{and \texttt{mask} is defined as:}
  \texttt{mask}(x~,~q) &=\begin{cases}x & \text{ if } q = 0 \\
  x - (x \bmod 2 ^ q) & \text{ if } q > 0
  \end{cases}
\end{align*}

%%FIXME - add rematrixing example
