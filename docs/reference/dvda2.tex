%This work is licensed under the
%Creative Commons Attribution-Share Alike 3.0 United States License.
%To view a copy of this license, visit
%http://creativecommons.org/licenses/by-sa/3.0/us/ or send a letter to
%Creative Commons,
%171 Second Street, Suite 300,
%San Francisco, California, 94105, USA.

\chapter{DVD-Audio}
DVD-Audio is a format for delivering hi-fidelity, multichannel
audio on DVD media.
A DVD-Audio's \texttt{AUDIO\_TS} directory contains the
relevent data needed for decoding, spread into a lot of files
whose names are more than a little cryptic at first glance.

Unlike CD audio, which is simply a set of 1 to 99 identically-formatted
audio tracks (in terms of channel count, sample rate and bits per sample),
a DVD-Audio disc contains one or more titlesets.
Each titleset contains one or more titles, and each
title contains one or more tracks.
\begin{figure}[h]
  \includegraphics{figures/dvda/layout.pdf}
\end{figure}
\par
\noindent
Typically, a DVD-Audio disc will contain two titlesets,
one for audio and the other for video - which we can ignore.
The first titleset will often contain two titles,
one for 2 channel audio and the other for 5.1 channel audio.
Each title will usually contain a consistent number of tracks
as MLP or PCM encoded audio.
\par
With this in mind, we can now make some sense of
the \texttt{AUDIO\_TS} directory's contents:
\vskip .25in
$\texttt{\huge{AUDIO\_TS.IFO}}$
\hfill
information about the disc, including the number of titlesets
\vskip .25in
$\texttt{\huge{ATS\_}}\underbrace{\texttt{\huge{01}}}_{Titleset}\texttt{\huge{\_0.IFO}}$
\hfill
information about all the titles in a given titleset
\vskip .25in
$\texttt{\huge{ATS\_}}\underbrace{\texttt{\huge{01}}}_{Titleset}\texttt{\huge{\_}}\underbrace{\texttt{\huge{1}}}_{AOB~\#}\texttt{\huge{.AOB}}$
\hfill
audio data for one or more tracks in a given titleset
\vskip .25in
\par
All are binary files containing one or more, 2048 byte sectors.

\section{AUDIO\_TS.IFO}
Known as the ``Audio Manager'' or ``AMG'',
this is primarily a container of pointers to
other files on disc.
However, for our purposes, we're only interested
in the \VAR{Audio Titleset Count} value.
\begin{figure}[h]
  \includegraphics{figures/dvda/audio_ts_ifo.pdf}
\end{figure}

\clearpage

\section{ATS\_XX\_0.IFO}

\ALGORITHM{an \texttt{ATS\_XX\_0.IFO} file, a titleset number}{timestamps for each track in each title in the titleset, a list of sector pointers}
\SetKw{SEEK}{seek}
\SetKwData{IDENTIFIER}{identifier}
\SetKwData{TITLECOUNT}{title count}
\SetKwData{LASTADDRESS}{last byte address}
\SetKwData{TITLENUMBER}{title number}
\SetKwData{TITLEOFFSET}{title table offset}
\SetKwData{TRACKCOUNT}{track count}
\SetKwData{INDEXCOUNT}{index count}
\SetKwData{TITLELENGTH}{title PTS length}
\SetKwData{POINTERSOFFSET}{sector pointers offset}
\SetKwData{TRACKINDEX}{track index number}
\SetKwData{TRACKPTSINDEX}{track PTS index}
\SetKwData{TRACKPTSLENGTH}{track PTS length}
\SetKwData{INDEXID}{index ID}
\SetKwData{FIRSTSECTOR}{first sector}
\SetKwData{LASTSECTOR}{last sector}
$\IDENTIFIER \leftarrow$ \READ 12 bytes\;
\ASSERT $\IDENTIFIER = \texttt{"DVDAUDIO-ATS"}$\;
\SEEK to file position \texttt{0x800}\tcc*[r]{seek to the second sector in the file}
$\TITLECOUNT \leftarrow$ \READ 16 unsigned bits\;
\SKIP 16 bits\;
$\LASTADDRESS \leftarrow$ \READ 32 unsigned bits\;
\For{$i \leftarrow 0$ \emph{\KwTo}\TITLECOUNT}{
  $\text{\TITLENUMBER}_i \leftarrow$ \READ 8 unsigned bits\;
  \SKIP 24 bits\;
  $\text{\TITLEOFFSET}_i \leftarrow$ \READ 32 unsigned bits\;
}
\For(\tcc*[f]{read title information}){$i \leftarrow 0$ \emph{\KwTo}\TITLECOUNT}{
  \SEEK to file position $(\texttt{0x800} + \text{\TITLEOFFSET}_i)$\;
  \SKIP 16 bits\;
  $\text{\TRACKCOUNT}_i \leftarrow$ \READ 8 unsigned bits\;
  $\text{\INDEXCOUNT}_i \leftarrow$ \READ 8 unsigned bits\;
  $\text{\TITLELENGTH}_i \leftarrow$ \READ 32 unsigned bits\;
  \SKIP 32 bits\;
  $\text{\POINTERSOFFSET}_i \leftarrow$ \READ 16 unsigned bits\;
  \SKIP 16 bits\;
  \For(\tcc*[f]{read track information}){$j \leftarrow 0$ \emph{\KwTo}$\text{\TRACKCOUNT}_i$}{
    \SKIP 32 bits\;
    $\text{\TRACKINDEX}_{i~j} \leftarrow$ \READ 8 unsigned bits\;
    \SKIP 8 bits\;
    $\text{\TRACKPTSINDEX}_{i~j} \leftarrow$ \READ 32 unsigned bits\;
    $\text{\TRACKPTSLENGTH}_{i~j} \leftarrow$ \READ 32 unsigned bits\;
    \SKIP 48 bits\;
  }
  \SEEK to file position $(\texttt{0x800} + \text{\TITLEOFFSET}_i + \text{\POINTERSOFFSET}_i)$\;
  \For(\tcc*[f]{read index information}){$j \leftarrow 0$ \emph{\KwTo}$\text{\INDEXCOUNT}_i$}{
    $\text{\INDEXID}_{i~j} \leftarrow$ \READ 32 unsigned bits\;
    \ASSERT $\text{\INDEXID}_{i~j} = \texttt{0x01000000}$\;
    $\text{\FIRSTSECTOR}_{i~j} \leftarrow$ \READ 32 unsigned bits\;
    $\text{\LASTSECTOR}_{i~j} \leftarrow$ \READ 32 unsigned bits\;
  }
}
\Return \TITLECOUNT, \TRACKCOUNT, \INDEXCOUNT, \TITLELENGTH, \TRACKINDEX,
\TRACKPTSINDEX, \TRACKPTSLENGTH, \FIRSTSECTOR, \LASTSECTOR\;
\EALGORITHM

\clearpage

\subsubsection{ATS\_XX\_0.IFO Second Sector}
\begin{figure}[h]
\includegraphics{figures/dvda/ats_xx_0.pdf}
\end{figure}

\subsubsection{Title Table}
\begin{figure}[h]
  \includegraphics{figures/dvda/ats_title.pdf}
\end{figure}

\subsubsection{Sector Pointers Table}
\begin{figure}[h]
  \includegraphics{figures/dvda/ats_sectors.pdf}
\end{figure}

\clearpage

\section{ATS\_XX\_X.AOB}

All of a titleset's AOB files can be considered part of a
single, contiguous collection of sectors, each 2048 bytes long.
Thus, it's possible for the start and end sectors for a given track
(as indicated in the sector pointers table) to span two or more
AOB files.
Each sector contains one or more packets as part of a
``Packetized Elementary Stream''.

\begin{figure}[h]
  \includegraphics{figures/dvda/ats_xx_x.pdf}
\end{figure}
\par
\noindent
Packets with a \VAR{stream ID} of \texttt{0xBD} contain encoded audio data.
\VAR{Packet data length} is the length of all data after
the \VAR{packet data length} field to the end of the packet.
\par
\noindent
Each sector within an AOB file is prefixed by a \VAR{Pack Header},
as follows:
\begin{figure}[h]
  \includegraphics{figures/dvda/aob_pack_header.pdf}
\end{figure}
\par
\noindent
The three \VAR{Current PTS} values (3 bits, 15 bits and 15 bits, respectively)
combine to indicate the current position within the stream, in PTS ticks.
There are 90,000 PTS ticks per second.

\clearpage

\subsection{Packet Payload Extraction}

\begin{figure}[h]
  \includegraphics{figures/dvda/audio_packet.pdf}
\end{figure}
\par
\noindent
MLP frame boundaries need not align with packet boundaries.
That is, a single MLP frame may span 2 or more AOB packets.

\clearpage

\section{MLP Decoding}
{\relsize{-1}
\ALGORITHM{packet data containing 1 or more MLP frames}{1 or more PCM frames}
\SetKwData{TOTALSIZE}{total frame size}
\While{MLP frames remain}{
  \SKIP 4 bits\;
  $\TOTALSIZE \leftarrow (\text{\READ 12 unsigned bits}) \times 2$\;
  \SKIP 16 bits\;
  decode next $(\TOTALSIZE - 4)$ bytes as MLP frame\;
}
\Return PCM frames\;
\EALGORITHM
}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_stream.pdf}
\end{figure}

\begin{landscape}

\subsection{MLP Frame Decoding}
\subsubsection{Persistent Variables}
{\relsize{-1}
\begin{tabular}{rrl}
\textbf{variable group} & \textbf{variable name} &
\textbf{used for} \\
\hline
\hline
\hyperref[mlp:readmajorsync]{\textbf{major sync}}
& $\textsf{substream count}$
& \hyperref[mlp:framedecoding]{frame decoding} \\
\hline
\hyperref[mlp:readrestartheader]{$\textbf{restart header}_s$}
& $\textsf{min channel}_s$
& read decoding parameters, reading residuals, channel filtering \\
& $\textsf{max channel}_s$
& read decoding parameters, reading residuals, channel filtering \\
& $\textsf{max matrix channel}_s$
& read decoding parameters, reading matrix params, channel rematrixing \\
& $\textsf{noise shift}_s$
& channel rematrixing \\
& $\textsf{noise gen seed}_s$
& channel rematrixing \\
& $\textsf{channel assignment}_{s~c}$
& ? \\
\hline
\hyperref[mlp:readdecodingparams]{$\textbf{decoding parameters}_s$}
& $\textsf{flag}_{s~i}$
& read decoding parameters \\
& $\textsf{block size}_s$
& reading residuals, channel filtering, channel rematrixing \\
& $\textsf{matrix count}_s$
& reading matrix params, reading residuals, channel rematrixing \\
& \hyperref[mlp:readmatrixparams]{$\textbf{matrix parameters}_{s~m}$} \\
& $\textsf{output shift}_{s~c}$
& output shifting \\
& $\textsf{quant step size}_{s~c}$
& reading residuals, channel filtering, channel rematrixing \\
& \hyperref[mlp:readchannelparams]{$\textbf{channel parameters}_{s~c}$} \\
\hline
\hyperref[mlp:readmatrixparams]{$\textbf{matrix parameters}_{s~m}$}
& $\textsf{out channel}_{s~m}$
& channel rematrixing \\
& $\textsf{LSB bypass}_{s~m}$
& reading residuals \\
& $\textsf{matrix coefficient}_{s~m~c}$
& channel rematrixing \\
& $\textsf{bypassed LSB}_{s~m~i}$
& channel rematrixing \\
\hline
\hyperref[mlp:readchannelparams]{$\textbf{channel parameters}_{s~c}$}
& \hyperref[mlp:readfirfilterparams]{$\textbf{FIR filter parameters}_{s~c}$} \\
& \hyperref[mlp:readiirfilterparams]{$\textbf{IIR filter parameters}_{s~c}$} \\
& $\textsf{Huffman offset}_{s~c}$
& reading residuals \\
& $\textsf{codebook}_{s~c}$
& reading residuals \\
& $\textsf{Huffman LSBs}_{s~c}$
& reading residuals \\
\hline
\hyperref[mlp:readfilterparams]{$\textbf{filter parameters}_{s~c}$}
& $\textsf{order}_{s~c}$
& channel filtering \\
& $\textsf{shift}_{s~c}$
& channel filtering \\
& $\textsf{coefficient}_{s~c~i}$
& channel filtering \\
& $\textsf{state}_{s~c~i}$
& channel filtering \\
\end{tabular}
}


\end{landscape}

\subsubsection{Frame Decoding Process}
\label{mlp:framedecoding}
{\relsize{-1}
\ALGORITHM{MLP frame}{1 or more PCM frames}
\SetKw{OR}{or}
\SetKwData{BPS}{bits per sample}
\SetKwData{RATE}{sample rate}
\SetKwData{CHANNELCOUNT}{channel count}
\SetKwData{SUBSTREAMCOUNT}{substream count}
\SetKwData{CHECKDATA}{checkdata present}
\SetKwData{SUBSTREAMEND}{substream end}
\SetKwData{SUBSTREAM}{substream}
\SetKwData{PARITY}{parity}
\SetKwData{CRC}{CRC-8}
\SetKwData{RESTARTHEADER}{restart header}
\SetKwData{DECODINGPARAMS}{decoding parameters}
$\text{\SUBSTREAMCOUNT} \leftarrow$ read major sync\;
\ASSERT $(\SUBSTREAMCOUNT = 1)$ \OR $(\SUBSTREAMCOUNT = 2)$\;
\For{$s \leftarrow 0$ \emph{\KwTo}\SUBSTREAMCOUNT}{
  $(\text{\CHECKDATA}_s~,~\text{\SUBSTREAMEND}_s) \leftarrow$ read substream info\;
}
\eIf{$\text{\CHECKDATA}_0 = 1$}{
  decode next $(\text{\SUBSTREAMEND}_0 - 2)$ bytes as $\text{\SUBSTREAM}_0$\;
  $\text{\PARITY}_0 \leftarrow$ \READ 8 unsigned bits\;
  $\text{\CRC}_0 \leftarrow$ \READ 8 unsigned bits\;
  verify $\text{\PARITY}_0$, $\text{\CRC}_0$ of $\text{\SUBSTREAM}_0$\;
}{
  decode next $\text{\SUBSTREAMEND}_0$ bytes as $\text{\SUBSTREAM}_0$\;
}
\uIf{$\SUBSTREAMCOUNT = 1$}{
  rematrix channels using $\text{\RESTARTHEADER}_0$ and $\text{\DECODINGPARAMS}_0$\;
  apply output shifts using $\text{\DECODINGPARAMS}_0$\;
}
\ElseIf{$\SUBSTREAMCOUNT = 2$}{
  \eIf{$\text{\CHECKDATA}_1 = 1$}{
    decode next $(\text{\SUBSTREAMEND}_1 - \text{\SUBSTREAMEND}_0 - 2)$ bytes as $\text{\SUBSTREAM}_1$\;
    $\text{\PARITY}_1 \leftarrow$ \READ 8 unsigned bits\;
    $\text{\CRC}_1 \leftarrow$ \READ 8 unsigned bits\;
    verify $\text{\PARITY}_1$, $\text{\CRC}_1$ of $\text{\SUBSTREAM}_1$\;
  }{
    decode next $(\text{\SUBSTREAMEND}_1 - \text{\SUBSTREAMEND}_0)$ bytes as $\text{\SUBSTREAM}_1$\;
  }
  rematrix channels using $\text{\RESTARTHEADER}_1$ and $\text{\DECODINGPARAMS}_1$\;
  apply output shifts using $\text{\DECODINGPARAMS}_1$\;
}
\Return substream channels as PCM frames\;
\EALGORITHM
}

\clearpage

\subsubsection{Reading Major Sync}
\label{mlp:readmajorsync}
This is a collection of information about the MLP stream
which occurs occasionally at the start of MLP frames.
Its values are consistent throughout the stream for any given track.
{\relsize{-1}
\ALGORITHM{MLP frame data}{substream count}
\SetKw{AND}{and}
\SetKw{OR}{or}
\SetKw{REWIND}{rewind stream}
\SetKwData{SYNCWORDS}{sync words}
\SetKwData{STREAMTYPE}{stream type}
\SetKwData{BPS}{bits per sample}
\SetKwFunction{BPSFUNC}{bps}
\SetKwData{RATE}{sample rate}
\SetKwFunction{RATEFUNC}{rate}
\SetKwData{CHANNELCOUNT}{channel count}
\SetKwData{CHANNELASSIGNMENT}{channel assignment}
\SetKwFunction{CHANNELFUNC}{channels}
\SetKwData{ISVBR}{is VBR}
\SetKwData{PEAKBITRATE}{peak bitrate}
\SetKwData{SUBSTREAMCOUNT}{substream count}
$\SYNCWORDS \leftarrow$ \READ 24 unsigned bits\;
$\STREAMTYPE \leftarrow$ \READ 8 unsigned bits\;
\eIf(\tcc*[f]{major sync found}){$(\SYNCWORDS = 16282223)$ \AND $(\STREAMTYPE = 187)$}{
  $\text{\BPS}_0 \leftarrow \BPSFUNC(\text{\READ 4 unsigned bits})$\;
  $\text{\BPS}_1 \leftarrow \BPSFUNC(\text{\READ 4 unsigned bits})$\;
  $\text{\RATE}_0 \leftarrow \RATEFUNC(\text{\READ 4 unsigned bits})$\;
  $\text{\RATE}_1 \leftarrow \RATEFUNC(\text{\READ 4 unsigned bits})$\;
  \SKIP 11 bits\;
  $(\text{\CHANNELCOUNT}~,~\text{\CHANNELASSIGNMENT}) \leftarrow \CHANNELFUNC(\text{\READ 5 unsigned bits})$\;
  \SKIP 48 bits\;
  $\text{\ISVBR} \leftarrow$ \READ 1 unsigned bit\;
  $\text{\PEAKBITRATE} \leftarrow$ \READ 15 unsigned bits\;
  $\text{\SUBSTREAMCOUNT} \leftarrow$ \READ 4 unsigned bits\;
  \ASSERT $(\text{\SUBSTREAMCOUNT} = 1)$ \OR $(\text{\SUBSTREAMCOUNT} = 2)$\;
  \SKIP 92 bits\;
  \Return $\text{\SUBSTREAMCOUNT}$\;
}(\tcc*[f]{major sync not found}){
  \REWIND 32 bits\;
  \Return substream count from previous major sync\;
}
\EALGORITHM
}
\begin{small}
  \begin{tabular}{|c|r|r|r|l|}
    \hline
    value & \texttt{bps} & \texttt{rate} & channels & channel assignment \\
    \hline
    \texttt{00000} & 16 & 48000 & 1 & front center \\
    \texttt{00001} & 20 & 96000 & 2 & front left, front right\\
    \texttt{00010} & 24 & 192000 & 3 & front left, front right, back center \\
    \texttt{00011} & & & 4 & front left, front right, back left, back right\\
    \texttt{00100} & & & 3 & front left, front right, LFE \\
    \texttt{00101} & & & 4 & front left, front right, LFE, back center \\
    \texttt{00110} & & & 5 & front left, front right, LFE, back left, back right \\
    \texttt{00111} & & & 3 & front left, front right, front center \\
    \texttt{01000} & & 44100 & 4 & front left, front right, front center, back center \\
    \texttt{01001} & & 88200 & 5 & front left, front right, front center, back left, back right \\
    \texttt{01010} & & 176400 & 4 & front left, front right, front center, LFE\\
    \texttt{01011} & & & 5 & front left, front right, front center, LFE, back center \\
    \texttt{01100} & & & 6 & front left, front right, front center, LFE back left, back right \\
    \texttt{01101} & & & 4 & front left, front right, front center, back center \\
    \texttt{01110} & & & 5 & front left, front right, front center, back left, back right \\
    \texttt{01111} & & & 4 & front left, front right, front center, LFE \\
    \texttt{10000} & & & 5 & front left, front right, front center, LFE, back center \\
    \texttt{10001} & & & 6 & front left, front right, front center, LFE, back left, back right \\
    \texttt{10010} & & & 5 & front left, front right, back left, back right, LFE \\
    \texttt{10011} & & & 5 & front left, front right, back left, back right, front center \\
    \texttt{10100} & & & 6 & front left, front right, back left, back right, front center, LFE \\
    \hline
  \end{tabular}
\end{small}

\clearpage

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_major_sync.pdf}
\end{figure}
\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_major_sync_parse.pdf}
\end{figure}
{\relsize{-1}
\begin{tabular}{rl}
  $\text{group}_0$ bits-per-sample & 24 \\
  $\text{group}_1$ bits-per-sample & 24 \\
  $\text{group}_0$ sample rate & 96000 Hz \\
  $\text{group}_1$ sample rate & 96000 Hz \\
  channel count & 5 \\
  channel assignment & front left, front right, LFE, back left, back right \\
  is VBR & yes \\
  peak bitrate & 1600 \\
  substream count & 2 \\
\end{tabular}
}

\clearpage

\subsubsection{Substream Info}
{\relsize{-1}
\ALGORITHM{MLP frame data}{checkdata present, substream end}
\SetKwData{EXTRAWORD}{extra word present}
\SetKwData{NONRESTART}{nonrestart substream}
\SetKwData{CHECKDATA}{checkdata present}
\SetKwData{SUBSTREAMEND}{substream end}
$\text{\EXTRAWORD} \leftarrow$ \READ 1 unsigned bit\;
\ASSERT $\text{\EXTRAWORD} = 0$\;
$\text{\NONRESTART} \leftarrow$ \READ 1 unsigned bit\;
$\text{\CHECKDATA} \leftarrow$ \READ 1 unsigned bit\;
\SKIP 1 bit\;
$\text{\SUBSTREAMEND} \leftarrow (\text{\READ 12 unsigned bits}) \times 2$\;
\Return $(\text{\CHECKDATA}~,~\text{\SUBSTREAMEND})$\;
\EALGORITHM
}
\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_substream_info.pdf}
\end{figure}
\par
\noindent
For example, given a frame with 2 substreams
and 2 substream info fields:
\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_substream_info_parse.pdf}
\end{figure}
\begin{table}[h]
\begin{tabular}{rrr}
& $\text{substream}_0$ & $\text{substream}_1$ \\
\hline
extra word present & 0 & 0 \\
nonrestart substream & 0 & 0 \\
checkdata present & 1 & 1 \\
pad & 1 & 0 \\
substream end & $72 \times 2 = 148$ & $159 \times 2 = 318$ \\
\end{tabular}
\end{table}
\par
\noindent
$\text{Substream Data}_0$ contains
the next 148 bytes following the $\text{Substream Info}_1$ field,
and $\text{Substream Data}_1$ contains 170 bytes
following $\text{Substream Data}_0$.
In addition, \VAR{checkdata present} values of 1
means both substreams will be followed by 8 bit parity and CRC-8 values.

\clearpage

\subsection{Decoding Substream}
{\relsize{-1}
\ALGORITHM{1 or more blocks of MLP data}{1 or more channels of PCM data from multiple blocks}
\SetKwData{MINCHANNEL}{min channel}
\SetKwData{MAXCHANNEL}{max channel}
\SetKwData{BLOCK}{block}
\SetKwData{OUTPUT}{output}
\SetKwData{LAST}{last block}
$\text{\OUTPUT}_s \leftarrow$ decode block to 1 or more channels of PCM data\;
$\text{\LAST} \leftarrow$ \READ 1 unsigned bit\;
\While{$\text{\LAST} = 0$}{
  $\text{\BLOCK}_s \leftarrow$ decode block to 1 or more channels of PCM data\;
  $\text{\OUTPUT}_{s} \leftarrow \text{\BLOCK}_{s}$ appended to $\text{\OUTPUT}_{s}$ on a channel-by-channel basis\;
  $\text{\LAST} \leftarrow$ \READ 1 unsigned bit\;
}
\BlankLine
\Return $\text{\OUTPUT}_s$\;
\EALGORITHM
}

\subsection{Decoding Block}
{\relsize{-1}
\ALGORITHM{MLP block data}{1 or more channels of PCM data}
\SetKwData{HEADERPRESENT}{restart header present}
\SetKwData{RESTARTHEADER}{restart header}
\SetKwData{DECODINGPARAMS}{decoding parameters}
\SetKwData{FILTERPARAMS}{filter parameters}
\SetKwData{MINCHANNEL}{min channel}
\SetKwData{MAXCHANNEL}{max channel}
\SetKwData{BYPASSEDLSB}{bypassed LSB}
\SetKwData{RESIDUAL}{residual}
\SetKwData{FILTERED}{filtered}
\eIf(\tcc*[f]{decoding parameters present}){$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $\text{\HEADERPRESENT} \leftarrow$ \READ 1 unsigned bit\;
  \eIf{$\text{\HEADERPRESENT} = 1$}{
    $\text{\RESTARTHEADER}_s \leftarrow$ read restart header\;
  }{
    $\text{\RESTARTHEADER}_s \leftarrow$ from previous block's restart header in substream\;
  }
  $\text{\DECODINGPARAMS}_s \leftarrow$ read decoding parameters with $\text{\HEADERPRESENT}$\;
}{
  $\text{\RESTARTHEADER}_s \leftarrow$ from previous block's restart header in substream\;
  $\text{\DECODINGPARAMS}_s \leftarrow$ from previous block's decoding parameters in substream\;
}
\BlankLine
$(\text{\BYPASSEDLSB}_{s}~,~\text{\RESIDUAL}_s) \leftarrow$ read residual data based on $\text{\DECODINGPARAMS}_s$\;
\BlankLine
\For{$c \leftarrow \text{\MINCHANNEL}_s$ \emph{\KwTo}$\text{\MAXCHANNEL}_s$}{
  $\text{\FILTERED}_{s~c} \leftarrow$ filter $\text{\RESIDUAL}_s$ using $\text{\FILTERPARAMS}_{s~c}$\;
}
\BlankLine
\Return $\text{\FILTERED}_{s}$\;
\EALGORITHM
}

\clearpage

\subsection{Reading Restart Header}
\label{mlp:readrestartheader}
{\relsize{-1}
\ALGORITHM{MLP substream data}{restart header parameters}
\SetKwData{HEADERSYNC}{header sync}
\SetKwData{NOISETYPE}{noise type}
\SetKwData{TIMESTAMP}{output timestamp}
\SetKwData{MINCHANNEL}{min channel}
\SetKwData{MAXCHANNEL}{max channel}
\SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
\SetKwData{NOISESHIFT}{noise shift}
\SetKwData{NOISEGENSEED}{noise gen seed}
\SetKwData{CHECKDATAPRESENT}{check data present}
\SetKwData{LOSSLESSCHECK}{lossless check}
\SetKwData{CHANNELASSIGNMENT}{channel assignment}
\SetKwData{CHECKSUM}{checksum}
\SetKwData{RESTARTHEADER}{restart header}
$\text{\HEADERSYNC} \leftarrow$ \READ 13 unsigned bits\;
\ASSERT $\text{\HEADERSYNC} = \texttt{0x18F5}$\;
$\text{\NOISETYPE} \leftarrow$ \READ 1 unsigned bit\;
\ASSERT $\text{\NOISETYPE} = 0$\;
$\text{\TIMESTAMP} \leftarrow$ \READ 16 unsigned bits\;
$\text{\MINCHANNEL} \leftarrow$ \READ 4 unsigned bits\;
$\text{\MAXCHANNEL} \leftarrow$ \READ 4 unsigned bits\;
\ASSERT $\text{\MAXCHANNEL} \geq \text{\MINCHANNEL}$\;
$\text{\MAXMATRIXCHANNEL} \leftarrow$ \READ 4 unsigned bits\;
\ASSERT $\text{\MAXMATRIXCHANNEL} \geq \text{\MAXCHANNEL}$\;
$\text{\NOISESHIFT} \leftarrow$ \READ 4 unsigned bits\;
$\text{\NOISEGENSEED} \leftarrow$ \READ 23 unsigned bits\;
\SKIP 19 bits\;
$\text{\CHECKDATAPRESENT} \leftarrow$ \READ 1 unsigned bit\;
$\text{\LOSSLESSCHECK} \leftarrow$ \READ 8 unsigned bits\;
\SKIP 16 bits\;
\For{$c \leftarrow 0$ \emph{\KwTo}$(\text{\MAXMATRIXCHANNEL} + 1)$}{
  $\text{\CHANNELASSIGNMENT}_{c} \leftarrow$ \READ 6 unsigned bits\;
  \ASSERT $\text{\CHANNELASSIGNMENT}_{c} \leq \text{\MAXMATRIXCHANNEL}$\;
}
$\text{\CHECKSUM} \leftarrow$ \READ 8 unsigned bits\;
\Return
$\RESTARTHEADER\left\lbrace\begin{tabular}{l}
  \MINCHANNEL \\
  \MAXCHANNEL \\
  \MAXMATRIXCHANNEL \\
  \NOISESHIFT \\
  \NOISEGENSEED \\
  \CHANNELASSIGNMENT
\end{tabular}\right.$\;
\EALGORITHM
}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_restart_header.pdf}
\end{figure}

\clearpage

\subsubsection{Reading Restart Header Example}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_restart_header_parse1.pdf}
\end{figure}
\begin{table}[h]
{\relsize{-1}
  \begin{tabular}{rl}
    header sync & \texttt{0x18F5} \\
    noise type & 0 \\
    output timestamp & 0 \\
    min channel & 0 \\
    max channel & 1 \\
    max matrix channel & 1 \\
    noise shift & 0 \\
    noise gen seed & 1 \\
    check data present & 0 \\
    lossless check & 0 \\
    $\text{channel assignment}_0$ & 0 \\
    $\text{channel assignment}_1$ & 1 \\
    checksum & \texttt{0x11} \\
  \end{tabular}
}
\end{table}

\clearpage

\subsection{Decoding Parameters}

%%FIXME - offer breakdown of what parameters are for

Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan nisl.

\clearpage

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_decoding_params.pdf}
\end{figure}

\clearpage

\subsection{Reading Decoding Parameters}
\label{mlp:readdecodingparams}
{\relsize{-1}
\ALGORITHM{MLP substream data, restart header present flag, restart header parameters}{decoding parameters}
\SetKw{OR}{or}
\SetKw{AND}{and}
\SetKwData{HEADERPRESENT}{restart header present}
\SetKwData{MINCHANNEL}{min channel}
\SetKwData{MAXCHANNEL}{max channel}
\SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
\SetKwData{PARAMSPRESENT}{parameters present}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{MATRIXPARAMS}{matrix parameters}
\SetKwData{MATRIXCOUNT}{matrix count}
\SetKwData{OUTPUTSHIFT}{output shift}
\SetKwData{QUANTSTEP}{quant step size}
\SetKwData{FLAG}{flag}
\uIf(\tcc*[f]{parameter presence flags}){$\text{\HEADERPRESENT}_s = 1$}{
  \uIf{$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
    \For{$f \leftarrow 0$ \emph{\KwTo}8}{
      $\text{\FLAG}_{s~f} \leftarrow$ \READ 1 unsigned bit\;
    }
  }
  \lElse{
    $\text{\FLAG}_s \leftarrow \texttt{[1, 1, 1, 1, 1, 1, 1, 1]}$\;
  }
}
\uElseIf{$(\text{\FLAG}_{s~0} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  \For{$f \leftarrow 0$ \emph{\KwTo}8}{
    $\text{\FLAG}_{s~f} \leftarrow$ \READ 1 unsigned bit\;
  }
}
\Else{
  $\text{\FLAG}_s \leftarrow$ from previous block in substream\;
}
\uIf(\tcc*[f]{block size}){$(\text{\FLAG}_{s~7} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $\text{\BLOCKSIZE}_s \leftarrow$ \READ 9 unsigned bits\;
  \ASSERT $\text{\BLOCKSIZE}_s \geq 8$\;
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  $\text{\BLOCKSIZE}_s \leftarrow 8$\;
}
\Else{
  $\text{\BLOCKSIZE}_s \leftarrow$ from previous block in substream\;
}
\uIf(\tcc*[f]{matrix parameters}){$(\text{\FLAG}_{s~6} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $\text{\MATRIXCOUNT}_{s} \leftarrow$ \READ 4 unsigned bits\;
  \For{$m \leftarrow 0$ \emph{\KwTo}$\text{\MATRIXCOUNT}_{s}$}{
    $\text{\MATRIXPARAMS}_{s~c} \leftarrow$ read matrix parameters\;
  }
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  $\text{\MATRIXCOUNT}_{s} \leftarrow 0$\;
}
\Else{
  $\text{\MATRIXCOUNT}_{s} \leftarrow$ from previous block in substream\;
  $\text{\MATRIXPARAMS}_{s} \leftarrow$ from previous block in substream\;
}
\uIf(\tcc*[f]{output shifts}){$(\text{\FLAG}_{s~5} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  \For{$c \leftarrow 0$ \emph{\KwTo}$(\text{\MAXMATRIXCHANNEL}_s + 1)$}{
    $\text{\OUTPUTSHIFT}_{s~c} \leftarrow$ \READ 4 signed bits\;
  }
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  \For{$c \leftarrow 0$ \emph{\KwTo}$(\text{\MAXMATRIXCHANNEL}_s + 1)$}{
    $\text{\OUTPUTSHIFT}_{s~c} \leftarrow 0$\;
  }
}
\Else{
  $\text{\OUTPUTSHIFT}_{s} \leftarrow$ from previous block in substream\;
}
\uIf(\tcc*[f]{quant step sizes}){$(\text{\FLAG}_{s~4} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  \For{$c \leftarrow \text{\MINCHANNEL}_s$ \emph{\KwTo}$(\text{\MAXCHANNEL}_s + 1)$}{
    $\text{\QUANTSTEP}_{s~c} \leftarrow$ \READ 4 unsigned bits\;
  }
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  \For{$c \leftarrow \text{\MINCHANNEL}_s$ \emph{\KwTo}$(\text{\MAXCHANNEL}_s + 1)$}{
    $\text{\QUANTSTEP}_{s~c} \leftarrow 0$\;
  }
}
\Else{
  $\text{\QUANTSTEP}_s \leftarrow$ from previous block in substream\;
}
\EALGORITHM
}

\clearpage

\label{mlp:readchannelparams}
{\relsize{-1}
  \begin{algorithm}[H]
    \DontPrintSemicolon
    \SetKw{AND}{and}
    \SetKw{READ}{read}
    \SetKw{ASSERT}{assert}
    \SetKwData{BLOCKSIZE}{block size}
    \SetKwData{HEADERPRESENT}{restart header present}
    \SetKwData{MINCHANNEL}{min channel}
    \SetKwData{MAXCHANNEL}{max channel}
    \SetKwData{MATRIXCOUNT}{matrix count}
    \SetKwData{MATRIX}{matrix parameters}
    \SetKwData{MATRIXOUTCH}{matrix out channel}
    \SetKwData{LSBBYPASS}{LSB bypass}
    \SetKwData{MATRIXCOEFF}{matrix coeff}
    \SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
    \SetKwData{OUTPUTSHIFT}{output shift}
    \SetKwData{QUANTSTEP}{quant step size}
    \SetKwData{CHANNELPARAMS}{channel parameters}
    \SetKwData{FLAG}{flag}
    \SetKwData{FIRPARAMS}{FIR filter parameters}
    \SetKwData{FIRORDER}{FIR order}
    \SetKwData{FIRSHIFT}{FIR shift}
    \SetKwData{FIRCOEFF}{FIR coeff}
    \SetKwData{FIRSTATE}{FIR state}
    \SetKwData{IIRPARAMS}{IIR filter parameters}
    \SetKwData{IIRORDER}{IIR order}
    \SetKwData{IIRSHIFT}{IIR shift}
    \SetKwData{IIRCOEFF}{IIR coeff}
    \SetKwData{IIRSTATE}{IIR state}
    \SetKwData{CODEBOOK}{codebook}
    \SetKwData{HUFFMANOFFSET}{Huffman offset}
    \SetKwData{HUFFMANLSBS}{Huffman LSBs}
    \SetKwData{DECODINGPARAMETERS}{decoding parameters}
    \SetKwFunction{LEN}{len}
    \For(\tcc*[f]{channel parameters}){$c \leftarrow \text{\MINCHANNEL}_s$ \emph{\KwTo}$(\text{\MAXCHANNEL}_s + 1)$}{
      \uIf{$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
        $\text{\CHANNELPARAMS}_{s~c} \leftarrow $ read channel parameters\;
      }
      \uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
        $\text{\CHANNELPARAMS}_{s~c} \leftarrow \left\lbrace\begin{tabular}{ll}
        $\text{\FIRPARAMS}_{s~c} $ & $ \leftarrow \left\lbrace\begin{tabular}{ll}
        $\text{\FIRORDER}_{s~c}$ & $\leftarrow 0$ \\
        $\text{\FIRSHIFT}_{s~c}$ & $\leftarrow 0$ \\
        $\text{\FIRCOEFF}_{s~c}$ & $\leftarrow \texttt{[]}$ \\
\end{tabular}\right.$ \\
        $\text{\IIRPARAMS}_{s~c} $ & $ \leftarrow \left\lbrace\begin{tabular}{ll}
        $\text{\IIRORDER}_{s~c}$ & $\leftarrow 0$ \\
        $\text{\IIRSHIFT}_{s~c}$ & $\leftarrow 0$ \\
        $\text{\IIRCOEFF}_{s~c}$ & $\leftarrow \texttt{[]}$ \\
        $\text{\IIRSTATE}_{s~c}$ & $\leftarrow \texttt{[]}$ \\
\end{tabular}\right.$ \\
        $\text{\HUFFMANOFFSET}_{s~c} $ & $ \leftarrow 0$ \\
        $\text{\CODEBOOK}_{s~c} $ & $ \leftarrow 0$ \\
        $\text{\HUFFMANLSBS}_{s~c} $ & $ \leftarrow 23$ \\
\end{tabular}\right.$\;
      }
      \Else{
        $\text{\CHANNELPARAMS}_{s~c} \leftarrow $ from previous block's corresponding channel in substream\;
      }
    }
    \Return $\text{\DECODINGPARAMETERS}_s\left\lbrace\begin{tabular}{l}
    $\text{\FLAG}_s$ \\
    $\text{\BLOCKSIZE}_s$ \\
    $\text{\MATRIXCOUNT}_s$ \\
    $\text{\MATRIX}_s$ \\
    $\text{\OUTPUTSHIFT}_s$ \\
    $\text{\QUANTSTEP}_s$ \\
    $\text{\CHANNELPARAMS}_s$ \\
    \end{tabular}\right.$\;
  \end{algorithm}
}

\clearpage

\subsubsection{Reading Matrix Parameters}
\label{mlp:readmatrixparams}
{\relsize{-1}
  \ALGORITHM{MLP substream data, max matrix channel}{matrix parameters}
  \SetKwData{MATRIXPARAMETERS}{matrix parameters}
  \SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
  \SetKwData{MATRIXOUTCH}{out channel}
  \SetKwData{FRACTIONALBITS}{fractional bits}
  \SetKwData{LSBBYPASS}{LSB bypass}
  \SetKwData{BYPASSEDLSB}{bypassed LSB}
  \SetKwData{MATRIXCOEFF}{matrix coefficient}
  $\text{\MATRIXOUTCH}_{s~m} \leftarrow$ \READ 4 unsigned bits\;
  \ASSERT $\text{\MATRIXOUTCH}_{s~m} \leq \text{\MAXMATRIXCHANNEL}_s$\;
  $\text{\FRACTIONALBITS} \leftarrow$ \READ 4 unsigned bits\;
  \ASSERT $\text{\FRACTIONALBITS} \leq 14$\;
  $\text{\LSBBYPASS}_{s~m} \leftarrow$ \READ 1 unsigned bit\;
  \For{$c \leftarrow 0$ \emph{\KwTo}$(\text{\MAXMATRIXCHANNEL}_s + 3)$}{
    \eIf{$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
      $v_{c} \leftarrow $ \READ $(\text{\FRACTIONALBITS} + 2)$ signed bits\;
      $\text{\MATRIXCOEFF}_{s~m~c} \leftarrow v_{c} \times 2 ^ {14 - \text{\FRACTIONALBITS}}$\;
    }{
      $\text{\MATRIXCOEFF}_{s~m~c} \leftarrow 0$\;
    }
  }
  $\text{\BYPASSEDLSB}_{s~m} \leftarrow \texttt{[]}$\tcc*[r]{populated by residual block}
  \BlankLine
  \Return $\text{\MATRIXPARAMETERS}_{s~m}\left\lbrace\begin{tabular}{l}
  $\text{\MATRIXOUTCH}_{s~m}$ \\
  $\text{\LSBBYPASS}_{s~m}$ \\
  $\text{\MATRIXCOEFF}_{s~m}$ \\
  $\text{\BYPASSEDLSB}_{s~m}$ \\
  \end{tabular}\right.$\;
  \EALGORITHM
}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_matrix_params.pdf}
\end{figure}

\clearpage

\subsubsection{Reading Channel Parameters}
{\relsize{-1}
\ALGORITHM{MLP substream data, restart header present, decoding parameter flags}{channel parameters}
\SetKw{AND}{and}
\SetKwData{CHANNELPARAMS}{channel parameters}
\SetKwData{HEADERPRESENT}{restart header present}
\SetKwData{FLAG}{flag}
\SetKwData{FIRPARAMS}{FIR filter parameters}
\SetKwData{FIRORDER}{FIR order}
\SetKwData{FIRSHIFT}{FIR shift}
\SetKwData{FIRCOEFF}{FIR coeff}
\SetKwData{IIRPARAMS}{IIR filter parameters}
\SetKwData{IIRORDER}{IIR order}
\SetKwData{IIRSHIFT}{IIR shift}
\SetKwData{IIRCOEFF}{IIR coeff}
\SetKwData{IIRSTATE}{IIR state}
\SetKwData{CODEBOOK}{codebook}
\SetKwData{HUFFMANOFFSET}{Huffman offset}
\SetKwData{HUFFMANLSBS}{Huffman LSBs}
\uIf(\tcc*[f]{FIR filter parameters}){$(\text{\FLAG}_{s~3} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $\text{\FIRPARAMS}_{s~c} \leftarrow $ read FIR filter parameters\;
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  $\text{\FIRPARAMS}_{s~c} \leftarrow \left\lbrace\begin{tabular}{l}
  $\text{\FIRORDER}_{s~c} \leftarrow 0$ \\
  $\text{\FIRSHIFT}_{s~c} \leftarrow 0$\\
  $\text{\FIRCOEFF}_{s~c} \leftarrow \texttt{[]}$
  \end{tabular}\right.
  $\;
}
\Else{
  $\text{\FIRPARAMS}_{s~c} \leftarrow$ from previous block's corresponding channel in substream\;
}
\BlankLine
\uIf(\tcc*[f]{IIR filter paramters}){$(\text{\FLAG}_{s~2} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $\text{\IIRPARAMS}_{s~c} \leftarrow$ read IIR filter parameters\;
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  $\text{\IIRPARAMS}_{s~c} \leftarrow \left\lbrace\begin{tabular}{l}
  $\text{\IIRORDER}_{s~c} \leftarrow 0$ \\
  $\text{\IIRSHIFT}_{s~c} \leftarrow 0$\\
  $\text{\IIRCOEFF}_{s~c} \leftarrow \texttt{[]}$ \\
  $\text{\IIRSTATE}_{s~c} \leftarrow \texttt{[]}$
  \end{tabular}\right.
  $\;
}
\Else{
  $\text{\IIRPARAMS}_{s~c} \leftarrow$ from previous block's corresponding channel in substream\;
}
\BlankLine
\uIf(\tcc*[f]{Huffman offset}){$(\text{\FLAG}_{s~1} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $\text{\HUFFMANOFFSET}_{s~c} \leftarrow$ \READ 15 signed bits\;
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  $\text{\HUFFMANOFFSET}_{s~c} \leftarrow 0$\;
}
\Else{
  $\text{\HUFFMANOFFSET}_{s~c} \leftarrow$ from previous block's corresponding channel in substream\;
}
$\text{\CODEBOOK}_{s~c} \leftarrow$ \READ 2 unsigned bits\;
$\text{\HUFFMANLSBS}_{s~c} \leftarrow$ \READ 5 unsigned bits\;
\ASSERT $\text{\HUFFMANLSBS}_{s~c} \leq 24$\;
\Return $\text{\CHANNELPARAMS}_{s~m}\left\lbrace\begin{tabular}{l}
$\text{\FIRPARAMS}_{s~m}$ \\
$\text{\IIRPARAMS}_{s~m}$ \\
$\text{\HUFFMANOFFSET}_{s~m}$ \\
$\text{\CODEBOOK}_{s~m}$ \\
$\text{\HUFFMANLSBS}_{s~m}$ \\
\end{tabular}\right.$\;
\EALGORITHM
}

\clearpage

\subsubsection{Reading FIR Filter Parameters}
\label{mlp:readfirfilterparams}
{\relsize{-1}
  \ALGORITHM{MLP substream data}{FIR filter parameters}
  \SetKwData{ORDER}{order}
  \SetKwData{SHIFT}{shift}
  \SetKwData{COEFFBITS}{coeff bits}
  \SetKwData{COEFFSHIFT}{coeff shift}
  \SetKwData{COEFF}{coefficient}
  \SetKwData{STATEBITS}{state bits}
  \SetKwData{STATESHIFT}{state shift}
  \SetKwData{FIRPARAMS}{FIR filter parameters}
  $\text{\ORDER}_{s~c} \leftarrow$ \READ 4 unsigned bits\;
  \ASSERT $\text{\ORDER}_{s~c} \leq 8$\;
  \eIf{$\text{\ORDER}_{s~c} > 0$}{
    $\text{\SHIFT}_{s~c} \leftarrow$ \READ 4 unsigned bits\;
    $\text{\COEFFBITS} \leftarrow$ \READ 5 unsigned bits\;
    \ASSERT $1 < \text{\COEFFBITS} < 16$\;
    $\text{\COEFFSHIFT} \leftarrow$ \READ 3 unsigned bits\;
    \ASSERT $(\text{\COEFFBITS} + \text{\COEFFSHIFT}) \leq 16$\;
    \For{$i \leftarrow 0$ \emph{\KwTo}$\text{\ORDER}_{s~c}$}{
      $v_{i} \leftarrow$ \READ $(\text{\COEFFBITS})$ signed bits\;
      $\text{\COEFF}_{s~c~i} \leftarrow v_{i} \times 2 ^ {\text{\COEFFSHIFT}}$\;
    }
    \ASSERT $(\READ~\textnormal{1 unsigned bit}) = 0$\;
  }{
    $\text{\SHIFT}_{s~c} \leftarrow 0$\;
    $\text{\COEFF}_{s~c} \leftarrow \texttt{[]}$\;
  }
  \Return
  $\text{\FIRPARAMS}_{s~c}\left\lbrace\begin{tabular}{l}
  $\text{\ORDER}_{s~c}$ \\
  $\text{\SHIFT}_{s~c}$ \\
  $\text{\COEFF}_{s~c}$
  \end{tabular}\right.$\;
  \EALGORITHM
}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_fir_filter_params.pdf}
\end{figure}

\clearpage

\subsubsection{Reading IIR Filter Parameters}
\label{mlp:readiirfilterparams}
{\relsize{-1}
  \ALGORITHM{MLP substream data}{IIR filter parameters}
  \SetKw{KwDownTo}{downto}
  \SetKwData{ORDER}{order}
  \SetKwData{SHIFT}{shift}
  \SetKwData{COEFFBITS}{coeff bits}
  \SetKwData{COEFFSHIFT}{coeff shift}
  \SetKwData{COEFF}{coefficient}
  \SetKwData{STATEBITS}{state bits}
  \SetKwData{STATESHIFT}{state shift}
  \SetKwData{STATE}{state}
  \SetKwData{IIRPARAMS}{IIR filter params}
  $\text{\ORDER}_{s~c} \leftarrow$ \READ 4 unsigned bits\;
  \ASSERT $\text{\ORDER}_{s~c} \leq 8$\;
  \eIf{$\text{\ORDER}_{s~c} > 0$}{
    $\text{\SHIFT}_{s~c} \leftarrow$ \READ 4 unsigned bits\;
    $\text{\COEFFBITS} \leftarrow$ \READ 5 unsigned bits\;
    \ASSERT $1 < \text{\COEFFBITS} < 16$\;
    $\text{\COEFFSHIFT} \leftarrow$ \READ 3 unsigned bits\;
    \ASSERT $(\text{\COEFFBITS} + \text{\COEFFSHIFT}) \leq 16$\;
    \For{$i \leftarrow 0$ \emph{\KwTo}$\text{\ORDER}_{s~c}$}{
      $v_{i} \leftarrow$ \READ $(\text{\COEFFBITS})$ signed bits\;
      $\text{\COEFF}_{s~c~i} \leftarrow v_{i} \times 2 ^ {\text{\COEFFSHIFT}}$\;
    }
    \eIf{$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
      $\text{\STATEBITS} \leftarrow$ \READ 4 unsigned bits\;
      $\text{\STATESHIFT} \leftarrow$ \READ 4 unsigned bits\;
      \For(\tcc*[f]{read state values in reverse order}){$i \leftarrow \text{\ORDER}_{s~c}$ \emph{\KwDownTo}0}{
        $s_{i} \leftarrow$ \READ $(\text{\STATEBITS})$ signed bits\;
        $\text{\STATE}_{s~c~i} \leftarrow s_{i} \times 2 ^ {\text{\STATESHIFT}}$\;
      }
    }{
      $\text{\STATE}_{s~c} \leftarrow \texttt{[]}$\;
    }
  }{
    $\text{\SHIFT}_{s~c} \leftarrow 0$\;
    $\text{\COEFF}_{s~c} \leftarrow \texttt{[]}$\;
    $\text{\STATE}_{s~c} \leftarrow \texttt{[]}$\;
  }
  \Return
  $\text{\IIRPARAMS}_{s~c}\left\lbrace\begin{tabular}{l}
  $\text{\ORDER}_{s~c}$ \\
  $\text{\SHIFT}_{s~c}$ \\
  $\text{\COEFF}_{s~c}$ \\
  $\text{\STATE}_{s~c}$
  \end{tabular}\right.$\;
  \EALGORITHM
}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_iir_filter_params.pdf}
\end{figure}

\clearpage

\subsubsection{Reading Decoding Parameters Example}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_decoding_params_parse.pdf}
\end{figure}

\clearpage

For example, given that a restart header is present with the values:
\begin{table}[h]
  {\relsize{-1}
    \begin{tabular}{rl}
      min channel & 0 \\
      max channel & 1 \\
      max matrix channel & 1 \\
    \end{tabular}
  }
\end{table}
\par
\noindent
our decoding parameters for a given substream are:
\begin{table}[h]
{\relsize{-1}
  \begin{tabular}{rlrl}
    \hline
    flags present & 0 \\
    flags & \texttt{[1, 1, 1, 1, 1, 1, 1, 1]} \\
    \hline
    block size present & 0 \\
    block size & 8 PCM frames \\
    \hline
    matrix parameters present & 1 \\
    matrix count & 2 \\
    $\text{matrix out channel}_0$ & 1 &
    $\text{matrix out channel}_1$ & 0 \\
    $\text{fractional bits}_0$ & 13 &
    $\text{fractional bits}_1$ & 13 \\
    $\text{LSB bypass}_0$ & 0 &
    $\text{LSB bypass}_1$ & 0 \\
    $\text{matrix coeff. present}_{0~0}$ & 0 &
    $\text{matrix coeff. present}_{1~0}$ & 1 \\
    $\text{matrix coeff.}_{0~0}$ & 0 &
    $\text{matrix coeff.}_{1~0}$ & -2053 \\
    $\text{matrix coeff. present}_{0~1}$ & 1 &
    $\text{matrix coeff. present}_{1~1}$ & 0 \\
    $\text{matrix coeff.}_{0~1}$ & -2053 &
    $\text{matrix coeff.}_{1~1}$ & 0 \\
    $\text{matrix coeff. present}_{0~2}$ & 1 &
    $\text{matrix coeff. present}_{1~2}$ & 1 \\
    $\text{matrix coeff.}_{0~2}$ & -32 &
    $\text{matrix coeff.}_{1~2}$ & 32 \\
    $\text{matrix coeff. present}_{0~3}$ & 1 &
    $\text{matrix coeff. present}_{1~3}$ & 1 \\
    $\text{matrix coeff.}_{0~3}$ & 32 &
    $\text{matrix coeff.}_{1~3}$ & 32 \\
    \hline
    output shift present & 1 \\
    $\text{output shift}_0$ & 1 &
    $\text{output shift}_1$ & 1 \\
    \hline
    quantum step size present & 0 \\
    \hline
    $\text{channel parameters present}_0$ & 1 &
    $\text{channel parameters present}_1$ & 1 \\
    $\text{FIR parameters present}_0$ & 0 &
    $\text{FIR parameters present}_1$ & 0 \\
    $\text{IIR parameters present}_0$ & 0 &
    $\text{IIR parameters present}_1$ & 0 \\
    $\text{Huffman offset present}_0$ & 0 &
    $\text{Huffman offset present}_1$ & 0 \\
    $\text{codebook}_0$ & 0 &
    $\text{codebook}_1$ & 0 \\
    $\text{Huffman LSB}_0$ & 1 &
    $\text{Huffman LSB}_1$ & 1 \\
    \hline
  \end{tabular}
}
\end{table}

\clearpage

\subsection{Reading Residuals Data}
{\relsize{-1}
\ALGORITHM{block size, min channel, max channel, matrix count; LSB bypass for each matrix;\newline quant step size, Huffman LSB, codebook, Huffman offset for each channel}{bypassed LSBs for each matrix, residuals for each channel}
\SetKwData{MINCHANNEL}{min channel}
\SetKwData{MAXCHANNEL}{max channel}
\SetKwData{CODEBOOK}{codebook}
\SetKwData{LSBBITS}{LSB bits}
\SetKwData{HUFFMANLSBS}{Huffman LSBs}
\SetKwData{QUANTSTEP}{quant step size}
\SetKwData{SIGNSHIFT}{sign shift}
\SetKwData{HUFFMANOFFSET}{Huffman offset}
\SetKwData{SIGNEDHUFFMANOFFSET}{signed Huffman offset}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{MATRIXCOUNT}{matrix count}
\SetKwData{LSBBYPASS}{LSB bypass}
\SetKwData{BYPASSEDLSB}{bypassed LSB}
\SetKwData{MSB}{MSB}
\SetKwData{LSB}{LSB}
\SetKwData{RESIDUAL}{residual}
\For(\tcc*[f]{calculate signed Huffman offset}){$c \leftarrow \text{\MINCHANNEL}_s$ \emph{\KwTo}$(\text{\MAXCHANNEL}_s + 1)$}{
  $\text{\LSBBITS}_{s~c} \leftarrow \text{\HUFFMANLSBS}_{s~c} - \text{\QUANTSTEP}_{s~c}$\;
  \eIf{$\text{\CODEBOOK}_{s~c} > 0$}{
    $\text{\SIGNSHIFT}_{s~c} \leftarrow \text{\LSBBITS}_{s~c} + 2 - \text{\CODEBOOK}_{s~c}$\;
    \eIf{$\text{\SIGNSHIFT}_{s~c} \geq 0$}{
      $\text{\SIGNEDHUFFMANOFFSET}_{s~c} \leftarrow \text{\HUFFMANOFFSET}_{s~c} - 7 \times 2 ^ {\text{\LSBBITS}_{s~c}} - 2 ^ {\text{\SIGNSHIFT}_{s~c}}$\;
    }{
      $\text{\SIGNEDHUFFMANOFFSET}_{s~c} \leftarrow \text{\HUFFMANOFFSET}_{s~c} - 7 \times 2 ^ {\text{\LSBBITS}_{s~c}}$\;
    }
  }{
    $\text{\SIGNSHIFT}_{s~c} \leftarrow \text{\LSBBITS}_{s~c} - 1$\;
    \eIf{$\text{\SIGNSHIFT}_{s~c} \geq 0$}{
      $\text{\SIGNEDHUFFMANOFFSET}_{s~c} \leftarrow \text{\HUFFMANOFFSET}_{s~c} - 2 ^ {\text{\SIGNSHIFT}_{s~c}}$\;
    }{
      $\text{\SIGNEDHUFFMANOFFSET}_{s~c} \leftarrow \text{\HUFFMANOFFSET}_{s~c}$\;
    }
  }
}
\BlankLine
\For{$i \leftarrow 0$ \emph{\KwTo}$\text{\BLOCKSIZE}_s$}{
  \For(\tcc*[f]{read bypassed LSBs for each matrix}){$m \leftarrow 0$ \emph{\KwTo}$\text{\MATRIXCOUNT}_s$}{
    \eIf{$\text{\LSBBYPASS}_{s~m} = 1$}{
      $\text{\BYPASSEDLSB}_{s~m~i} \leftarrow$ \READ 1 unsigned bit\;
    }{
      $\text{\BYPASSEDLSB}_{s~m~i} \leftarrow 0$\;
    }
  }
  \For(\tcc*[f]{read residuals for each channel}){$c \leftarrow \text{\MINCHANNEL}_s$ \emph{\KwTo}$(\text{\MAXCHANNEL}_s + 1)$}{
    \uIf{$\text{\CODEBOOK}_{s~c} = 0$}{
      $\text{\MSB}_{s~c~i} \leftarrow 0$\;
    }
    \uElseIf{$1 \leq \text{\CODEBOOK}_{s~c} \leq 3$}{
      $\text{\MSB}_{s~c~i} \leftarrow$ read Huffman value from $\text{\CODEBOOK}_{s~c}$\;
    }
    \Else{$\text{\MSB}_{s~c~i} \leftarrow -1$}
    \ASSERT $\text{\MSB}_{s~c~i} \geq 0$\;
    \BlankLine
    $\text{\LSB}_{s~c~i} \leftarrow$ \READ $(\text{\LSBBITS}_{s~c})$ unsigned bits\;
    $\text{\RESIDUAL}_{s~c~i} \leftarrow ((\text{\MSB}_{s~c~i} \times 2 ^ {\text{\LSBBITS}_{s~c}}) + \text{\LSB}_{s~c~i} + \text{\SIGNEDHUFFMANOFFSET}_{s~c}) \times 2 ^ {\text{\QUANTSTEP}_{s~c}}$\;
  }
}
\BlankLine
\Return $(\text{\BYPASSEDLSB}_{s}~,~\text{\RESIDUAL}_s)$\;
\EALGORITHM
}

\clearpage

\begin{figure}[h]
  \label{mlp_codebooks}
  \includegraphics{figures/dvda/mlp_codebook1.pdf}
  \caption{Codebook 1}
  \vskip 2em
  \includegraphics{figures/dvda/mlp_codebook2.pdf}
  \caption{Codebook 2}
  \vskip 2em
  \includegraphics{figures/dvda/mlp_codebook3.pdf}
  \caption{Codebook 3}
\end{figure}

\clearpage

\subsubsection{Reading Block Data Example}
Given the channel parameters:
\begin{table}[h]
{\relsize{-1}
\begin{tabular}{rrr}
& channel 0 & channel 1 \\
\hline
$\text{Huffman offset}_c$ & 0 & 0 \\
$\text{codebook}_c$ & 1 & 2 \\
$\text{Huffman LSBs}_c$ & 2 & 2 \\
\hline
$\text{LSB bits}_c$ & 2 & 2 \\
$\text{sign shift}_c$ & $3$ & $2$ \\
$\text{signed Huffman offset}_c$ & $0 - 7 \times 2 ^ 2 - 2 ^ 3 = -36$ & $0 - 7 \times 2 ^ 2 - 2 ^ 2 = -32$ \\
\end{tabular}
}
\end{table}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_block_parse.pdf}
\end{figure}
{\relsize{-1}
  \begin{tabular}{r||rr>{$}r<{$}|rr>{$}r<{$}}
    $i$ & $\text{MSB}_{0~i}$ & $\text{LSB}_{0~i}$ & \text{residual}_{0~i} &
    $\text{MSB}_{1~i}$ & $\text{LSB}_{1~i}$ & \text{residual}_{1~i} \\
    \hline
    0 & 9 & 3 & 9 \times 2 ^ 2 + 3 - 36 = 3 &
    7 & 1 & 7 \times 2 ^ 2 + 1 - 32 = -3 \\
    1 & 11 & 2 & 11 \times 2 ^ 2 + 2 - 36 = 10 &
    7 & 2 & 7 \times 2 ^ 2 + 2 - 32 = -2 \\
    2 & 11 & 0 & 11 \times 2 ^ 2 + 0 - 36 = 8 &
    8 & 0 & 8 \times 2 ^ 2 + 0 - 32 = 0 \\
    3 & 8 & 3 & 8 \times 2 ^ 2 + 3 - 36 = -1 &
    9 & 3 & 9 \times 2 ^ 2 + 3 - 32 = 7 \\
    4 & 8 & 3 & 8 \times 2 ^ 2 + 3 - 36 = -1 &
    3 & 3 & 3 \times 2 ^ 2 + 3 - 32 = -17 \\
    5 & 11 & 0 & 11 \times 2 ^ 2 + 0 - 36 = 8 &
    4 & 1 & 4 \times 2 ^ 2 + 1 - 32 = -15 \\
    6 & 12 & 3 & 12 \times 2 ^ 2 + 3 - 36 = 15 &
    6 & 0 & 6 \times 2 ^ 2 + 0 - 32 = -8 \\
    7 & 11 & 1 & 11 \times 2 ^ 2 + 1 - 36 = 9 &
    6 & 3 & 6 \times 2 ^ 2 + 3 - 32 = -5 \\
    8 & 5 & 0 & 5 \times 2 ^ 2 + 0 - 36 = -16 &
    8 & 0 & 8 \times 2 ^ 2 + 0 - 32 = 0 \\
    9 & 7 & 0 & 7 \times 2 ^ 2 + 0 - 36 = -8 &
    8 & 3 & 8 \times 2 ^ 2 + 3 - 32 = 3 \\
  \end{tabular}
}

\clearpage

\subsection{Channel Filtering}
{\relsize{-1}
\ALGORITHM{block size, signed residual values, channel's quant step size,\newline FIR filter parameters, IIR filter parameters}{filtered residual values, new FIR state, new IIR state}
\SetKw{AND}{and}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SHIFT}{shift}
\SetKwData{FIRORDER}{FIR order}
\SetKwData{FIRSHIFT}{FIR shift}
\SetKwData{FIRCOEFF}{FIR coeff}
\SetKwData{FIRSTATE}{FIR state}
\SetKwData{IIRORDER}{IIR order}
\SetKwData{IIRSHIFT}{IIR shift}
\SetKwData{IIRCOEFF}{IIR coeff}
\SetKwData{IIRSTATE}{IIR state}
\SetKwData{RESIDUAL}{residual}
\SetKwData{SUM}{sum}
\SetKwData{SHIFTEDSUM}{shifted sum}
\SetKwData{FILTERED}{filtered}
\SetKwFunction{LEN}{len}
\SetKwFunction{MASK}{mask}
\SetKwData{QUANTSIZE}{quant step size}
\ASSERT $(\text{\FIRORDER}_{s~c} + \text{\IIRORDER}_{s~c}) \leq 8$\;
\uIf{$(\text{\FIRORDER}_{s~c} > 0)$ \AND $(\text{\IIRORDER}_{s~c} > 0)$}{
  \ASSERT $\text{\FIRSHIFT}_{s~c} = \text{\IIRSHIFT}_{s~c}$\;
  $\text{\SHIFT} \leftarrow \text{\FIRSHIFT}_{s~c}$\;
}
\uElseIf{$\text{\FIRORDER} > 0$}{
  $\text{\SHIFT} \leftarrow \text{\FIRSHIFT}_{s~c}$\;
}
\Else{
  $\text{\SHIFT} \leftarrow \text{\IIRSHIFT}_{s~c}$\;
}
\For{$i \leftarrow 0$ \emph{\KwTo}$\text{\BLOCKSIZE}_s$}{
  $\text{\SUM}_i \leftarrow 0$\;
  \For{$j \leftarrow 0$ \emph{\KwTo}$\text{\FIRORDER}_{s~c}$}{
    $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\FIRCOEFF}_{s~c~j} \times \text{\FIRSTATE}_{s~c~(\LEN(\text{\FIRSTATE}) - j - 1)}$\;
  }
  \For{$k \leftarrow 0$ \emph{\KwTo}$\text{\IIRORDER}_{s~c}$}{
    $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\IIRCOEFF}_{s~c~k} \times \text{\IIRSTATE}_{s~c~(\LEN(\text{\IIRSTATE}) - k - 1)}$\;
  }
  \BlankLine
  $\text{\SHIFTEDSUM}_i \leftarrow \lfloor\text{\SUM}_i \div 2 ^ {\SHIFT}\rfloor$\;
  \BlankLine
  $v_i \leftarrow \MASK(\text{\SHIFTEDSUM}_i + \text{\RESIDUAL}_{s~c~i}~,~\text{\QUANTSIZE}_{s~c})$\;
  \BlankLine
  $\text{\FILTERED}_{s~c~i} \leftarrow v_i$\;
  $\text{\FIRSTATE}_{s~c~\LEN(\text{\FIRSTATE})} \leftarrow v_i$\;
  $\text{\IIRSTATE}_{s~c~\LEN(\text{\IIRSTATE})} \leftarrow v_i - \text{\SHIFTEDSUM}_i$\;
}
\Return $(\text{\FILTERED}_{s~c}~,~\text{\FIRSTATE}_{s~c}~,~\text{\IIRSTATE}_{s~c})$\;
\EALGORITHM
}
\vskip .25in
\par
\noindent
where \texttt{mask} is defined as:
\begin{equation*}
\texttt{mask}(x~,~q) =\begin{cases}x & \text{ if } q = 0 \\
\lfloor x \div 2 ^ q \rfloor \times 2 ^ q & \text{ if } q > 0
\end{cases}
\end{equation*}
\par
\noindent
Since the maximum FIR order and maximum IIR order are both 8,
one needs to return only the last 8 values of FIR and IIR state.

%%FIXME - add residual filtering example

\clearpage

\subsection{Rematrixing Channels}
{\relsize{-1}
\ALGORITHM{block size, filtered residuals, noise shift, noise gen seed, matrix parameters, quant step sizes, bypassed LSBs}{rematrixed channels, updated noise gen seed}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{NOISE}{noise}
\SetKwData{NOISESHIFT}{noise shift}
\SetKwData{SHIFTED}{shifted}
\SetKwData{NOISEGENSEED}{noise gen seed}
\SetKwData{MATRIXCOUNT}{matrix count}
\SetKwData{SUM}{sum}
\SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
\SetKwData{FILTERED}{filtered}
\SetKwData{MATRIXCOEFF}{matrix coefficient}
\SetKwData{REMATRIXED}{rematrixed}
\SetKwData{MATRIXOUTCHANNEL}{matrix out channel}
\SetKwData{QUANTSTEPSIZE}{quant step size}
\SetKwData{BYPASSEDLSB}{bypassed LSB}
\SetKwFunction{MASK}{mask}
\SetKwFunction{CROP}{crop}
\For(\tcc*[f]{generate noise channels}){$i \leftarrow 0$ \emph{\KwTo}$\text{\BLOCKSIZE}_s$}{
  $\text{\SHIFTED}_i \leftarrow \lfloor\text{\NOISEGENSEED}_s \div 2 ^ 7\rfloor \bmod{2 ^ {16}}$\;
  $\text{\NOISE}_{0~i} \leftarrow \CROP(\lfloor\text{\NOISEGENSEED}_s \div 2 ^ {15}\rfloor) \times 2 ^ {\text{\NOISESHIFT}_s}$\;
  $\text{\NOISE}_{1~i} \leftarrow \CROP(\text{\SHIFTED}_i) \times 2 ^ {\text{\NOISESHIFT}_s}$\;
  $\text{\NOISEGENSEED}_s \leftarrow ((\text{\NOISEGENSEED}_s \times 2 ^ {16}) \bmod{2 ^ {32}}) \xor \text{\SHIFTED}_i \xor (\text{\SHIFTED}_i \times 2 ^ 5)$\;
}
\BlankLine
\For(\tcc*[f]{perform channel rematrixing}){$m \leftarrow 0$ \emph{\KwTo}$\text{\MATRIXCOUNT}_s$}{
  $o \leftarrow \text{\MATRIXOUTCHANNEL}_{s~m}$\;
  \For{$i \leftarrow 0$ \emph{\KwTo}$\text{\BLOCKSIZE}_s$}{
    $\text{\SUM}_i \leftarrow 0$\;
    \For{$c \leftarrow 0$ \emph{\KwTo}$\text{\MAXMATRIXCHANNEL}_s + 1$}{
      $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\FILTERED}_{s~c~i} \times \text{\MATRIXCOEFF}_{s~m~c}$\;
    }
    $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\NOISE}_{0~i} \times \text{\MATRIXCOEFF}_{s~m~(\MAXMATRIXCHANNEL + 1)}$\;
    $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\NOISE}_{1~i} \times \text{\MATRIXCOEFF}_{s~m~(\MAXMATRIXCHANNEL + 2)}$\;
    $\text{\FILTERED}_{s~o~i} \leftarrow \MASK(\lfloor\text{\SUM}_i \div 2 ^ {14}\rfloor~,~\text{\QUANTSTEPSIZE}_{s~o}) + \text{\BYPASSEDLSB}_{s~m~i}$\;
  }
}
\Return $(\text{\FILTERED}_{s}~,~\text{\NOISEGENSEED}_s)$\;
\EALGORITHM
}
\vskip .25in
\par
\noindent
where \texttt{crop} is defined as:
\begin{align*}
  \texttt{crop}(x) &=
  \begin{cases}
    x \bmod{2 ^ 8} & \text{if } \lfloor (x \bmod{2 ^ 8}) \div 2 ^ 7\rfloor = 0 \\
    (x \bmod{2 ^ 7}) - 2 ^ 7 & \text{if } \lfloor (x \bmod{2 ^ 8}) \div 2 ^ 7\rfloor \neq 0
  \end{cases}
  \intertext{and \texttt{mask} is defined as:}
  \texttt{mask}(x~,~q) &=\begin{cases}x & \text{ if } q = 0 \\
  \lfloor x \div 2 ^ q \rfloor \times 2 ^ q & \text{ if } q > 0
  \end{cases}
\end{align*}

Because each channel may be rematrixed zero or more times,
filtered channels are rematrixed in-place
and the final result is output.

%%FIXME - add rematrixing example

\clearpage

\subsection{Applying Output Shifts}

{\relsize{-1}
\ALGORITHM{1 or more channels of rematrixed sample data, output shifts}{1 or more channels of shifted sample data}
\SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
\SetKwData{REMATRIXED}{rematrixed}
\SetKwData{OUTPUTSHIFT}{output shift}
\SetKwData{SHIFTED}{shifted}
\For{$c \leftarrow 0$ \emph{\KwTo}$(\text{\MAXMATRIXCHANNEL}_s + 1)$}{
  \eIf{$\text{\OUTPUTSHIFT}_{s~c} > 0$}{
    \For{$i \leftarrow 0$ \emph{\KwTo}$\LEN(\text{\REMATRIXED}_{s~c})$}{
      $\text{\SHIFTED}_{s~c~i} \leftarrow \text{\REMATRIXED}_{s~c~i} \times 2 ^ {\text{\OUTPUTSHIFT}_{s~c}}$\;
    }
  }{
    $\text{\SHIFTED}_{s~c} \leftarrow \text{\REMATRIXED}_{s~c}$\;
  }
}
\Return $\text{\SHIFTED}_{s}$\;
\EALGORITHM
}
