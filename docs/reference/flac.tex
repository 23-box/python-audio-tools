%This work is licensed under the
%Creative Commons Attribution-Share Alike 3.0 United States License.
%To view a copy of this license, visit
%http://creativecommons.org/licenses/by-sa/3.0/us/ or send a letter to
%Creative Commons,
%171 Second Street, Suite 300,
%San Francisco, California, 94105, USA.

\chapter{Free Lossless Audio Codec}
FLAC compresses PCM audio data losslessly using predictors and a
residual.
FLACs contain checksumming to verify their integrity, contain comment tags for
metadata and are stream-able.

Except for the contents of the VORBIS\_COMMENT metadata block, everything in FLAC is big-endian.

\section{the FLAC File Stream}
\begin{figure}[h]
\includegraphics{figures/flac/stream.pdf}
\end{figure}
\par
\noindent
\VAR{Last} is 0 when there are no additional metadata blocks and 1 when
it is the final block before the the audio frames.
\VAR{Block Length} is the size of the metadata block data to follow,
not including the header.
\begin{figure}[h]
\begin{tabular}{| r | l |}
\hline
Block Type & Block \\
\hline
\texttt{0} & STREAMINFO \\
\texttt{1} & PADDING \\
\texttt{2} & APPLICATION \\
\texttt{3} & SEEKTABLE \\
\texttt{4} & VORBIS\_COMMENT \\
\texttt{5} & CUESHEET \\
\texttt{6} & PICTURE \\
\texttt{7-126} & reserved \\
\texttt{127} & invalid \\
\hline
\end{tabular}
\end{figure}

\pagebreak

\section{FLAC Metadata Blocks}

\subsection{STREAMINFO}
\begin{figure}[h]
\includegraphics{figures/flac/streaminfo.pdf}
\end{figure}

\subsection{PADDING}

PADDING is simply a block full of NULL (\texttt{0x00}) bytes.
Its purpose is to provide extra metadata space within the FLAC file.
By having a padding block, other metadata blocks can be grown or
shrunk without having to rewrite the entire FLAC file by removing or
adding space to the padding.


\subsection{APPLICATION}
\begin{figure}[h]
\includegraphics{figures/flac/application.pdf}
\end{figure}
\noindent
APPLICATION is a general-purpose metadata block used by a variety of
different programs.
Its contents are defined by the ASCII Application ID value.

\subsection{SEEKTABLE}
\begin{figure}[h]
\includegraphics{figures/flac/seektable.pdf}
\end{figure}

\pagebreak

\subsection{VORBIS\_COMMENT}
\begin{figure}[h]
\includegraphics{figures/flac/vorbiscomment.pdf}
\end{figure}
\par
\noindent
The length fields are all little-endian.
The Vendor String and Comment Strings are all UTF-8 encoded.
Keys are not case-sensitive and may occur multiple times,
indicating multiple values for the same field.
For instance, a track with multiple artists may have
more than one \texttt{ARTIST}.

\begin{multicols}{2}
{\relsize{-2}
\begin{description}
\item[ALBUM] album name
\item[ARTIST] artist name, band name, composer, author, etc.
\item[CATALOGNUMBER*] CD spine number
\item[COMPOSER*] the work's author
\item[CONDUCTOR*] performing ensemble's leader
\item[COPYRIGHT] copyright attribution
\item[DATE] recording date
\item[DESCRIPTION] a short description
\item[DISCNUMBER*] disc number for multi-volume work
\item[ENGINEER*] the recording masterer
\item[ENSEMBLE*] performing group
\item[GENRE] a short music genre label
\item[GUEST ARTIST*] collaborating artist
\item[ISRC] ISRC number for the track
\item[LICENSE] license information
\item[LOCATION] recording location
\item[OPUS*] number of the work
\item[ORGANIZATION] record label
\item[PART*] track's movement title
\item[PERFORMER] performer name, orchestra, actor, etc.
\item[PRODUCER*] person responsible for the project
\item[PRODUCTNUMBER*] UPC, EAN, or JAN code
\item[PUBLISHER*] album's publisher
\item[RELEASE DATE*] date the album was published
\item[REMIXER*] person who created the remix
\item[SOURCE ARTIST*] artist of the work being performed
\item[SOURCE MEDIUM*] CD, radio, cassette, vinyl LP, etc.
\item[SOURCE WORK*] a soundtrack's original work
\item[SPARS*] DDD, ADD, AAD, etc.
\item[SUBTITLE*] for multiple track names in a single file
\item[TITLE] track name
\item[TRACKNUMBER] track number
\item[VERSION] track version
\end{description}
}
\end{multicols}
\par
\noindent
Fields marked with * are proposed extension fields and not part of the official Vorbis comment specification.

\pagebreak

\subsection{CUESHEET}
\begin{figure}[h]
\includegraphics{figures/flac/cuesheet.pdf}
\end{figure}

\subsection{PICTURE}
\begin{figure}[h]
\includegraphics{figures/flac/picture.pdf}
\end{figure}
\begin{tabular}{|r|l|}
\hline
Picture Type & Type \\
\hline
0 & Other \\
1 & 32x32 pixels `file icon' (PNG only) \\
2 & Other file icon \\
3 & Cover (front) \\
4 & Cover (back) \\
5 & Leaflet page \\
6 & Media (e.g. label side of CD) \\
7 & Lead artist / Lead performer / Soloist \\
8 & Artist / Performer \\
9 & Conductor \\
10 & Band / Orchestra \\
11 & Composer \\
12 & Lyricist / Text writer \\
13 & Recording location \\
14 & During recording \\
15 & During performance \\
16 & Movie / Video screen capture \\
17 & A bright colored fish \\
18 & Illustration \\
19 & Band / Artist logotype \\
20 & Publisher / Studio logotype \\
\hline
\end{tabular}

\section{FLAC Decoding}

The basic process for decoding a FLAC file is as follows:
\par
\noindent
\ALGORITHM{a FLAC encoded file}{PCM samples}
\SetKwData{HEADER}{file header}
\SetKwData{PCMCOUNT}{PCM frame count}
\SetKwData{MDSUM}{MD5 sum}
$\HEADER \leftarrow$ \READ 4 bytes\;
\ASSERT $\text{\HEADER} = \texttt{"fLaC"}$\;
\hyperref[flac:read_metadata]{get \PCMCOUNT and \MDSUM from STREAMINFO metadata block}\;
skip remaining metadata blocks\;
initialize stream MD5\;
\While{$\PCMCOUNT > 0$}{
  \hyperref[flac:decode_frame]{decode FLAC frame to 1 or more PCM frames}\;
  deduct FLAC frame's block size from $\PCMCOUNT$\;
  \hyperref[flac:update_md5]{update stream MD5 sum with decoded PCM frame data}\;
  \Return decoded PCM frames\;
}
\ASSERT STREAMINFO \MDSUM = stream MD5 sum
\EALGORITHM
\begin{figure}[h]
\includegraphics{figures/flac/stream3.pdf}
\end{figure}
\par
All of the fields in the FLAC stream are big-endian.\footnote{Except
for the length fields in the VORBIS\_COMMENT metadata block.
However, this block is not needed for decoding.
}

\clearpage

\subsection{Reading Metadata Blocks}
\label{flac:read_metadata}
{\relsize{-1}
\ALGORITHM{the FLAC file stream}{STREAMINFO values used for decoding}
\SetKwData{LAST}{last}
\SetKwData{TYPE}{type}
\SetKwData{SIZE}{size}
\SetKwData{MINBLOCKSIZE}{minimum block size}
\SetKwData{MAXBLOCKSIZE}{maximum block size}
\SetKwData{MINFRAMESIZE}{minimum frame size}
\SetKwData{MAXFRAMESIZE}{maximum frame size}
\SetKwData{SAMPLERATE}{sample rate}
\SetKwData{CHANNELS}{channels}
\SetKwData{BPS}{bits per sample}
\SetKwData{TOTALFRAMES}{total PCM frames}
\SetKwData{MDSUM}{MD5 sum}
\SetKwData{STREAMINFO}{STREAMINFO}
\Repeat{$\LAST = 1$}{
  $\LAST \leftarrow$ \READ 1 unsigned bit\;
  $\TYPE \leftarrow$ \READ 7 unsigned bits\;
  $\SIZE \leftarrow$ \READ 24 unsigned bits\;
  \eIf(\tcc*[f]{read STREAMINFO metadata block}){$\TYPE = 0$}{
    \begin{tabular}{rcl}
      \MINBLOCKSIZE & $\leftarrow$ & \READ 16 unsigned bits\; \\
      \MAXBLOCKSIZE & $\leftarrow$ & \READ 16 unsigned bits\; \\
      \MINFRAMESIZE & $\leftarrow$ & \READ 24 unsigned bits\; \\
      \MAXFRAMESIZE & $\leftarrow$ & \READ 24 unsigned bits\; \\
      \SAMPLERATE & $\leftarrow$ & \READ 20 unsigned bits\; \\
      \CHANNELS & $\leftarrow$ & (\READ 3 unsigned bits) + 1\; \\
      \BPS & $\leftarrow$ & (\READ 5 unsigned bits) + 1\; \\
      \TOTALFRAMES & $\leftarrow$ & \READ 36 unsigned bits\; \\
      \MDSUM & $\leftarrow$ & \READ 16 bytes\;
    \end{tabular}
  }(\tcc*[f]{skip other metadata blocks}){
    \SKIP \SIZE bytes\;
  }
}
\Return $\text{\STREAMINFO} \leftarrow \left\lbrace\begin{tabular}{l}
\MINBLOCKSIZE \\
\MAXBLOCKSIZE \\
\MINFRAMESIZE \\
\MAXFRAMESIZE \\
\SAMPLERATE \\
\CHANNELS \\
\BPS \\
\TOTALFRAMES \\
\MDSUM \\
\end{tabular}\right.$
\EALGORITHM
}
\begin{figure}[h]
\includegraphics{figures/flac/metadata.pdf}
\end{figure}

\clearpage

For example, given the metadata bytes:
\begin{figure}[h]
\includegraphics{figures/flac/block_header.pdf}
\end{figure}
\par
\noindent
\begin{tabular}{rcrcl}
\textsf{last} & $\leftarrow$ & \texttt{0x1} & = & is last metadata block \\
\textsf{size} & $\leftarrow$ & \texttt{0x0} & = & METADATA block \\
\textsf{type} & $\leftarrow$ & \texttt{0x22} & = & 34 bytes \\
\textsf{minimum block size} & $\leftarrow$ & \texttt{0x0100} & = & 4096 samples \\
\textsf{maximum block size} & $\leftarrow$ & \texttt{0x0100} & = & 4096 samples \\
\textsf{minimum frame size} & $\leftarrow$ & \texttt{0x00000C} & = & 12 bytes \\
\textsf{maximum frame size} & $\leftarrow$ & \texttt{0x00000C} & = & 12 bytes \\
\textsf{sample rate} & $\leftarrow$ & \texttt{0xAC44} & = & 44100Hz \\
\textsf{channels} & $\leftarrow$ & \texttt{0x1} & = & 1 (+ 1) = 2 \\
\textsf{bits per sample} & $\leftarrow$ & \texttt{0xF} & = & 15 (+ 1) = 16 \\
\textsf{total PCM frames} & $\leftarrow$ & \texttt{0x32} & = & 50 \\
\textsf{MD5 sum} & $\leftarrow$ & \multicolumn{3}{l}{\texttt{6D0BB00954CEB7FBEE436BB55A8397A9}} \\
\end{tabular}

\clearpage

\subsection{Decoding a FLAC Frame}
\label{flac:decode_frame}
\ALGORITHM{STREAMINFO values and the FLAC file stream}{decoded PCM samples}
\SetKwData{CHANNEL}{channel}
\SetKwData{CHANNELCOUNT}{channel count}
\hyperref[flac:read_frame_header]{read frame header to determine channel count, assignment and bits-per-sample}\;
\ForEach{\CHANNEL \IN \CHANNELCOUNT}{
  \hyperref[flac:decode_subframe]{decode subframe to PCM samples based on its effective bits-per-sample}\;
}
byte-align file stream\;
\hyperref[flac:verify_crc16]{verify frame's CRC-16 checksum}\;
\hyperref[flac:recombine_subframes]{recombine subframes based on the frame's channel assignment}\;
\Return samples\;
\EALGORITHM
\begin{figure}[h]
\includegraphics{figures/flac/frames.pdf}
\end{figure}

\clearpage

\subsection{Reading a FLAC Frame Header}
\label{flac:read_frame_header}
{\relsize{-1}
\ALGORITHM{STREAMINFO values and the FLAC file stream}{stream information and subframe decoding parameters}
\SetKwData{SYNCCODE}{sync code}
\SetKwData{BLOCKINGSTRATEGY}{blocking strategy}
\SetKwData{ENCODEDBLOCKSIZE}{encoded block size}
\SetKwData{ENCODEDSAMPLERATE}{encoded sample rate}
\SetKwData{ENCODEDCHANNELS}{encoded channels}
\SetKwData{ENCODEDBPS}{encoded bits per sample}
\SetKwData{FRAMENUMBER}{frame number}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SAMPLERATE}{sample rate}
\SetKwData{BPS}{bits per sample}
\SetKwData{CHANNELCOUNT}{channel count}
\SetKwData{CRC}{CRC-8}
\SetKwData{FRAMEHEADER}{frame header}
\begin{tabular}{rcl}
\SYNCCODE & $\leftarrow$ & \READ 14 unsigned bits\; \\
& & \ASSERT $\text{\SYNCCODE} = \texttt{0x3FFE}$\; \\
& & \SKIP 1 bit\; \\
\BLOCKINGSTRATEGY & $\leftarrow$ & \READ 1 unsigned bit\; \\
\ENCODEDBLOCKSIZE & $\leftarrow$ & \READ 4 unsigned bits\; \\
\ENCODEDSAMPLERATE & $\leftarrow$ & \READ 4 unsigned bits\; \\
\ENCODEDCHANNELS & $\leftarrow$ & \READ 4 unsigned bits\; \\
\ENCODEDBPS & $\leftarrow$ & \READ 3 unsigned bits\; \\
& & \SKIP 1 bit\; \\
\FRAMENUMBER & $\leftarrow$ & \READ UTF-8 value\; \\
\BLOCKSIZE & $\leftarrow$ & decode \ENCODEDBLOCKSIZE\; \\
\SAMPLERATE & $\leftarrow$ & decode \ENCODEDSAMPLERATE\; \\
\BPS & $\leftarrow$ & decode \ENCODEDBPS\; \\
\CHANNELCOUNT & $\leftarrow$ & decode \ENCODEDCHANNELS\; \\
\CRC & $\leftarrow$ & \READ 8 unsigned bits\; \\
& & \hyperref[flac:verify_crc8]{verify \CRC}\; \\
\end{tabular}\;
\BlankLine
\Return $\text{\FRAMEHEADER} \leftarrow \left\lbrace\begin{tabular}{l}
\BLOCKSIZE \\
\SAMPLERATE \\
\BPS \\
\ENCODEDCHANNELS \\
\CHANNELCOUNT \\
\end{tabular}\right.$\;
\EALGORITHM
}

\subsubsection{Reading UTF-8 Frame Number}
{\relsize{-1}
\ALGORITHM{FLAC file stream}{UTF-8 value as unsigned integer}
\SetKwData{TOTALBYTES}{total bytes}
\SetKwData{VALUE}{value}
\SetKwData{CONTINUATIONHEADER}{continuation header}
\SetKwData{CONTINUATIONBITS}{continuation bits}
$\TOTALBYTES \leftarrow$ \UNARY with stop bit 0\;
$\VALUE \leftarrow$ \READ (7 - $\TOTALBYTES$) unsigned bits\;
\While{$\TOTALBYTES > 0$}{
  $\CONTINUATIONHEADER \leftarrow$ \READ 2 unsigned bits\;
  \ASSERT $\CONTINUATIONHEADER = 2$\;
  $\CONTINUATIONBITS \leftarrow$ \READ 6 unsigned bits\;
  $\VALUE \leftarrow (\VALUE \times 2 ^ 6) + \CONTINUATIONBITS$\;
  $\TOTALBYTES \leftarrow \TOTALBYTES - 1$\;
}
\Return \VALUE\;
\EALGORITHM
}
For example, given the UTF-8 bytes \texttt{E1 82 84}:
\par
\begin{wrapfigure}[5]{l}{2.375in}
\includegraphics{figures/flac/utf8.pdf}
\end{wrapfigure}
\begin{align*}
\text{UTF-8 value} &= \texttt{0001 000010 000100} \\
&= \texttt{0001 0000 1000 0100} \\
&= \texttt{0x1084} \\
&= 4228
\end{align*}

\clearpage

\subsubsection{Decoding Block Size}
{\relsize{-1}
\begin{tabular}{rl||rl}
encoded & block size (in samples) &
encoded & block size \\
\hline
\texttt{0000} & maximum block size from STREAMINFO &
\texttt{1000} & 256 \\
\texttt{0001} & 192 &
\texttt{1001} & 512 \\
\texttt{0010} & 576 &
\texttt{1010} & 1024 \\
\texttt{0011} & 1152 &
\texttt{1011} & 2048 \\
\texttt{0100} & 2304 &
\texttt{1100} & 4096 \\
\texttt{0101} & 4608 &
\texttt{1101} & 8192 \\
\texttt{0110} & (\textbf{read} 8 unsigned bits) + 1 &
\texttt{1110} & 16384 \\
\texttt{0111} & (\textbf{read} 16 unsigned bits) + 1 &
\texttt{1111} & 32768 \\
\end{tabular}
}

\subsubsection{Decoding Sample Rate}
{\relsize{-1}
\begin{tabular}{rl||rl}
encoded & sample rate (in Hz) &
encoded & sample rate \\
\hline
\texttt{0000} & from STREAMINFO &
\texttt{1000} & 32000 \\
\texttt{0001} & 88200 &
\texttt{1001} & 44100 \\
\texttt{0010} & 176400 &
\texttt{1010} & 48000 \\
\texttt{0011} & 192000 &
\texttt{1011} & 96000 \\
\texttt{0100} & 8000 &
\texttt{1100} & (\textbf{read} 8 unsigned bits) $\times$ 1000 \\
\texttt{0101} & 16000 &
\texttt{1101} & \textbf{read} 16 unsigned bits \\
\texttt{0110} & 22050 &
\texttt{1110} & (\textbf{read} 16 unsigned bits) $\times$ 10 \\
\texttt{0111} & 24000 &
\texttt{1111} & invalid \\
\end{tabular}
}

\subsubsection{Decoding Bits per Sample}
{\relsize{-1}
\begin{tabular}{rl||rl}
encoded & bits-per-sample &
encoded & bits-per-sample \\
\hline
\texttt{000} & from STREAMINFO &
\texttt{100} & 16 \\
\texttt{001} & 8 &
\texttt{101} & 20 \\
\texttt{010} & 12 &
\texttt{110} & 24 \\
\texttt{011} & invalid &
\texttt{111} & invalid \\
\end{tabular}
}

\subsubsection{Decoding Channel Count and Assignment}
{\relsize{-1}
\begin{tabular}{rrl}
& channel & \\
encoded & count & channel assignment \\
\hline
\texttt{0000} & 1 & front Center \\
\texttt{0001} & 2 & front Left, front Right \\
\texttt{0010} & 3 & front Left, front Right, front Center \\
\texttt{0011} & 4 & front Left, front Right, back Left, back Right \\
\texttt{0100} & 5 & fL, fR, fC, back/surround left, back/surround right \\
\texttt{0101} & 6 & fL, fR, fC, LFE, back/surround left, back/surround right \\
\texttt{0110} & 7 & undefined \\
\texttt{0111} & 8 & undefined \\
\texttt{1000} & 2 & front Left, Difference \\
\texttt{1001} & 2 & Difference, front Right \\
\texttt{1010} & 2 & Mid, Side \\
\texttt{1011} & & reserved \\
\texttt{1100} & & reserved \\
\texttt{1101} & & reserved \\
\texttt{1110} & & reserved \\
\texttt{1111} & & reserved \\
\end{tabular}
}

\subsubsection{Frame Header Decoding Example}
\begin{figure}[h]
\includegraphics{figures/flac/header-example.pdf}
\end{figure}
{\relsize{-1}
\begin{tabular}{rcl}
\textsf{sync code} & = & \texttt{0x3FFE} \\
\textsf{encoded block size} & = & \texttt{1100b} \\
\textsf{encoded sample rate} & = & \texttt{1001b} \\
\textsf{encoded channels} & = & \texttt{0001b} \\
\textsf{encoded bps} & = & \texttt{100b} \\
\textsf{frame number} & = & 0 \\
\textsf{block size} & = & 4096 samples \\
\textsf{sample rate} & = & 44100Hz \\
\textsf{bits per sample} & = & 16 \\
\textsf{channel count} & = & 2 \\
\textsf{channel assignment} & = & front left, front right
\end{tabular}
}
\subsubsection{Calculating Frame Header CRC-8}
\label{flac:verify_crc8}
Given a header byte and previous CRC-8 checksum,
or 0 as an initial value:
\begin{equation*}
\text{checksum}_i = \texttt{CRC8}(byte\xor\text{checksum}_{i - 1})
\end{equation*}
\begin{table}[h]
{\relsize{-3}\ttfamily
\begin{tabular}{|r||r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|}
\hline
 & 0x?0 & 0x?1 & 0x?2 & 0x?3 & 0x?4 & 0x?5 & 0x?6 & 0x?7 & 0x?8 & 0x?9 & 0x?A & 0x?B & 0x?C & 0x?D & 0x?E & 0x?F \\
\hline
0x0? & 0x00 & 0x07 & 0x0E & 0x09 & 0x1C & 0x1B & 0x12 & 0x15 & 0x38 & 0x3F & 0x36 & 0x31 & 0x24 & 0x23 & 0x2A & 0x2D \\
0x1? & 0x70 & 0x77 & 0x7E & 0x79 & 0x6C & 0x6B & 0x62 & 0x65 & 0x48 & 0x4F & 0x46 & 0x41 & 0x54 & 0x53 & 0x5A & 0x5D \\
0x2? & 0xE0 & 0xE7 & 0xEE & 0xE9 & 0xFC & 0xFB & 0xF2 & 0xF5 & 0xD8 & 0xDF & 0xD6 & 0xD1 & 0xC4 & 0xC3 & 0xCA & 0xCD \\
0x3? & 0x90 & 0x97 & 0x9E & 0x99 & 0x8C & 0x8B & 0x82 & 0x85 & 0xA8 & 0xAF & 0xA6 & 0xA1 & 0xB4 & 0xB3 & 0xBA & 0xBD \\
0x4? & 0xC7 & 0xC0 & 0xC9 & 0xCE & 0xDB & 0xDC & 0xD5 & 0xD2 & 0xFF & 0xF8 & 0xF1 & 0xF6 & 0xE3 & 0xE4 & 0xED & 0xEA \\
0x5? & 0xB7 & 0xB0 & 0xB9 & 0xBE & 0xAB & 0xAC & 0xA5 & 0xA2 & 0x8F & 0x88 & 0x81 & 0x86 & 0x93 & 0x94 & 0x9D & 0x9A \\
0x6? & 0x27 & 0x20 & 0x29 & 0x2E & 0x3B & 0x3C & 0x35 & 0x32 & 0x1F & 0x18 & 0x11 & 0x16 & 0x03 & 0x04 & 0x0D & 0x0A \\
0x7? & 0x57 & 0x50 & 0x59 & 0x5E & 0x4B & 0x4C & 0x45 & 0x42 & 0x6F & 0x68 & 0x61 & 0x66 & 0x73 & 0x74 & 0x7D & 0x7A \\
0x8? & 0x89 & 0x8E & 0x87 & 0x80 & 0x95 & 0x92 & 0x9B & 0x9C & 0xB1 & 0xB6 & 0xBF & 0xB8 & 0xAD & 0xAA & 0xA3 & 0xA4 \\
0x9? & 0xF9 & 0xFE & 0xF7 & 0xF0 & 0xE5 & 0xE2 & 0xEB & 0xEC & 0xC1 & 0xC6 & 0xCF & 0xC8 & 0xDD & 0xDA & 0xD3 & 0xD4 \\
0xA? & 0x69 & 0x6E & 0x67 & 0x60 & 0x75 & 0x72 & 0x7B & 0x7C & 0x51 & 0x56 & 0x5F & 0x58 & 0x4D & 0x4A & 0x43 & 0x44 \\
0xB? & 0x19 & 0x1E & 0x17 & 0x10 & 0x05 & 0x02 & 0x0B & 0x0C & 0x21 & 0x26 & 0x2F & 0x28 & 0x3D & 0x3A & 0x33 & 0x34 \\
0xC? & 0x4E & 0x49 & 0x40 & 0x47 & 0x52 & 0x55 & 0x5C & 0x5B & 0x76 & 0x71 & 0x78 & 0x7F & 0x6A & 0x6D & 0x64 & 0x63 \\
0xD? & 0x3E & 0x39 & 0x30 & 0x37 & 0x22 & 0x25 & 0x2C & 0x2B & 0x06 & 0x01 & 0x08 & 0x0F & 0x1A & 0x1D & 0x14 & 0x13 \\
0xE? & 0xAE & 0xA9 & 0xA0 & 0xA7 & 0xB2 & 0xB5 & 0xBC & 0xBB & 0x96 & 0x91 & 0x98 & 0x9F & 0x8A & 0x8D & 0x84 & 0x83 \\
0xF? & 0xDE & 0xD9 & 0xD0 & 0xD7 & 0xC2 & 0xC5 & 0xCC & 0xCB & 0xE6 & 0xE1 & 0xE8 & 0xEF & 0xFA & 0xFD & 0xF4 & 0xF3 \\
\hline
\end{tabular}
}
\end{table}
\begin{align*}
\text{checksum}_0 = \texttt{CRC8}(\texttt{FF}\xor\texttt{00}) = \texttt{F3} & &
\text{checksum}_3 = \texttt{CRC8}(\texttt{18}\xor\texttt{E6}) = \texttt{F4} \\
\text{checksum}_1 = \texttt{CRC8}(\texttt{F8}\xor\texttt{F3}) = \texttt{31} & &
\text{checksum}_4 = \texttt{CRC8}(\texttt{00}\xor\texttt{F4}) = \texttt{C2} \\
\text{checksum}_2 = \texttt{CRC8}(\texttt{C9}\xor\texttt{31}) = \texttt{E6} & &
\text{checksum}_5 = \texttt{CRC8}(\texttt{C2}\xor\texttt{C2}) = \texttt{00} \\
\end{align*}
Note that the final checksum (including the CRC-8 byte itself)
should always be 0.


\clearpage

\subsection{Decoding a FLAC Subframe}
\label{flac:decode_subframe}
{\relsize{-1}
\ALGORITHM{the frame's block size and bits per sample, the subframe's channel assignment and the FLAC file stream}{decoded signed PCM samples}
\SetKwData{TYPEORDER}{type/order}
\SetKwData{WASTEDBPS}{wasted BPS}
\SetKwData{EFFECTIVEBPS}{subframe's BPS}
\SetKwData{DIFFERENCE}{difference}
\SetKwData{SIDE}{side}
\SetKwData{ORDER}{order}
\SetKwData{SAMPLE}{sample}
\SetKwData{BLOCKSIZE}{block size}
\SKIP 1 bit\;
$\TYPEORDER \leftarrow$ \READ 6 unsigned bits\;
\eIf(\tcc*[f]{account for wasted bits}){$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $\WASTEDBPS \leftarrow$ (\UNARY with stop bit 1) + 1\;
}{
  $\WASTEDBPS \leftarrow 0$\;
}
\eIf{subframe's channel assignment is \DIFFERENCE or \SIDE}{
  $\EFFECTIVEBPS \leftarrow \text{frame header's bits per sample} - \WASTEDBPS + 1$\;
}{
  $\EFFECTIVEBPS \leftarrow \text{frame header's bits per sample} - \WASTEDBPS$\;
}
\uIf{$\TYPEORDER = 0$}{
  \SAMPLE $\leftarrow$ \hyperref[flac:decode_constant]{decode CONSTANT subframe with \BLOCKSIZE, \EFFECTIVEBPS}\;
}
\uElseIf{$\TYPEORDER = 1$} {
  \SAMPLE $\leftarrow$ \hyperref[flac:decode_verbatim]{decode VERBATIM subframe with \BLOCKSIZE, \EFFECTIVEBPS}\;
}
\uElseIf{$8 \leq \TYPEORDER \leq 12$} {
  $\ORDER \leftarrow \TYPEORDER - 8$\;
  \SAMPLE $\leftarrow$ \hyperref[flac:decode_fixed]{decode FIXED subframe with \BLOCKSIZE, \EFFECTIVEBPS, \ORDER}\;
}
\uElseIf{$32 \leq \TYPEORDER \leq 63$} {
  $\ORDER \leftarrow \TYPEORDER - 31$\;
  \SAMPLE $\leftarrow$ \hyperref[flac:decode_lpc]{decode LPC subframe with \BLOCKSIZE, \EFFECTIVEBPS, \ORDER}\;
}
\Else {
  undefined subframe type error\;
}
\If(\tcc*[f]{prepend any wasted bits to each sample}){$\WASTEDBPS > 0$}{
  \For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
    $\text{\SAMPLE}_i \leftarrow \text{\SAMPLE}_i \times 2 ^ {\WASTEDBPS}$\;
  }
}
\Return \SAMPLE\;
\EALGORITHM
}
\begin{figure}[h]
\includegraphics{figures/flac/subframes.pdf}
\end{figure}

\clearpage

\subsubsection{Decoding CONSTANT Subframe}
\label{flac:decode_constant}
\ALGORITHM{the frame's block size, the subframe's bits per sample}{decoded signed PCM samples}
\SetKwData{CONSTANT}{constant}
\SetKwData{BPS}{subframe's BPS}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SAMPLE}{sample}
$\CONSTANT \leftarrow$ \READ (\BPS) signed bits\;
\For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
  $\text{\SAMPLE}_i \leftarrow \CONSTANT$\;
}
\Return \SAMPLE\;
\EALGORITHM
\begin{figure}[h]
  \includegraphics{figures/flac/constant.pdf}
\end{figure}

\subsubsection{Decoding VERBATIM Subframe}
\label{flac:decode_verbatim}
\ALGORITHM{the frame's block size, the subframe's bits per sample}{decoded signed PCM samples}
\SetKwData{BPS}{bits per sample}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SAMPLE}{sample}
\For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
  $\text{\SAMPLE}_i \leftarrow $ \READ (\BPS) signed bits\;
}
\Return \SAMPLE\;
\EALGORITHM
\begin{figure}[h]
\includegraphics{figures/flac/verbatim.pdf}
\end{figure}

\clearpage

\subsubsection{Decoding FIXED Subframe}
\label{flac:decode_fixed}
{\relsize{-1}
\ALGORITHM{the frame's block size, the subframe's bits per sample and predictor order}{decoded signed PCM samples}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{BPS}{subframe's BPS}
\SetKwData{ORDER}{order}
\SetKwData{SAMPLE}{sample}
\SetKwData{RESIDUAL}{residual}
\For(\tcc*[f]{warm-up samples}){$i \leftarrow 0$ \emph{\KwTo}\ORDER}{
  $\text{\SAMPLE}_i \leftarrow $ \READ (\BPS) signed bits\;
}
\BlankLine
$\RESIDUAL \leftarrow$ \hyperref[flac:decode_residual]{read residual block with frame's \BLOCKSIZE and subframe's \ORDER}\;
\BlankLine
\Switch{\ORDER}{
  \uCase{0} {
    \For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
      $\text{\SAMPLE}_i \leftarrow \text{\RESIDUAL}_i$
    }
  }
  \uCase{1} {
    \For{$i \leftarrow 1$ \emph{\KwTo}\BLOCKSIZE}{
      $\text{\SAMPLE}_i \leftarrow \text{\SAMPLE}_{i - 1} + \text{\RESIDUAL}_{i - 1}$
    }
  }
  \uCase{2} {
    \For{$i \leftarrow 2$ \emph{\KwTo}\BLOCKSIZE}{
      $\text{\SAMPLE}_i \leftarrow (2 \times \text{\SAMPLE}_{i - 1}) - \text{\SAMPLE}_{i - 2} + \text{\RESIDUAL}_{i - 2}$
    }
  }
  \uCase{3} {
    \For{$i \leftarrow 3$ \emph{\KwTo}\BLOCKSIZE}{
      $\text{\SAMPLE}_i \leftarrow (3 \times \text{\SAMPLE}_{i - 1}) - (3 \times \text{\SAMPLE}_{i - 2}) + \text{\SAMPLE}_{i - 3} + \text{\RESIDUAL}_{i - 3}$
    }
  }
  \Case{4} {
    \For{$i \leftarrow 4$ \emph{\KwTo}\BLOCKSIZE}{
      $\text{\SAMPLE}_i \leftarrow (4 \times \text{\SAMPLE}_{i - 1}) - (6 \times \text{\SAMPLE}_{i - 2}) + (4 \times \text{\SAMPLE}_{i - 3}) - \text{\SAMPLE}_{i - 4} + \text{\RESIDUAL}_{i - 4}$
    }
  }
}
\Return \SAMPLE\;
\EALGORITHM
}
\begin{figure}[h]
\includegraphics{figures/flac/fixed.pdf}
\end{figure}

\clearpage

\subsubsection{FIXED Subframe Decoding Example}

Given the subframe bytes of a 16 bits per sample stream\footnote{Decoding the residual block is explained on page \pageref{flac:decode_residual}}:
\begin{figure}[h]
\includegraphics{figures/flac/fixed-parse.pdf}
\end{figure}
\begin{align*}
\text{subframe type} &\leftarrow \text{FIXED} \\
\text{subframe order} &\leftarrow 1 \\
\text{wasted BPS} &\leftarrow 0 \\
\text{warm-up sample}_0 &\leftarrow 37 \\
\end{align*}
\begin{center}
\begin{tabular}{r||r|>{$}r<{$}}
$i$ & $\textsf{residual}_{i - 1}$ & \textsf{sample}_i \\
\hline
0 & & 37 \\
1 & -2 & 37 - 2 = 35 \\
2 & 3 & 35 + 3 = 38 \\
3 & -1 & 38 - 1 = 37 \\
4 & -5 & 37 - 5 = 32 \\
5 & 1 & 32 + 1 = 33 \\
6 & -5 & 33 - 5 = 27 \\
7 & 4 & 27 + 4 = 31 \\
8 & -2 & 31 - 2 = 29 \\
9 & -3 & 29 - 3 = 26 \\
10 & 1 & 26 + 1 = 27 \\
\end{tabular}
\end{center}

\clearpage

\subsubsection{Decoding LPC Subframe}
\label{flac:decode_lpc}
{\relsize{-1}
\ALGORITHM{the frame's block size, the subframe's bits per sample and predictor order}{decoded signed PCM samples}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{BPS}{subframe's BPS}
\SetKwData{ORDER}{order}
\SetKwData{QLPPREC}{QLP precision}
\SetKwData{QLPSHIFT}{QLP shift needed}
\SetKwData{COEFF}{QLP coefficient}
\SetKwData{RESIDUAL}{residual}
\SetKwData{SAMPLE}{sample}
\SetKwFunction{MAX}{max}
\For(\tcc*[f]{warm-up samples}){$i \leftarrow 0$ \emph{\KwTo}\ORDER}{
  $\text{\SAMPLE}_i \leftarrow $ \READ (\BPS) signed bits\;
}
$\QLPPREC \leftarrow$ (\READ 4 unsigned bits) + 1\;
$\QLPSHIFT \leftarrow \MAX(\text{\READ 5 signed bits}~,~0)$\footnote{negative shifts are no-ops in the decoder}\;
\For{$i \leftarrow 0$ \emph{\KwTo}\ORDER}{
  $\text{\COEFF}_i \leftarrow$ \READ (\QLPPREC) signed bits\;
}
\BlankLine
$\RESIDUAL \leftarrow$ \hyperref[flac:decode_residual]{read residual block with frame's \BLOCKSIZE and subframe's \ORDER}\;
\BlankLine
\For{$i \leftarrow \ORDER$ \emph{\KwTo}\BLOCKSIZE}{
  $\text{\SAMPLE}_i \leftarrow \left\lfloor \frac{\overset{\ORDER - 1}{\underset{j = 0}{\sum}}
    \text{\COEFF}_j \times \text{\SAMPLE}_{i - j - 1} } {2 ^ \text{\QLPSHIFT}}\right\rfloor + \text{\RESIDUAL}_{i - \ORDER}$\;
}
\Return \SAMPLE\;
\EALGORITHM
}
\begin{figure}[h]
\includegraphics{figures/flac/lpc.pdf}
\end{figure}

\subsubsection{LPC Subframe Decoding Example}
\begin{table}[h]
{\relsize{-1}
\begin{tabular}{rcl}
  subframe type & $\leftarrow$ & LPC \\
  subframe order & $\leftarrow$ & 3 \\
  wasted BPS & $\leftarrow$ & 0 \\
  QLP precision & $\leftarrow$ & 12 \\
  QLP shift needed & $\leftarrow$ & 10 \\
\end{tabular}
\begin{tabular}{r|rrr}
  $i$ & $\textsf{sample}_i$ & $\textsf{QLP coefficient}_i$ & $\textsf{residual}_i$ \\
\hline
0 & 43 & 1451 & 4 \\
1 & 48 & -323 & 0 \\
2 & 50 & -110 & 1 \\
3 & & & -2 \\
4 & & & -3 \\
\end{tabular}
}
\end{table}

\clearpage

\begin{figure}[h]
\includegraphics{figures/flac/lpc-parse.pdf}
\end{figure}
{\relsize{-1}
\begin{align*}
\text{sample}_0 &\leftarrow 43 \\
\text{sample}_1 &\leftarrow 48 \\
\text{sample}_2 &\leftarrow 50 \\
\text{sample}_3 &\leftarrow \left\lfloor\frac{(1451 \times 50) + (-323 \times 48) + (-110 \times 43)}{2 ^ {10}}\right\rfloor + 4 = \left\lfloor\frac{52316}{1024}\right\rfloor + 4 = \textbf{55} \\
\text{sample}_4 &\leftarrow \left\lfloor\frac{(1451 \times 55) + (-323 \times 50) + (-110 \times 48)}{2 ^ {10}}\right\rfloor + 0 = \left\lfloor\frac{58375}{1024}\right\rfloor + 0 = \textbf{57} \\
\text{sample}_5 &\leftarrow \left\lfloor\frac{(1451 \times 57) + (-323 \times 55) + (-110 \times 50)}{2 ^ {10}}\right\rfloor + 1 = \left\lfloor\frac{59442}{1024}\right\rfloor + 1 = \textbf{59} \\
\text{sample}_6 &\leftarrow \left\lfloor\frac{(1451 \times 59) + (-323 \times 57) + (-110 \times 55)}{2 ^ {10}}\right\rfloor - 2 = \left\lfloor\frac{61148}{1024}\right\rfloor - 2 = \textbf{57} \\
\text{sample}_7 &\leftarrow \left\lfloor\frac{(1451 \times 57) + (-323 \times 59) + (-110 \times 57)}{2 ^ {10}}\right\rfloor - 3 = \left\lfloor\frac{57380}{1024}\right\rfloor - 3 = \textbf{53} \\
\end{align*}
}

\clearpage

\subsubsection{Decoding Residual Block}
\label{flac:decode_residual}
{\relsize{-1}
\ALGORITHM{the frame's block size and predictor order}{decoded signed residual values}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{CODING}{coding method}
\SetKwData{PORDER}{partition order}
\SetKwData{PCOUNT}{partition residual count}
\SetKwData{ORDER}{predictor order}
\SetKwData{RESIDUAL}{residual}
\SetKwData{RICE}{Rice}
\SetKwData{ESCAPE}{escape code}
\SetKwData{MSB}{MSB}
\SetKwData{LSB}{LSB}
\SetKwData{UNSIGNED}{unsigned}
\SetKw{AND}{and}
\SetKw{OR}{or}
$\CODING \leftarrow$ \READ 2 unsigned bits\;
$\PORDER \leftarrow$ \READ 4 unsigned bits\;
$i \leftarrow 0$\;
\BlankLine
\For(\tcc*[f]{read residual partitions}){$p \leftarrow 0$ \emph{\KwTo}$2 ^ {\text{\PORDER}}$}{
  \uIf{$\text{\CODING} = 0$}{
    $\text{\RICE}_p \leftarrow$ \READ 4 unsigned bits\;
  }
  \uElseIf{$\text{\CODING} = 1$}{
    $\text{\RICE}_p \leftarrow$ \READ 5 unsigned bits\;
  }
  \Else{
    undefined residual coding method error\;
  }
  \eIf{p = 0}{
    $\text{\PCOUNT}_p \leftarrow \lfloor\text{\BLOCKSIZE} \div 2 ^ {\PORDER}\rfloor - \text{\ORDER}$
  }{
    $\text{\PCOUNT}_p \leftarrow \lfloor\text{\BLOCKSIZE} \div 2 ^ {\PORDER}\rfloor$
  }
  \eIf{$((\text{\CODING} = 0)~\text{\AND}~(\text{\RICE}_p = 15))$ \OR
    $((\text{\CODING} = 1)~\text{\AND}~(\text{\RICE}_p = 31))$}{
    $\text{\ESCAPE}_p \leftarrow$ \READ 5 unsigned bits\;
    \For{$j \leftarrow 0$ \emph{\KwTo}$\text{\PCOUNT}_p$}{
      $\text{\RESIDUAL}_i \leftarrow$ \READ $\text{\ESCAPE}_p$ signed bits\;
      $i \leftarrow i + 1$\;
    }
  }{
    \For{$j \leftarrow 0$ \emph{\KwTo}$\text{\PCOUNT}_p$} {
      $\text{\MSB}_i \leftarrow$ \UNARY with stop bit 1\;
      $\text{\LSB}_i \leftarrow$ \READ $\text{\RICE}_p$ unsigned bits\;
      $\text{\UNSIGNED}_i \leftarrow \text{\MSB}_i \times 2 ^ {\text{\RICE}_p} + \text{\LSB}_i$\;
      \eIf(\tcc*[f]{apply sign bit}){$(\text{\UNSIGNED}_i \bmod 2) = 0$}{
        $\text{\RESIDUAL}_i \leftarrow \text{\UNSIGNED}_i \div 2$\;
      }{
        $\text{\RESIDUAL}_i \leftarrow -\lfloor \text{\UNSIGNED}_i \div 2 \rfloor - 1$\;
      }
      $i \leftarrow i + 1$\;
    }
  }
}
\Return \RESIDUAL\;
\EALGORITHM
}

\clearpage

\begin{figure}[h]
\includegraphics{figures/flac/residual.pdf}
\end{figure}
\par
\noindent
As an example, we'll decode 10 residual values from the following bytes:
\begin{figure}[h]
\includegraphics{figures/flac/residual-parse.pdf}
\end{figure}
\par
\noindent
{\relsize{-1}
\begin{tabular}{rcl|rcl}
\textsf{coding method} & $\leftarrow$ & 0 \\
\textsf{partition order} & $\leftarrow$ & 0 \\
\textsf{Rice parameter} & $\leftarrow$ & 2 \\
\hline
$\textsf{MSB}_0$ & $\leftarrow$ & 0 &
$\textsf{MSB}_5$ & $\leftarrow$ & 2 \\
$\textsf{LSB}_0$ & $\leftarrow$ & 3 &
$\textsf{LSB}_5$ & $\leftarrow$ & 1 \\
$\textsf{unsigned}_0$ & $\leftarrow$ & $0 \times 2 ^ 2 + 3 = 3$ &
$\textsf{unsigned}_5$ & $\leftarrow$ & $2 \times 2 ^ 2 + 1 = 9$ \\
$\textsf{residual}_0$ & $\leftarrow$ & $-\lfloor 3 \div 2\rfloor - 1 = -2$ &
$\textsf{residual}_5$ & $\leftarrow$ & $-\lfloor 9 \div 2\rfloor - 1 = -5$ \\
\hline
$\textsf{MSB}_1$ & $\leftarrow$ & 1 &
$\textsf{MSB}_6$ & $\leftarrow$ & 2 \\
$\textsf{LSB}_1$ & $\leftarrow$ & 2 &
$\textsf{LSB}_6$ & $\leftarrow$ & 0 \\
$\textsf{unsigned}_1$ & $\leftarrow$ & $1 \times 2 ^ 2 + 2 = 6$ &
$\textsf{unsigned}_6$ & $\leftarrow$ & $2 \times 2 ^ 2 + 0 = 8$ \\
$\textsf{residual}_1$ & $\leftarrow$ & $6 \div 2 = 3$ &
$\textsf{residual}_6$ & $\leftarrow$ & $8 \div 2 = 4$ \\
\hline
$\textsf{MSB}_2$ & $\leftarrow$ & 0 &
$\textsf{MSB}_7$ & $\leftarrow$ & 0 \\
$\textsf{LSB}_2$ & $\leftarrow$ & 1 &
$\textsf{LSB}_7$ & $\leftarrow$ & 3 \\
$\textsf{unsigned}_2$ & $\leftarrow$ & $0 \times 2 ^ 2 + 1 = 1$ &
$\textsf{unsigned}_7$ & $\leftarrow$ & $0 \times 2 ^ 2 + 3 = 3$ \\
$\textsf{residual}_2$ & $\leftarrow$ & $-\lfloor 1 \div 2\rfloor - 1 = -1$ &
$\textsf{residual}_7$ & $\leftarrow$ & $-\lfloor 3 \div 2\rfloor - 1 = -2$ \\
\hline
$\textsf{MSB}_3$ & $\leftarrow$ & 2 &
$\textsf{MSB}_8$ & $\leftarrow$ & 1 \\
$\textsf{LSB}_3$ & $\leftarrow$ & 1 &
$\textsf{LSB}_8$ & $\leftarrow$ & 1 \\
$\textsf{unsigned}_3$ & $\leftarrow$ & $2 \times 2 ^ 2 + 1 = 9$ &
$\textsf{unsigned}_8$ & $\leftarrow$ & $1 \times 2 ^ 2 + 1 = 5$ \\
$\textsf{residual}_3$ & $\leftarrow$ & $-\lfloor 9 \div 2\rfloor - 1 = -5$ &
$\textsf{residual}_8$ & $\leftarrow$ & $-\lfloor 5 \div 2\rfloor - 1 = -3$ \\
\hline
$\textsf{MSB}_4$ & $\leftarrow$ & 0 &
$\textsf{MSB}_9$ & $\leftarrow$ & 0 \\
$\textsf{LSB}_4$ & $\leftarrow$ & 2 &
$\textsf{LSB}_9$ & $\leftarrow$ & 2 \\
$\textsf{unsigned}_4$ & $\leftarrow$ & $0 \times 2 ^ 2 + 2 = 2$ &
$\textsf{unsigned}_9$ & $\leftarrow$ & $0 \times 2 ^ 2 + 2 = 2$ \\
$\textsf{residual}_4$ & $\leftarrow$ & $2 \div 2 = 1$ &
$\textsf{residual}_9$ & $\leftarrow$ & $2 \div 2 = 1$ \\
\end{tabular}
}
\par
\noindent
\vskip .25in
for a final set of residuals: -2, 3, -1, -5, 1, -5, 4, -2, -3 and 1.

\clearpage

\subsection{Calculating Frame CRC-16}
\label{flac:verify_crc16}
CRC-16 is used to checksum the entire FLAC frame, including the header
and any padding bits after the final subframe.
Given a byte of input and the previous CRC-16 checksum,
or 0 as an initial value, the current checksum can be calculated as follows:
\begin{equation}
\text{checksum}_i = \texttt{CRC16}(byte\xor(\text{checksum}_{i - 1} \gg 8 ))\xor(\text{checksum}_{i - 1} \ll 8)
\end{equation}
\par
\noindent
and the checksum is always truncated to 16-bits.
\begin{table}[h]
{\relsize{-3}\ttfamily
\begin{tabular}{|r||r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|}
\hline
 & 0x?0 & 0x?1 & 0x?2 & 0x?3 & 0x?4 & 0x?5 & 0x?6 & 0x?7 & 0x?8 & 0x?9 & 0x?A & 0x?B & 0x?C & 0x?D & 0x?E & 0x?F \\
\hline
0x0? & 0000 & 8005 & 800f & 000a & 801b & 001e & 0014 & 8011 & 8033 & 0036 & 003c & 8039 & 0028 & 802d & 8027 & 0022 \\
0x1? & 8063 & 0066 & 006c & 8069 & 0078 & 807d & 8077 & 0072 & 0050 & 8055 & 805f & 005a & 804b & 004e & 0044 & 8041 \\
0x2? & 80c3 & 00c6 & 00cc & 80c9 & 00d8 & 80dd & 80d7 & 00d2 & 00f0 & 80f5 & 80ff & 00fa & 80eb & 00ee & 00e4 & 80e1 \\
0x3? & 00a0 & 80a5 & 80af & 00aa & 80bb & 00be & 00b4 & 80b1 & 8093 & 0096 & 009c & 8099 & 0088 & 808d & 8087 & 0082 \\
0x4? & 8183 & 0186 & 018c & 8189 & 0198 & 819d & 8197 & 0192 & 01b0 & 81b5 & 81bf & 01ba & 81ab & 01ae & 01a4 & 81a1 \\
0x5? & 01e0 & 81e5 & 81ef & 01ea & 81fb & 01fe & 01f4 & 81f1 & 81d3 & 01d6 & 01dc & 81d9 & 01c8 & 81cd & 81c7 & 01c2 \\
0x6? & 0140 & 8145 & 814f & 014a & 815b & 015e & 0154 & 8151 & 8173 & 0176 & 017c & 8179 & 0168 & 816d & 8167 & 0162 \\
0x7? & 8123 & 0126 & 012c & 8129 & 0138 & 813d & 8137 & 0132 & 0110 & 8115 & 811f & 011a & 810b & 010e & 0104 & 8101 \\
0x8? & 8303 & 0306 & 030c & 8309 & 0318 & 831d & 8317 & 0312 & 0330 & 8335 & 833f & 033a & 832b & 032e & 0324 & 8321 \\
0x9? & 0360 & 8365 & 836f & 036a & 837b & 037e & 0374 & 8371 & 8353 & 0356 & 035c & 8359 & 0348 & 834d & 8347 & 0342 \\
0xA? & 03c0 & 83c5 & 83cf & 03ca & 83db & 03de & 03d4 & 83d1 & 83f3 & 03f6 & 03fc & 83f9 & 03e8 & 83ed & 83e7 & 03e2 \\
0xB? & 83a3 & 03a6 & 03ac & 83a9 & 03b8 & 83bd & 83b7 & 03b2 & 0390 & 8395 & 839f & 039a & 838b & 038e & 0384 & 8381 \\
0xC? & 0280 & 8285 & 828f & 028a & 829b & 029e & 0294 & 8291 & 82b3 & 02b6 & 02bc & 82b9 & 02a8 & 82ad & 82a7 & 02a2 \\
0xD? & 82e3 & 02e6 & 02ec & 82e9 & 02f8 & 82fd & 82f7 & 02f2 & 02d0 & 82d5 & 82df & 02da & 82cb & 02ce & 02c4 & 82c1 \\
0xE? & 8243 & 0246 & 024c & 8249 & 0258 & 825d & 8257 & 0252 & 0270 & 8275 & 827f & 027a & 826b & 026e & 0264 & 8261 \\
0xF? & 0220 & 8225 & 822f & 022a & 823b & 023e & 0234 & 8231 & 8213 & 0216 & 021c & 8219 & 0208 & 820d & 8207 & 0202 \\
\hline
\end{tabular}
}
\end{table}
\par
\noindent
For example, given the frame bytes:
\texttt{FF F8 CC 1C 00 C0 EB 00 00 00 00 00 00 00 00},
the frame's CRC-16 can be calculated:
{\relsize{-2}
\begin{align*}
\CRCSIXTEEN{0}{0xFF}{0x0000}{0xFF}{0x0000}{0x0202} \\
\CRCSIXTEEN{1}{0xF8}{0x0202}{0xFA}{0x0200}{0x001C} \\
\CRCSIXTEEN{2}{0xCC}{0x001C}{0xCC}{0x1C00}{0x1EA8} \\
\CRCSIXTEEN{3}{0x1C}{0x1EA8}{0x02}{0xA800}{0x280F} \\
\CRCSIXTEEN{4}{0x00}{0x280F}{0x28}{0x0F00}{0x0FF0} \\
\CRCSIXTEEN{5}{0xC0}{0x0FF0}{0xCF}{0xF000}{0xF2A2} \\
\CRCSIXTEEN{6}{0xEB}{0xF2A2}{0x19}{0xA200}{0x2255} \\
\CRCSIXTEEN{7}{0x00}{0x2255}{0x22}{0x5500}{0x55CC} \\
\CRCSIXTEEN{8}{0x00}{0x55CC}{0x55}{0xCC00}{0xCDFE} \\
\CRCSIXTEEN{9}{0x00}{0xCDFE}{0xCD}{0xFE00}{0x7CAD} \\
\CRCSIXTEEN{10}{0x00}{0x7CAD}{0x7C}{0xAD00}{0x2C0B} \\
\CRCSIXTEEN{11}{0x00}{0x2C0B}{0x2C}{0x0B00}{0x8BEB} \\
\CRCSIXTEEN{12}{0x00}{0x8BEB}{0x8B}{0xEB00}{0xE83A} \\
\CRCSIXTEEN{13}{0x00}{0xE83A}{0xE8}{0x3A00}{0x3870} \\
\CRCSIXTEEN{14}{0x00}{0x3870}{0x38}{0x7000}{0xF093} \\
\intertext{Thus, the next two bytes after the final subframe should be
\texttt{0xF0} and \texttt{0x93}.
Again, when the checksum bytes are run through the checksumming procedure:}
\CRCSIXTEEN{15}{0xF0}{0xF093}{0x00}{0x9300}{0x9300} \\
\CRCSIXTEEN{16}{0x93}{0x9300}{0x00}{0x0000}{0x0000}
\end{align*}
the result will also always be 0, just as in the CRC-8.
}

\clearpage

\subsection{Recombining Subframes}
\label{flac:recombine_subframes}
\ALGORITHM{the frame's block size and channel assignment, a set of decoded subframe samples\footnote{$\textsf{subframe}_{x~y}$ indicates the $y$th sample in subframe $x$}}{a list of signed PCM frames per channel}
\SetKwData{ENCODEDCHANNELS}{encoded channels}
\SetKwData{CHANNELCOUNT}{channel count}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SUBFRAME}{subframe}
\SetKwData{CHANNEL}{channel}
\uIf(\tcc*[f]{independent}){$0 \leq \ENCODEDCHANNELS \leq 7$}{
 \CHANNELCOUNT $\leftarrow \ENCODEDCHANNELS + 1$\;
 \For{$c \leftarrow 0$ \emph{\KwTo}\CHANNELCOUNT}{
   \For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
     $\text{\CHANNEL}_{c~i} \leftarrow \text{\SUBFRAME}_{c~i}$
   }
 }
}
\uElseIf(\tcc*[f]{left-difference}){$\ENCODEDCHANNELS = 8$}{
  \For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
    $\text{\CHANNEL}_{0~i} \leftarrow \text{\SUBFRAME}_{0~i}$\;
    $\text{\CHANNEL}_{1~i} \leftarrow \text{\SUBFRAME}_{0~i} - \text{\SUBFRAME}_{1~i}$\;
  }
}
\uElseIf(\tcc*[f]{difference-right}){$\ENCODEDCHANNELS = 9$}{
  \For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
    $\text{\CHANNEL}_{0~i} \leftarrow \text{\SUBFRAME}_{0~i} + \text{\SUBFRAME}_{1~i}$\;
    $\text{\CHANNEL}_{1~i} \leftarrow \text{\SUBFRAME}_{1~i}$\;
  }
}
\ElseIf(\tcc*[f]{mid-side}){$\ENCODEDCHANNELS = 10$}{
  \For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
    $\text{\CHANNEL}_{0~i} \leftarrow \lfloor(((\text{\SUBFRAME}_{0~i} \times 2) + (\text{\SUBFRAME}_{1~i} \bmod 2)) + \text{\SUBFRAME}_{1~i}) \div 2\rfloor$\;
      $\text{\CHANNEL}_{1~i} \leftarrow \lfloor(((\text{\SUBFRAME}_{0~i} \times 2) + (\text{\SUBFRAME}_{1~i} \bmod 2)) - \text{\SUBFRAME}_{1~i}) \div 2\rfloor$\;
  }
}
\Return \CHANNEL\;
\EALGORITHM

\clearpage

\subsection{Updating Stream MD5 Sum}
\label{flac:update_md5}
\ALGORITHM{the frame's signed PCM samples\footnote{$channel_{c~i}$ indicates the $i$th sample in channel $c$}}{the stream's updated MD5 sum}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{CHANNELCOUNT}{channel count}
\SetKwData{CHANNEL}{channel}
\For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
  \For{$c \leftarrow 0$ \emph{\KwTo}\CHANNELCOUNT}{
    bytes $\leftarrow \text{\CHANNEL}_{c~i}$ as signed, little-endian bytes\;
    update stream's MD5 sum with bytes\;
  }
}
\Return stream's MD5 sum\;
\EALGORITHM
\vskip .25in
\par
\noindent
For example, given a 16 bits per sample stream with the signed sample values:
\begin{table}[h]
\begin{tabular}{r|rr}
$i$ & $\textsf{channel}_{0~i}$ & $\textsf{channel}_{1~i}$ \\
\hline
0 & 1 & -1 \\
1 & 2 & -2 \\
2 & 3 & -3 \\
\end{tabular}
\end{table}
\par
\noindent
are translated to the bytes:
\begin{table}[h]
\begin{tabular}{r|rr}
$i$ & $\textsf{channel}_{0~i}$ & $\textsf{channel}_{1~i}$ \\
\hline
0 & \texttt{01 00} & \texttt{FF FF} \\
1 & \texttt{02 00} & \texttt{FE FF} \\
2 & \texttt{03 00} & \texttt{FD FF} \\
\end{tabular}
\end{table}
\par
\noindent
and combined as:
\vskip .15in
\par
\noindent
\texttt{01 00 FF FF 02 00 FE FF 03 00 FD FF}
\vskip .15in
\par
\noindent
whose MD5 sum is:
\vskip .15in
\par
\noindent
\texttt{E7482f6462B27EE04EADC079291C79E9}

\clearpage

\section{FLAC Encoding}

The basic process for encoding a FLAC file is as follows:
\par
\noindent
\ALGORITHM{PCM frames, various encoding parameters:
\newline
{\relsize{-1}
\begin{tabular}{rll}
parameter & possible values & typical values \\
\hline
block size & a positive number of PCM frames & 1152 or 4096 \\
maximum LPC order & integer between 0 and 32, inclusive & 0, 6, 8 or 12 \\
minimum partition order & integer between 0 and 16, inclusive & 0 \\
maximum partition order & integer between 0 and 16, inclusive & 3, 4, 5 or 6 \\
maximum Rice parameter & 14 if bits-per-sample $\leq 16$, otherwise 30 & \\
try mid-side & true or false & \\
try adaptive mid-side & true or false & \\
QLP precision & $\begin{cases}
7 & \text{ if } 0 < \text{block size} \leq 192 \\
8 & \text{ if } 192 < \text{block size} \leq 384 \\
9 & \text{ if } 384 < \text{block size} \leq 576 \\
10 & \text{ if } 576 < \text{block size} \leq 1152 \\
11 & \text{ if } 1152 < \text{block size} \leq 2304 \\
12 & \text{ if } 2304 < \text{block size} \leq 4608 \\
13 & \text{ if } \text{block size} > 4608 \\
\end{cases}$ & \\
exhaustive model search & true or false & \\
\end{tabular}
}
}{an encoded FLAC file}
\SetKwData{BLOCKSIZE}{block size}
$\texttt{"fLaC"} \rightarrow$ \WRITE 4 bytes\;
\hyperref[flac:write_placeholder_blocks]{write placeholder STREAMINFO metadata block}\;
write PADDING metadata block\;
initialize stream's MD5 sum\;
\While{PCM frames remain}{
  take \BLOCKSIZE PCM frames from the input\;
  \hyperref[flac:update_md5_w]{update the stream's MD5 sum with that PCM data}\;
  \hyperref[flac:encode_frame]{encode a FLAC frame from PCM frames using the given encoding parameters}\;
  update STREAMINFO's values from the FLAC frame\;
}
return to the start of the file and rewrite the STREAMINFO metadata block\;
\EALGORITHM
\begin{figure}[h]
\includegraphics{figures/flac/stream3.pdf}
\end{figure}
\par
\noindent
All of the fields in the FLAC stream are big-endian.

\clearpage

\subsection{Writing Placeholder Metadata Blocks}
\label{flac:write_placeholder_blocks}
\ALGORITHM{input stream's attributes, a default block size}{1 or more metadata blocks to the FLAC file stream}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SAMPLERATE}{sample rate}
\SetKwData{CHANNELS}{channel count}
\SetKwData{BPS}{bits per sample}
$0 \rightarrow$ \WRITE 1 unsigned bit\tcc*[r]{is last block}
$0 \rightarrow$ \WRITE 7 unsigned bits\tcc*[r]{STREAMINFO type}
$34 \rightarrow$ \WRITE 24 unsigned bits\tcc*[r]{STREAMINFO size}
$\BLOCKSIZE \rightarrow$ \WRITE 16 unsigned bits\tcc*[r]{minimum block size}
$\BLOCKSIZE \rightarrow$ \WRITE 16 unsigned bits\tcc*[r]{maximum block size}
$0 \rightarrow$ \WRITE 24 unsigned bits\tcc*[r]{minimum frame size}
$0 \rightarrow$ \WRITE 24 unsigned bits\tcc*[r]{maximum frame size}
$\SAMPLERATE \rightarrow$ \WRITE 20 unsigned bits\;
$\CHANNELS - 1 \rightarrow$ \WRITE 3 unsigned bits\;
$\BPS - 1 \rightarrow$ \WRITE 5 unsigned bits\;
$0 \rightarrow$ \WRITE 36 unsigned bits\tcc*[r]{total PCM frames}
$0 \rightarrow$ \WRITE 16 bytes\tcc*[r]{stream's MD5 sum}
\BlankLine
\BlankLine
$1 \rightarrow$ \WRITE 1 unsigned bit\tcc*[r]{is last block}
$1 \rightarrow$ \WRITE 7 unsigned bits\tcc*[r]{PADDING type}
$4096 \rightarrow$ \WRITE 24 unsigned bits\tcc*[r]{PADDING size}
$0 \rightarrow$ \WRITE 4096 bytes\tcc*[r]{PADDING's data}
\EALGORITHM
\par
\noindent
PADDING can be some size other than 4096 bytes.
One simply wants to leave enough room for a VORBIS\_COMMENT block,
SEEKTABLE and so forth.
Other fields such as the minimum/maximum frame size
and the stream's final MD5 sum can't be known in advance;
we'll need to return to this block once encoding is finished
in order to populate them.
\begin{figure}[h]
\includegraphics{figures/flac/metadata.pdf}
\end{figure}


\clearpage

\subsection{Updating Stream MD5 Sum}
\label{flac:update_md5_w}
\ALGORITHM{the frame's signed PCM input samples\footnote{$channel_{c~i}$ indicates the $i$th sample in channel $c$}}{the stream's updated MD5 sum}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{CHANNELCOUNT}{channel count}
\SetKwData{CHANNEL}{channel}
\For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
  \For{$c \leftarrow 0$ \emph{\KwTo}\CHANNELCOUNT}{
    bytes $\leftarrow \text{\CHANNEL}_{c~i}$ as signed, little-endian bytes\;
    update stream's MD5 sum with bytes\;
  }
}
\Return stream's MD5 sum\;
\EALGORITHM
\par
\noindent
For example, given a 16 bits per sample stream with the signed sample values:
\begin{table}[h]
\begin{tabular}{r|rr}
$i$ & $\textsf{channel}_0$ & $\textsf{channel}_1$ \\
\hline
0 & 1 & -1 \\
1 & 2 & -2 \\
2 & 3 & -3 \\
\end{tabular}
\end{table}
\par
\noindent
are translated to the bytes:
\begin{table}[h]
\begin{tabular}{r|rr}
$i$ & $\textsf{channel}_0$ & $\textsf{channel}_1$ \\
\hline
0 & \texttt{01 00} & \texttt{FF FF} \\
1 & \texttt{02 00} & \texttt{FE FF} \\
2 & \texttt{03 00} & \texttt{FD FF} \\
\end{tabular}
\end{table}
\par
\noindent
and combined as:
\vskip .15in
\par
\noindent
\texttt{01 00 FF FF 02 00 FE FF 03 00 FD FF}
\vskip .15in
\par
\noindent
whose MD5 sum is:
\vskip .15in
\par
\noindent
\texttt{E7482f6462B27EE04EADC079291C79E9}
\vskip .25in
\par
This process is identical to the MD5 sum calculation performed
during FLAC decoding, but performed in the opposite order.

\clearpage

\subsection{Encoding a FLAC Frame}
\label{flac:encode_frame}
{\relsize{-1}
\ALGORITHM{up to ``block size'' number of PCM frames, encoding parameters}{a single FLAC frame}
\SetKw{AND}{and}
\SetKw{OR}{or}
\SetKwData{CHANNELCOUNT}{channel count}
\SetKwData{BPS}{bits per sample}
\SetKwData{CHANNEL}{channel}
\SetKwData{AVERAGE}{average}
\SetKwData{DIFFERENCE}{difference}
\SetKwData{LEFTS}{left subframe}
\SetKwData{RIGHTS}{right subframe}
\SetKwData{AVGS}{average subframe}
\SetKwData{DIFFS}{difference subframe}
\SetKwData{IBITS}{independent}
\SetKwData{LDBITS}{left/difference}
\SetKwData{DRBITS}{difference/right}
\SetKwData{ADBITS}{average/difference}
\SetKwData{SUBFRAME}{subframe}
\SetKwFunction{LEN}{len}
\SetKwFunction{MIN}{min}
\SetKwFunction{BUILDSUBFRAME}{build subframe}
\SetKwFunction{CALCMIDSIDE}{calculate mid-side}
\eIf{$\CHANNELCOUNT = 2$ \AND (try mid-side \OR try adaptive mid-side)}{
  \begin{tabular}{rcl}
    $(\AVERAGE~,~\DIFFERENCE)$ & $\leftarrow$ & \hyperref[flac:calc_midside]{calculate mid-side of $\text{\CHANNEL}_0$ and $\text{\CHANNEL}_1$} \\
    \LEFTS & $\leftarrow$ & \hyperref[flac:encode_subframe]{encode $\text{\CHANNEL}_0$ as subframe at $\BPS$} \\
    \RIGHTS & $\leftarrow$ & \hyperref[flac:encode_subframe]{encode $\text{\CHANNEL}_1$ as subframe at $\BPS$} \\
    \AVGS & $\leftarrow$ &  \hyperref[flac:encode_subframe]{encode $\text{\AVERAGE}$ as subframe at $\BPS$} \\
    \DIFFS & $\leftarrow$ & \hyperref[flac:encode_subframe]{encode $\text{\DIFFERENCE}$ as subframe at $(\BPS + 1)$} \\
    \IBITS & $\leftarrow$ & $\LEN(\LEFTS) + \LEN(\RIGHTS)$ \\
    \LDBITS & $\leftarrow$ & $\LEN(\LEFTS) + \LEN(\DIFFS)$ \\
    \DRBITS & $\leftarrow$ & $\LEN(\DIFFS) + \LEN(\RIGHTS)$ \\
    \ADBITS & $\leftarrow$ & $\LEN(\AVGS) + \LEN(\DIFFS)$ \\
  \end{tabular}\;
  \BlankLine
  \uIf{try mid-side}{
    \uIf{$\IBITS < \MIN(\LDBITS~,~\DRBITS~,~\ADBITS)$}{
      \hyperref[flac:write_frame_header]{write frame header with channel assignment \texttt{0x1}}\;
      write \LEFTS\;
      write \RIGHTS\;
    }
    \uElseIf{$\LDBITS < \MIN(\DRBITS~,~\ADBITS)$}{
      \hyperref[flac:write_frame_header]{write frame header with channel assignment \texttt{0x8}}\;
      write \LEFTS\;
      write \DIFFS\;
    }
    \uElseIf{$\DRBITS < \ADBITS$}{
      \hyperref[flac:write_frame_header]{write frame header with channel assignment \texttt{0x9}}\;
      write \DIFFS\;
      write \RIGHTS\;
    }
    \Else{
      \hyperref[flac:write_frame_header]{write frame header with channel assignment \texttt{0xA}}\;
      write \AVGS\;
      write \DIFFS\;
    }
  }\uElseIf{$\IBITS < \ADBITS$}{
    \hyperref[flac:write_frame_header]{write frame header with channel assignment \texttt{0x1}}\;
    write \LEFTS\;
    write \RIGHTS\;
  }
  \Else{
    \hyperref[flac:write_frame_header]{write frame header with channel assignment \texttt{0xA}}\;
    write \AVGS\;
    write \DIFFS\;
  }
}(\tcc*[f]{store subframes independently}){
  \hyperref[flac:write_frame_header]{write frame header with channel assignment $\CHANNELCOUNT - 1$}\;
  \For{$c \leftarrow 0$ \emph{\KwTo}\CHANNELCOUNT}{
    $\text{\SUBFRAME}_c \leftarrow $ \hyperref[flac:encode_subframe]{encode $\text{\CHANNEL}_c$ as subframe at $\BPS$}\;
    write $\text{\SUBFRAME}_c$\;
  }
}
byte align the stream\;
\hyperref[flac:calculate_crc16]{write frame's CRC-16 checksum}\;
\EALGORITHM
}

\clearpage

\subsubsection{Calculating Mid-Side}
\label{flac:calc_midside}
\ALGORITHM{block size, 2 channels of PCM data}{2 channels stored as average / difference}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{CHANNEL}{channel}
\SetKwData{AVERAGE}{average}
\SetKwData{DIFFERENCE}{difference}
\For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
  $\text{\AVERAGE}_i \leftarrow \lfloor (\text{\CHANNEL}_{0~i} + \text{\CHANNEL}_{1~i}) \div 2\rfloor$\;
  $\text{\DIFFERENCE}_i \leftarrow \text{\CHANNEL}_{0~i} - \text{\CHANNEL}_{1~i}$\;
}
\Return $(\text{\AVERAGE}~,~\text{\DIFFERENCE})$\;
\EALGORITHM
\begin{align*}
\intertext{For example, given the input samples:}
\textsf{channel}_{0~0} &\leftarrow 10 \\
\textsf{channel}_{1~0} &\leftarrow 15
\intertext{Our average and difference samples are:}
\textsf{average}_0 &\leftarrow \left\lfloor\frac{10 + 15}{2}\right\rfloor = 12 \\
\textsf{difference}_0 &\leftarrow 10 - 15 = -5
\intertext{Note that the \textsf{difference} channel is identical
for left-difference, difference-right and mid-side channel assignments.
For example, when recombined from left-difference\footnotemark:}
\textsf{sample}_0 &\leftarrow 10 \\
\textsf{sample}_1 &\leftarrow 10 - (-5) = 15
\intertext{difference-right:}
\textsf{sample}_0 &\leftarrow -5 + 15 = 10 \\
\textsf{sample}_1 &\leftarrow 15
\intertext{and mid-side:}
\textsf{sample}_0 &\leftarrow \lfloor(((12 \times 2) + (-5 \bmod 2)) + -5) \div 2\rfloor  = \lfloor((24 + 1 - 5) \div 2\rfloor = 10 \\
\textsf{sample}_1 &\leftarrow \lfloor(((12 \times 2) + (-5 \bmod 2)) - -5) \div 2\rfloor =  \lfloor((24 + 1 + 5) \div 2\rfloor = 15
\end{align*}
\footnotetext{See the recombining subframes algorithms on page
\pageref{flac:recombine_subframes}.}

\clearpage

\subsubsection{Writing Frame Header}
\label{flac:write_frame_header}
{\relsize{-1}
\ALGORITHM{the frame's channel assignment, the input stream's parameters}{a FLAC frame header}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SAMPLERATE}{sample rate}
\SetKwData{FRAMENUMBER}{frame number}
\SetKwData{EBLOCKSIZE}{encoded block size}
\SetKwData{ESAMPLERATE}{encoded sample rate}
\SetKwData{EBPS}{encoded bits per sample}
\SetKwData{ASSIGNMENT}{channel assignment}
\SetKwData{CRC}{CRC-8}
\SetKw{OR}{or}
$\texttt{0x3FFE} \rightarrow$ \WRITE 14 unsigned bits\tcc*[r]{sync code}
$0 \rightarrow$ \WRITE 1 unsigned bit\;
$0 \rightarrow$ \WRITE 1 unsigned bit\tcc*[r]{blocking strategy}
$\EBLOCKSIZE \rightarrow$ \WRITE 4 unsigned bits\;
$\ESAMPLERATE \rightarrow$ \WRITE 4 unsigned bits\;
$\ASSIGNMENT \rightarrow$ \WRITE 4 unsigned bits\;
$\EBPS \rightarrow$ \WRITE 3 unsigned bits\;
$0 \rightarrow$ \WRITE 1 unsigned bit\;
$\FRAMENUMBER \rightarrow$ \WRITE \hyperref[flac:write_utf8]{as UTF-8 encoded value}\;
\uIf{$\EBLOCKSIZE = 6$}{
  $(\BLOCKSIZE - 1) \rightarrow$ \WRITE 8 unsigned bits\;
}
\ElseIf{$\EBLOCKSIZE = 7$}{
  $\BLOCKSIZE - 1 \rightarrow$ \WRITE 16 unsigned bits\;
}
\uIf{$\ESAMPLERATE = 12$}{
  $\SAMPLERATE \div 1000 \rightarrow$ \WRITE 8 unsigned bits\;
}
\uElseIf{$\ESAMPLERATE = 13$}{
  $\SAMPLERATE \rightarrow$ \WRITE 16 unsigned bits\;
}
\ElseIf{$\ESAMPLERATE = 14$}{
  $\SAMPLERATE \div 10 \rightarrow$ \WRITE 16 unsigned bits\;
}
$\CRC \leftarrow$ \hyperref[flac:calculate_crc8]{calculate frame header's CRC-8}\;
$\CRC \rightarrow$ \WRITE 8 unsigned bits\;
\EALGORITHM
}

\subsubsection{Encoding Block Size}
{\relsize{-1}
\ALGORITHM{block size in samples}{encoded block size as 4 bit value}
\SetKwData{BLOCKSIZE}{block size}
\Switch{\BLOCKSIZE}{
\lCase{192}{\Return 1}\;
\lCase{256}{\Return 8}\;
\lCase{512}{\Return 9}\;
\lCase{576}{\Return 2}\;
\lCase{1024}{\Return 10}\;
\lCase{1152}{\Return 3}\;
\lCase{2048}{\Return 11}\;
\lCase{2304}{\Return 4}\;
\lCase{4096}{\Return 12}\;
\lCase{4608}{\Return 5}\;
\lCase{8192}{\Return 13}\;
\lCase{16384}{\Return 14}\;
\lCase{32768}{\Return 15}\;
\Other{
  \lIf{$\BLOCKSIZE \leq 256$}{\Return 6}\;
  \lElseIf{$\BLOCKSIZE \leq 65536$}{\Return 7}\;
  \lElse{\Return 0}
}
}
\EALGORITHM
}

\clearpage

\subsubsection{Encoding Sample Rate}
{\relsize{-1}
\ALGORITHM{sample rate in Hz}{encoded sample rate as 4 bit value}
\SetKw{AND}{and}
\SetKwData{SAMPLERATE}{sample rate}
\Switch{\SAMPLERATE}{
\lCase{8000}{\Return 4}\;
\lCase{16000}{\Return 5}\;
\lCase{22050}{\Return 6}\;
\lCase{24000}{\Return 7}\;
\lCase{32000}{\Return 8}\;
\lCase{44100}{\Return 9}\;
\lCase{48000}{\Return 10}\;
\lCase{88200}{\Return 1}\;
\lCase{96000}{\Return 11}\;
\lCase{176400}{\Return 2}\;
\lCase{192000}{\Return 3}\;
\Other{
  \lIf{$(\SAMPLERATE \bmod 1000 = 0)$ \AND $(\SAMPLERATE \leq 255000)$}{\Return 12}\;
  \lElseIf{$(\SAMPLERATE \bmod 10 = 0)$ \AND $(\SAMPLERATE \leq 655350)$}{\Return 14}\;
  \lElseIf{$\SAMPLERATE \leq 65535$}{\Return 13}\;
  \lElse{\Return 0}
}
}
\EALGORITHM
}
\subsubsection{Encoding Bits Per Sample}
{\relsize{-1}
\ALGORITHM{bits per sample}{encoded bits per sample as 3 bit value}
\SetKwData{BPS}{bits per sample}
\Switch{\BPS}{
\lCase{8}{\Return 1}\;
\lCase{12}{\Return 2}\;
\lCase{16}{\Return 4}\;
\lCase{20}{\Return 5}\;
\lCase{24}{\Return 6}\;
\lOther{\Return 0}\;
}
\EALGORITHM
}
\begin{figure}[h]
\includegraphics{figures/flac/frames.pdf}
\end{figure}

\clearpage

\subsubsection{Encoding UTF-8 Frame Number}
\label{flac:write_utf8}
{\relsize{-1}
\ALGORITHM{value as unsigned integer}{1 or more UTF-8 bytes}
\SetKwData{VALUE}{value}
\SetKwData{TOTALBYTES}{total bytes}
\SetKwData{SHIFT}{shift}
\eIf{$\VALUE \leq 127$}{
  $\VALUE \rightarrow$ \WRITE 8 unsigned bits\;
}{
  \uIf{$\VALUE \leq 2047$}{
    $\TOTALBYTES \leftarrow 2$\;
  }
  \uElseIf{$\VALUE \leq 65535$}{
    $\TOTALBYTES \leftarrow 3$\;
  }
  \uElseIf{$\VALUE \leq 2097151$}{
    $\TOTALBYTES \leftarrow 4$\;
  }
  \uElseIf{$\VALUE \leq 67108863$}{
    $\TOTALBYTES \leftarrow 5$\;
  }
  \ElseIf{$\VALUE \leq 2147483647$}{
    $\TOTALBYTES \leftarrow 6$\;
  }
  $\SHIFT \leftarrow (\TOTALBYTES - 1) \times 6$\;
  $\TOTALBYTES \rightarrow$ \WUNARY with stop bit 0\;
  $\lfloor \text{\VALUE} \div 2 ^ \text{\SHIFT} \rfloor \rightarrow$ \WRITE $(7 - \TOTALBYTES)$ unsigned bits\tcc*[r]{initial value}
  $\SHIFT \leftarrow \SHIFT - 6$\;
  \While{$\SHIFT \geq 0$}{
    $2 \rightarrow$ \WRITE 2 unsigned bits\tcc*[r]{continuation header}
    $\lfloor \VALUE \div 2 ^ \text{\SHIFT} \rfloor \bmod 64 \rightarrow$ \WRITE 6 unsigned bits\tcc*[r]{continuation bits}
    $\SHIFT \leftarrow \SHIFT - 6$\;
  }
}
\EALGORITHM
}
\par
\noindent
For example, encoding the frame number 4228 in UTF-8:
\par
\noindent
\begin{wrapfigure}[10]{r}{2.375in}
\includegraphics{figures/flac/utf8.pdf}
\end{wrapfigure}
\begin{align*}
\textsf{total bytes} &\leftarrow 3 \\
\textsf{shift} &\leftarrow 12 \\
& 3 \rightarrow \textbf{write unary} \text{ with stop bit 1} \\
& 1 \rightarrow \textbf{write} \text{ in 4 unsigned bits} \\
\textsf{shift} &\leftarrow 12 - 6 = 6 \\
& 2 \rightarrow \textbf{write} \text{ in 2 unsigned bits} \\
& 2 \rightarrow \textbf{write} \text{ in 6 unsigned bits} \\
\textsf{shift} &\leftarrow 6 - 6 = 0 \\
& 2 \rightarrow \textbf{write} \text{ in 2 unsigned bits} \\
& 4 \rightarrow \textbf{write} \text{ in 6 unsigned bits}
\end{align*}

\clearpage

\subsubsection{Calculating CRC-8}
\label{flac:calculate_crc8}
Given a header byte and previous CRC-8 checksum,
or 0 as an initial value:
\begin{equation*}
\text{checksum}_i = \text{CRC8}(byte\xor\text{checksum}_{i - 1})
\end{equation*}
\begin{table}[h]
{\relsize{-3}\ttfamily
\begin{tabular}{|r||r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|}
\hline
 & 0x?0 & 0x?1 & 0x?2 & 0x?3 & 0x?4 & 0x?5 & 0x?6 & 0x?7 & 0x?8 & 0x?9 & 0x?A & 0x?B & 0x?C & 0x?D & 0x?E & 0x?F \\
\hline
0x0? & 0x00 & 0x07 & 0x0E & 0x09 & 0x1C & 0x1B & 0x12 & 0x15 & 0x38 & 0x3F & 0x36 & 0x31 & 0x24 & 0x23 & 0x2A & 0x2D \\
0x1? & 0x70 & 0x77 & 0x7E & 0x79 & 0x6C & 0x6B & 0x62 & 0x65 & 0x48 & 0x4F & 0x46 & 0x41 & 0x54 & 0x53 & 0x5A & 0x5D \\
0x2? & 0xE0 & 0xE7 & 0xEE & 0xE9 & 0xFC & 0xFB & 0xF2 & 0xF5 & 0xD8 & 0xDF & 0xD6 & 0xD1 & 0xC4 & 0xC3 & 0xCA & 0xCD \\
0x3? & 0x90 & 0x97 & 0x9E & 0x99 & 0x8C & 0x8B & 0x82 & 0x85 & 0xA8 & 0xAF & 0xA6 & 0xA1 & 0xB4 & 0xB3 & 0xBA & 0xBD \\
0x4? & 0xC7 & 0xC0 & 0xC9 & 0xCE & 0xDB & 0xDC & 0xD5 & 0xD2 & 0xFF & 0xF8 & 0xF1 & 0xF6 & 0xE3 & 0xE4 & 0xED & 0xEA \\
0x5? & 0xB7 & 0xB0 & 0xB9 & 0xBE & 0xAB & 0xAC & 0xA5 & 0xA2 & 0x8F & 0x88 & 0x81 & 0x86 & 0x93 & 0x94 & 0x9D & 0x9A \\
0x6? & 0x27 & 0x20 & 0x29 & 0x2E & 0x3B & 0x3C & 0x35 & 0x32 & 0x1F & 0x18 & 0x11 & 0x16 & 0x03 & 0x04 & 0x0D & 0x0A \\
0x7? & 0x57 & 0x50 & 0x59 & 0x5E & 0x4B & 0x4C & 0x45 & 0x42 & 0x6F & 0x68 & 0x61 & 0x66 & 0x73 & 0x74 & 0x7D & 0x7A \\
0x8? & 0x89 & 0x8E & 0x87 & 0x80 & 0x95 & 0x92 & 0x9B & 0x9C & 0xB1 & 0xB6 & 0xBF & 0xB8 & 0xAD & 0xAA & 0xA3 & 0xA4 \\
0x9? & 0xF9 & 0xFE & 0xF7 & 0xF0 & 0xE5 & 0xE2 & 0xEB & 0xEC & 0xC1 & 0xC6 & 0xCF & 0xC8 & 0xDD & 0xDA & 0xD3 & 0xD4 \\
0xA? & 0x69 & 0x6E & 0x67 & 0x60 & 0x75 & 0x72 & 0x7B & 0x7C & 0x51 & 0x56 & 0x5F & 0x58 & 0x4D & 0x4A & 0x43 & 0x44 \\
0xB? & 0x19 & 0x1E & 0x17 & 0x10 & 0x05 & 0x02 & 0x0B & 0x0C & 0x21 & 0x26 & 0x2F & 0x28 & 0x3D & 0x3A & 0x33 & 0x34 \\
0xC? & 0x4E & 0x49 & 0x40 & 0x47 & 0x52 & 0x55 & 0x5C & 0x5B & 0x76 & 0x71 & 0x78 & 0x7F & 0x6A & 0x6D & 0x64 & 0x63 \\
0xD? & 0x3E & 0x39 & 0x30 & 0x37 & 0x22 & 0x25 & 0x2C & 0x2B & 0x06 & 0x01 & 0x08 & 0x0F & 0x1A & 0x1D & 0x14 & 0x13 \\
0xE? & 0xAE & 0xA9 & 0xA0 & 0xA7 & 0xB2 & 0xB5 & 0xBC & 0xBB & 0x96 & 0x91 & 0x98 & 0x9F & 0x8A & 0x8D & 0x84 & 0x83 \\
0xF? & 0xDE & 0xD9 & 0xD0 & 0xD7 & 0xC2 & 0xC5 & 0xCC & 0xCB & 0xE6 & 0xE1 & 0xE8 & 0xEF & 0xFA & 0xFD & 0xF4 & 0xF3 \\
\hline
\end{tabular}
}
\end{table}

\subsubsection{Frame Header Encoding Example}
Given a frame header with the following attributes:
\begin{table}[h]
\begin{tabular}{rl}
block size : & 4096 PCM frames \\
sample rate : & 44100 Hz \\
channel assignment : & 1 (2 channels stored independently) \\
bits per sample : & 16 \\
frame number : & 0
\end{tabular}
\end{table}
\par
\noindent
we generate the following frame header bytes:
\begin{figure}[h]
\includegraphics{figures/flac/header-example.pdf}
\end{figure}
\par
\noindent
Note how the CRC-8 is calculated from the preceding 5 header bytes:
\begin{align*}
\text{checksum}_0 = \text{CRC8}(\texttt{FF}\xor\texttt{00}) = \texttt{F3} & &
\text{checksum}_3 = \text{CRC8}(\texttt{18}\xor\texttt{E6}) = \texttt{F4} \\
\text{checksum}_1 = \text{CRC8}(\texttt{F8}\xor\texttt{F3}) = \texttt{31} & &
\text{checksum}_4 = \text{CRC8}(\texttt{00}\xor\texttt{F4}) = \texttt{C2} \\
\text{checksum}_2 = \text{CRC8}(\texttt{C9}\xor\texttt{31}) = \texttt{E6} \\
\end{align*}

\clearpage

\subsection{Encoding a FLAC Subframe}
\label{flac:encode_subframe}
{\relsize{-1}
\ALGORITHM{block size, signed subframe samples, subframe's bits per sample}{a FLAC subframe}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SAMPLE}{sample}
\SetKwData{WASTEDBPS}{wasted BPS}
\SetKwData{BPS}{subframe's BPS}
\SetKwData{CONSTANT}{CONSTANT subframe}
\SetKwData{FIXED}{FIXED subframe}
\SetKwData{VERBATIM}{VERBATIM subframe}
\SetKwData{LPCPARAMS}{LPC parameters}
\SetKwData{LPC}{LPC subframe}
\SetKwFunction{LEN}{len}
\SetKwFunction{MIN}{min}
\eIf{all samples are the same}{
  \Return \hyperref[flac:encode_constant_subframe]{\CONSTANT using $\text{\SAMPLE}_0$}\;
}{
  $\WASTEDBPS \leftarrow$ \hyperref[flac:calculate_wasted_bps]{calculate wasted bits per sample for $\text{\SAMPLE}$}\;
  \If{$\WASTEDBPS > 0$}{
    \For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
      $\text{\SAMPLE}_i \leftarrow \text{\SAMPLE}_i \div 2 ^ \text{\WASTEDBPS}$\;
    }
    $\BPS \leftarrow \BPS - \WASTEDBPS$\;
  }
  $\VERBATIM \leftarrow$ \hyperref[flac:encode_verbatim_subframe]{build VERBATIM subframe from \SAMPLE}\;
  \BlankLine
  $\FIXED \leftarrow$ \hyperref[flac:encode_fixed_subframe]{build FIXED subframe from \SAMPLE}\;
  \BlankLine
  \eIf(\tcc*[f]{from encoding parameters}){maximum LPC order $ > 0$}{
    $\LPCPARAMS \leftarrow$ \hyperref[flac:compute_lpc_params]{compute best LPC parameters from \SAMPLE}\;
    $\LPC \leftarrow$ \hyperref[flac:encode_lpc_subframe]{build LPC subframe from \LPCPARAMS}\;
    \BlankLine
    \uIf{$\LEN(\VERBATIM) \leq \MIN(\LEN(\LPC)~,~\LEN(\FIXED))$}{
      \Return \VERBATIM\;
    }
    \uElseIf{$\LEN(\FIXED) \leq \LEN(\LPC)$}{
      \Return \FIXED\;
    }
    \Else{
      \Return \LPC\;
    }
  }{
    \eIf{$\LEN(\VERBATIM) \leq \LEN(\FIXED)$}{
      \Return \VERBATIM\;
    }{
      \Return \FIXED\;
    }
  }
}
\EALGORITHM
}

\subsubsection{Calculating Wasted Bits Per Sample}
\label{flac:calculate_wasted_bps}
{\relsize{-1}
  \ALGORITHM{a list of signed PCM samples}{an unsigned integer}
  \SetKwData{WASTEDBPS}{wasted bps}
  \SetKwData{SAMPLE}{sample}
  \SetKwData{BLOCKSIZE}{block size}
  \SetKwFunction{MIN}{min}
  \SetKwFunction{WASTED}{wasted}
  $\text{\WASTEDBPS} \leftarrow \infty$\tcc*[r]{maximum unsigned integer}
  \For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
    $\text{\WASTEDBPS} \leftarrow \MIN(\WASTED(\text{\SAMPLE}_i)~,~\text{\WASTEDBPS})$\;
  }
  \eIf(\tcc*[f]{all samples are 0}){$\WASTEDBPS = \infty$}{
    \Return 0\;
  }{
    \Return \WASTEDBPS\;
  }
  \EALGORITHM
  where the \texttt{wasted} function is defined as:
  \begin{equation*}
    \texttt{wasted}(x) =
    \begin{cases}
      \infty & \text{if } x = 0 \\
      0 & \text{if } x \bmod 2 = 1 \\
      1 + \texttt{wasted}(x \div 2) & \text{if } x \bmod 2 = 0 \\
    \end{cases}
  \end{equation*}
}

\clearpage

\subsection{Encoding a CONSTANT Subframe}
\label{flac:encode_constant_subframe}
{\relsize{-1}
\ALGORITHM{signed subframe sample, subframe's bits per sample}{a CONSTANT subframe}
\SetKwData{SAMPLE}{sample}
\SetKwData{BPS}{subframe's BPS}
$0 \rightarrow$ \WRITE 1 unsigned bit\tcc*[r]{pad}
$0 \rightarrow$ \WRITE 6 unsigned bits\tcc*[r]{subframe type}
$0 \rightarrow$ \WRITE 1 unsigned bit\tcc*[r]{no wasted BPS}
$\text{\SAMPLE} \rightarrow$ \WRITE $(\BPS)$ signed bits\;
\Return a CONSTANT subframe\;
\EALGORITHM
}
\begin{figure}[h]
  \includegraphics{figures/flac/constant.pdf}
\end{figure}

\subsection{Encoding a VERBATIM Subframe}
\label{flac:encode_verbatim_subframe}
{\relsize{-1}
\ALGORITHM{signed subframe samples, subframe's bits per sample}{a VERBATIM subframe}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SAMPLE}{sample}
\SetKwData{BPS}{subframe's BPS}
$0 \rightarrow$ \WRITE 1 unsigned bit\tcc*[r]{pad}
$1 \rightarrow$ \WRITE 6 unsigned bits\tcc*[r]{subframe type}
$0 \rightarrow$ \WRITE 1 unsigned bit\tcc*[r]{no wasted BPS}
\For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
  $\text{\SAMPLE}_i \rightarrow$ \WRITE $(\BPS)$ signed bits\;
}
\Return a VERBATIM subframe\;
\EALGORITHM
}
\begin{figure}[h]
  \includegraphics{figures/flac/verbatim.pdf}
\end{figure}

\clearpage

\subsection{Encoding a FIXED Subframe}
\label{flac:encode_fixed_subframe}
{\relsize{-1}
\ALGORITHM{signed subframe samples, subframe's bits per sample, wasted BPS}{a FIXED subframe}
\SetKwData{BPS}{subframe's BPS}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{RESIDUAL}{residual}
\SetKwData{SAMPLE}{sample}
\SetKwData{ERROR}{total error}
\SetKwData{ORDER}{order}
\SetKwData{WASTEDBPS}{wasted BPS}
\tcc{first decide which FIXED subframe order to use}
\For(\tcc*[f]{order 0}){$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
  $\text{\RESIDUAL}_{0~i} \leftarrow \text{\SAMPLE}_i$\;
}
$\text{\ERROR}_0 \leftarrow \overset{\BLOCKSIZE - 1}{\underset{i = 4}{\sum}}|\text{\RESIDUAL}_{0~i}|$\;
\BlankLine
\eIf{$\BLOCKSIZE > 4$}{
\For(\tcc*[f]{order 1-4}){$\ORDER \leftarrow 1$ \emph{\KwTo}5}{
  \For{$i \leftarrow 0$ \emph{\KwTo}$\BLOCKSIZE - \ORDER$}{
  $\text{\RESIDUAL}_{\ORDER~i} \leftarrow \text{\RESIDUAL}_{(\ORDER - 1)~(i + 1)} - \text{\RESIDUAL}_{(\ORDER - 1)~i}$\;
  }
  $\text{\ERROR}_{\ORDER} \leftarrow \overset{\BLOCKSIZE - \ORDER - 1}{\underset{i = 4 - \ORDER}{\sum}}|\text{\RESIDUAL}_{\ORDER~i}|$\;
}
\BlankLine
choose subframe \ORDER such that $\text{\ERROR}_{\ORDER}$ is smallest\;
}{
use subframe \ORDER 0\;
}
\BlankLine
\tcc{then return a FIXED subframe with that order}
$0 \rightarrow$ \WRITE 1 unsigned bit\tcc*[r]{pad}
$1 \rightarrow$ \WRITE 3 unsigned bits\tcc*[r]{subframe type}
$\text{\ORDER} \rightarrow$ \WRITE 3 unsigned bits\;
\eIf{$\WASTEDBPS > 0$}{
  $1 \rightarrow$ \WRITE 1 unsigned bit\;
  $(\text{\WASTEDBPS} - 1) \rightarrow$ \WUNARY with stop bit 1\;
}{
  $0 \rightarrow$ \WRITE 1 unsigned bit\;
}
\For(\tcc*[f]{warm-up samples}){$i \leftarrow 0$ \emph{\KwTo}\ORDER}{
  $\text{\SAMPLE}_i \rightarrow$ \WRITE $(\BPS)$ signed bits\;
}
\hyperref[flac:write_residual_block]{write encoded residual block based on $\text{\RESIDUAL}_{\ORDER}$'s signed values}\;
\BlankLine
\Return a FIXED subframe\;
\EALGORITHM
}
\begin{figure}[h]
  \includegraphics{figures/flac/fixed.pdf}
\end{figure}

\clearpage

\subsubsection{FIXED Subframe Calculation Example}

Given the subframe samples: \texttt{18, 20, 26, 24, 24, 23, 21, 24, 23, 20}:
\begin{table}[h]
\begin{tabular}{r|r|r|r|r|r}
& \textsf{order} 0 & \textsf{order} 1 & \textsf{order} 2 & \textsf{order} 3 & \textsf{order} 4 \\
\hline
$\textsf{residual}_{o~0}$ & \texttt{\color{gray}18} & \texttt{\color{gray}2} & \texttt{\color{gray}4} & \texttt{\color{gray}-12} & \texttt{22} \\
$\textsf{residual}_{o~1}$ & \texttt{\color{gray}20} & \texttt{\color{gray}6} & \texttt{\color{gray}-8} & \texttt{10} & \texttt{-13} \\
$\textsf{residual}_{o~2}$ & \texttt{\color{gray}26} & \texttt{\color{gray}-2} & \texttt{2} & \texttt{-3} & \texttt{3} \\
$\textsf{residual}_{o~3}$ & \texttt{\color{gray}24} & \texttt{0} & \texttt{-1} & \texttt{0} & \texttt{6} \\
$\textsf{residual}_{o~4}$ & \texttt{24} & \texttt{-1} & \texttt{-1} & \texttt{6} & \texttt{-15} \\
$\textsf{residual}_{o~5}$ & \texttt{23} & \texttt{-2} & \texttt{5} & \texttt{-9} & \texttt{11} \\
$\textsf{residual}_{o~6}$ & \texttt{21} & \texttt{3} & \texttt{-4} & \texttt{2} \\
$\textsf{residual}_{o~7}$ & \texttt{24} & \texttt{-1} & \texttt{-2} \\
$\textsf{residual}_{o~8}$ & \texttt{23} & \texttt{-3} \\
$\textsf{residual}_{o~9}$ & \texttt{20} \\
\hline
$\textsf{total error}_{o}$ & \texttt{135} & \texttt{10} & \texttt{15} & \texttt{30} & \texttt{70} \\
\end{tabular}
\end{table}
\par
\noindent
Note how the total number of residuals equals the
total number of samples minus the subframe's order,
to account for the warm-up samples.
Also note that if you remove the first $4 - \textsf{order}$ residuals
and sum the absolute value of the remaining residuals,
the result is the \VAR{total error} value
used when calculating the best FIXED subframe order.

\clearpage

\subsection{Residual Encoding}
\label{flac:write_residual_block}
{\relsize{-1}
\ALGORITHM{a set of signed residual values, the subframe's block size and predictor order, minimum and maximum partition order from encoding parameters}{an encoded block of residuals}
\SetKwData{ORDER}{predictor order}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{PAORDER}{partition order}
\SetKwData{PSIZE}{partition size}
\SetKwData{PSUM}{partition sum}
\SetKwData{RICE}{Rice}
\SetKwData{CODING}{coding method}
\SetKwData{UNSIGNED}{unsigned}
\SetKwData{PARTITION}{partition}
\SetKwData{PLEN}{partition length}
\SetKwData{MSB}{MSB}
\SetKwData{LSB}{LSB}
\SetKwFunction{SUM}{sum}
\SetKwFunction{MAX}{max}
\SetKw{BREAK}{break}
\tcc{calculate best partition order and Rice parameters for that order}
\For{$o \leftarrow \text{minimum partition order}$ \emph{\KwTo}(maximum partition order + 1)}{
  \eIf{$(\BLOCKSIZE \bmod 2^{o}) = 0$}{
    $(\text{\RICE}_o~,~\text{\PARTITION}_o~,~\text{\PSIZE}_o) \leftarrow$ \hyperref[flac:write_residual_partition]{encode residual partition(s) with order $o$}\;
  }{
    \BREAK\;
  }
}
\BlankLine
choose partition order $o$ such that $\PSIZE_{o}$ is smallest\;
\BlankLine
\eIf{$\MAX(\text{\RICE}_{o}) > 14$}{
  $\CODING \leftarrow 1$\;
}{
  $\CODING \leftarrow 0$\;
}
\BlankLine
\tcc{write 1 or more residual partitions to residual block}
$\CODING \rightarrow$ \WRITE 2 unsigned bits\;
$o \rightarrow$ \WRITE 4 unsigned bits\;
\For{$p \leftarrow 0$ \emph{\KwTo}$2 ^ {o}$} {
  \eIf{$\CODING = 0$}{
    $\text{\RICE}_{o~p} \rightarrow$ \WRITE 4 unsigned bits\;
  }{
    $\text{\RICE}_{o~p} \rightarrow$ \WRITE 5 unsigned bits\;
  }
  \BlankLine
  \eIf{$p = 0$}{
    $\text{\PLEN}_{o~0} \leftarrow \BLOCKSIZE \div 2 ^ {o} - \ORDER$\;
  }{
    $\text{\PLEN}_{o~p} \leftarrow \BLOCKSIZE \div 2 ^ {o}$\;
  }
  \BlankLine
  \For(\tcc*[f]{write residual partition}){$i \leftarrow 0$ \emph{\KwTo}$\text{\PLEN}_{o~p}$}{
    \eIf{$\text{\PARTITION}_{o~p~i} \geq 0$}{
      $\text{\UNSIGNED}_i \leftarrow \text{\PARTITION}_{o~p~i} \times 2$\;
    }{
    $\text{\UNSIGNED}_i \leftarrow (-\text{\PARTITION}_{o~p~i} - 1) \times 2 + 1$\;
    }
    $\text{\MSB}_i \leftarrow \lfloor \text{\UNSIGNED}_i \div 2 ^ \text{\RICE} \rfloor$\;
    $\text{\LSB}_i \leftarrow \text{\UNSIGNED}_i - (\text{\MSB}_i \times 2 ^ \text{\RICE})$\;
    $\text{\MSB}_i \rightarrow$ \WUNARY with stop bit 1\;
    $\text{\LSB}_i \rightarrow$ \WRITE $\text{\RICE}$ unsigned bits\;
  }
}
\Return encoded residual block\;
\EALGORITHM
}

\clearpage

\subsubsection{Encoding Partitions}
\label{flac:write_residual_partition}
{\relsize{-1}
\ALGORITHM{partition order $o$, predictor order, residual values, block size, maximum Rice parameter}{Rice parameter, residual partitions, total estimated size}
\SetKwData{ORDER}{predictor order}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{PSIZE}{partition size}
\SetKwData{PLEN}{plength}
\SetKwData{PARTITION}{partition}
\SetKwData{RESIDUAL}{residual}
\SetKwData{PSUM}{partition sum}
\SetKwData{RICE}{Rice}
\SetKwData{MAXPARAMETER}{maximum Rice parameter}
\SetKw{BREAK}{break}
$\text{\PSIZE}_o \leftarrow 0$\;
\BlankLine
\For(\tcc*[f]{split residuals into partitions}){$p \leftarrow 0$ \emph{\KwTo}$2 ^ {o}$}{
  \eIf{$p = 0$}{
    $\text{\PLEN}_{o~0} \leftarrow \BLOCKSIZE \div 2 ^ {o} - \ORDER$\;
  }{
    $\text{\PLEN}_{o~p} \leftarrow \BLOCKSIZE \div 2 ^ {o}$\;
  }
  $\text{\PARTITION}_{o~p} \leftarrow$ get next $\text{\PLEN}_{o~p}$ values from \RESIDUAL\;
  \BlankLine
  $\text{\PSUM}_{o~p} \leftarrow \overset{\text{\PLEN}_{o~p} - 1}{\underset{i = 0}{\sum}} |\text{\PARTITION}_{o~p~i}|$\;
  \BlankLine
  $\text{\RICE}_{o~p} \leftarrow 0$\tcc*[r]{compute best Rice parameter for partition}
  \While{$\text{\PLEN}_{o~p} \times 2 ^ {\text{\RICE}_{o~p}} < \text{\PSUM}_{o~p}$}{
    \eIf{$\text{\RICE}_{o~p} < \MAXPARAMETER$}{
      $\text{\RICE}_{o~p} \leftarrow \text{\RICE}_{o~p} + 1$\;
    }{
      \BREAK\;
    }
  }
  \BlankLine
  \eIf(\tcc*[f]{add estimated size of partition to total size}){$\text{\RICE}_{o~p} > 0$}{
    $\text{\PSIZE}_o \leftarrow \text{\PSIZE}_o + 4 + ((1 + \text{\RICE}_{o~p}) \times \text{\PLEN}_{o~p}) + \left\lfloor\frac{\text{\PSUM}_{o~p}}{2 ^ {\text{\RICE}_{o~p} - 1}}\right\rfloor - \left\lfloor\frac{\text{\PLEN}_{o~p}}{2}\right\rfloor$\;
  }{
    $\text{\PSIZE}_o \leftarrow \text{\PSIZE}_o + 4 + \text{\PLEN}_{o~p} + (\text{\PSUM}_{o~p} \times 2) - \left\lfloor\frac{\text{\PLEN}_{o~p}}{2}\right\rfloor$\;
  }
}
\BlankLine
\Return $(\text{\RICE}_o~,~\text{\PARTITION}_o~,~\text{\PSIZE}_o)$\;
\EALGORITHM
}

\begin{figure}[h]
\includegraphics{figures/flac/residual.pdf}
\end{figure}

\clearpage

\subsubsection{Residual Encoding Example}
Given a block size of 10 and the residuals \texttt{2, 6, -2, 0, -1, -2, 3, -1, -3}:
\begin{align*}
\intertext{for $\text{partition order} = 0$:}
\textsf{partition}_{0~0} &\leftarrow \texttt{[2, 6, -2, 0, -1, -2, 3, -1, -3]} \\
\text{partition sum}_{0~0} &\leftarrow 2 + 6 + 2 + 0 + 1 + 2 + 3 + 1 + 3 = 20 \\
\textsf{Rice}_{0~0} &\leftarrow 1~~(9 \times 2 ^ 0 < 20~,~9 \times 2 ^ 1 < 20~,~9 \times 2 ^ 2 > 20) \\
\intertext{which is encoded to $encoded~residuals_{0~0}$:
\newline
\includegraphics{figures/flac/residual-example1.pdf}}
\intertext{for partition order (porder) = 1:}
\textsf{partition}_{1~0} &\leftarrow \texttt{[2, 6, -2, 0]} \\
\text{partition sum}_{1~0} &\leftarrow 2 + 6 + 2 + 0 = 10 \\
\textsf{Rice}_{1~0} &\leftarrow 1~~(4 \times 2 ^ 0 < 10~,~4 \times 2 ^ 1 < 10~,~4 \times 2 ^ 2 > 10) \\
\intertext{which is encoded to $encoded~residuals_{1~0}$:
\newline
\includegraphics{figures/flac/residual-example2.pdf}}
\textsf{partition}_{1~1} &\leftarrow \texttt{[-1, -2, 3, -1, -3]} \\
\text{partition sum}_{1~1} &\leftarrow 1 + 2 + 3 + 1 + 3 = 10 \\
\textsf{Rice}_{1~1} &\leftarrow 1~~(4 \times 2 ^ 0 < 10~,~4 \times 2 ^ 1 < 10~,~4 \times 2 ^ 2 > 10) \\
\intertext{which is encoded to $encoded~residuals_{1~1}$:
\newline
\includegraphics{figures/flac/residual-example3.pdf}}
\end{align*}
\par
\noindent
Since partition order 0's 33 bits, + 4 bits for one partition header,
is smaller than partition order 1's 17 bits + 16 bits + 8 bits
for two partition headers, the ideal partition order for these residuals is 0.

\clearpage

The 33 bit partition is packaged into a complete residual block
in which:
\newline
\begin{tabular}{rl}
$partition_{0~0}$ & $\leftarrow$ \texttt{2, 6, -2, 0, -1, -2, 3, -1, -3} \\
$Rice_{0~0}$ & $\leftarrow 1$ \\
partition order & $\leftarrow 0$ \\
coding method & $\leftarrow 0$ \\
\end{tabular}
\begin{figure}[h]
\includegraphics{figures/flac/residual-example4.pdf}
\end{figure}
\par
Finally, we package these residuals into a FIXED subframe in which:
\newline
\begin{tabular}{rl}
predictor order & $\leftarrow 1$ \\
$\text{warm-up sample}_0$ & $\leftarrow $ 18 \\
\end{tabular}
\begin{figure}[h]
\includegraphics{figures/flac/residual-example5.pdf}
\end{figure}
\par
\noindent
Reducing our 10, 16-bit samples from a total of 160 bits
down to only 67 bits - or about 40\% of their original size.

\clearpage

\subsection{Computing Best LPC Parameters}
\label{flac:compute_lpc_params}
{\relsize{-1}
\ALGORITHM{signed subframe samples, encoding parameters}{LPC parameters}
\SetKwFunction{LEN}{len}
\SetKw{AND}{and}
\SetKw{NOT}{not}
\SetKwData{SAMPLE}{sample}
\SetKwData{WINDOWED}{windowed}
\SetKwData{AUTOCORRELATIONS}{autocorrelation}
\SetKwData{LPCOEFFS}{LP coefficients}
\SetKwData{ERRORS}{error}
\SetKwData{ORDER}{predictor order}
\SetKwData{QLPCOEFFS}{QLP coefficients}
\SetKwData{QLPPRECISION}{QLP precision}
\SetKwData{QLPSHIFT}{QLP shift needed}
\SetKwData{BESTLPCPARAMS}{best LPC parameters}
\SetKwData{LPCPARAMS}{LPC parameters}
\SetKwData{LPCDATA}{LPC subframe data}
\tcc{windowed sample count equals subframe sample count}
$\WINDOWED \leftarrow$ \hyperref[flac:window]{window \SAMPLE}\;
\BlankLine
\tcc{autocorrelation value count equals the maximum LPC order + 1}
$\AUTOCORRELATIONS \leftarrow$ \hyperref[flac:autocorrelate]{autocorrelate \WINDOWED}\;
\BlankLine
\eIf{$\LEN(\AUTOCORRELATIONS) > 1$ \AND \AUTOCORRELATIONS aren't all 0.0}{
  $(\LPCOEFFS~,~\ERRORS)\leftarrow$ \hyperref[flac:compute_lp_coeffs]{compute LP coefficients from \AUTOCORRELATIONS}\;
  \BlankLine
  \eIf(\tcc*[f]{from encoding parameters}){\NOT exhaustive model search}{
    \tcc{estimate which set of LP coefficients is the smallest
      and return those}
    $o \leftarrow$ \hyperref[flac:estimate_best_order]{estimate best order from \ERRORS, sample count and bits per sample}\;
    $\text{\LPCPARAMS}_o \leftarrow$ \hyperref[flac:quantize_lp_coeffs]{quantize \LPCOEFFS at order $o$}\;
    \Return $\text{\LPCPARAMS}_o$\;
  }{
    \tcc{build a complete LPC subframe from each set of LP coefficients
    and return the parameters of the one which is smallest}
    \For{$o \leftarrow 1$ \emph{\KwTo}maximum LPC order + 1}{
      $\text{\LPCPARAMS}_o \leftarrow$ \hyperref[flac:quantize_lp_coeffs]{quantize \LPCOEFFS at order $o$}\;
      $\text{\LPCDATA}_o \leftarrow$ \hyperref[flac:encode_lpc_subframe]{build LPC subframe from $\text{\LPCPARAMS}_o$}\;
    }
    choose predictor order $o$ whose $\text{\LPCDATA}_o$ block is smallest\;
    \BlankLine
    \Return $\text{\LPCPARAMS}_o$\;
  }
}{
  \tcc{all samples are 0, so return very basic coefficients}
  \Return $\text{\LPCPARAMS} \leftarrow \left\lbrace\begin{tabular}{rcl}
  \ORDER & $\leftarrow$ & 0 \\
  \QLPCOEFFS & $\leftarrow$ & \texttt{[0]} \\
  \QLPPRECISION & $\leftarrow$ & 2 \\
  \QLPSHIFT & $\leftarrow$ & 0 \\
  \end{tabular}\right.$\;
}
\EALGORITHM
}

\clearpage


\subsubsection{Windowing the Input Samples}
\label{flac:window}
\ALGORITHM{a list of signed input sample integers}{a list of signed windowed samples as floats}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SAMPLE}{sample}
\SetKwData{WINDOWED}{windowed}
\SetKwFunction{TUKEY}{tukey}
\For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
  $\text{\WINDOWED}_i = \text{\SAMPLE}_i \times \TUKEY(i)$\;
}
\Return \WINDOWED\;
\EALGORITHM
\par
\noindent
The \VAR{Tukey} function is defined as:
\begin{equation*}
\texttt{tukey}(n) =
\begin{cases}
\frac{1}{2} \times \left[1 + cos\left(\pi \times \left(\frac{2 \times n}{\alpha \times (N - 1)} - 1 \right)\right)\right] & \text{ if } 0 \leq n \leq \frac{\alpha \times (N - 1)}{2} \\
1 & \text{ if } \frac{\alpha \times (N - 1)}{2} \leq n \leq (N - 1) \times (1 - \frac{\alpha}{2}) \\
\frac{1}{2} \times \left[1 + cos\left(\pi \times \left(\frac{2 \times n}{\alpha \times (N - 1)} - \frac{2}{\alpha} + 1 \right)\right)\right] & \text{ if } (N - 1) \times (1 - \frac{\alpha}{2}) \leq n \leq (N - 1) \\
\end{cases}
\end{equation*}
\par
\noindent
Where $N$ is the total number of samples and $\alpha$ is $\nicefrac{1}{2}$.
\par
\noindent
\begin{wrapfigure}[5]{r}{3in}
\includegraphics{figures/flac/tukey.pdf}
\end{wrapfigure}
\begin{table}[h]
\begin{tabular}{r|r|r|r}
$i$ & $\textsf{sample}_i$ & $\texttt{tukey}(i)$ & $\textsf{windowed}_i$ \\
\hline
0 & 18 & 0 & 0.0 \\
1 & 20 & .41 & 8.2 \\
2 & 26 & .97 & 25.2 \\
3 & 24 & 1 & 24.0 \\
4 & 24 & 1 & 24.0 \\
5 & 23 & 1 & 23.0 \\
6 & 21 & 1 & 21.0 \\
7 & 24 & .97 & 23.3 \\
8 & 23 & .41 & 9.4 \\
9 & 20 & 0 & 0.0 \\
\end{tabular}
\end{table}

\clearpage

\subsubsection{Performing Autocorrelation}
\label{flac:autocorrelate}
\ALGORITHM{a list of signed windowed samples, the maximum LPC order}{a list of signed autocorrelation values}
\SetKwData{MAXLPCORDER}{max LPC order}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{WINDOWED}{windowed}
\SetKwData{AUTOCORRELATED}{autocorrelated}
\For{$l \leftarrow 0$ \emph{\KwTo}$(\text{\MAXLPCORDER} + 1)$}{
  $\text{\AUTOCORRELATED}_{l} = \overset{\text{\BLOCKSIZE} - l - 1}{\underset{i = 0}{\sum}}\text{\WINDOWED}_i \times \text{\WINDOWED}_{i + l}$\;
}
\EALGORITHM
For example, given the windowed samples:
\texttt{0.0, 8.2, 25.2, 24.0, 24.0, 23.0, 21.0, 23.3, 9.4, 0.0}
and a maximum LPC order of 3:
\begin{figure}[h]
\subfloat{
  {\relsize{-2}
    \begin{tabular}{rrrrr}
      \texttt{0.0} & $\times$ & \texttt{0.0} & $=$ & \texttt{0.00} \\
      \texttt{8.2} & $\times$ & \texttt{8.2} & $=$ & \texttt{67.24} \\
      \texttt{25.2} & $\times$ & \texttt{25.2} & $=$ & \texttt{635.04} \\
      \texttt{24.0} & $\times$ & \texttt{24.0} & $=$ & \texttt{576.00} \\
      \texttt{24.0} & $\times$ & \texttt{24.0} & $=$ & \texttt{576.00} \\
      \texttt{23.0} & $\times$ & \texttt{23.0} & $=$ & \texttt{529.00} \\
      \texttt{21.0} & $\times$ & \texttt{21.0} & $=$ & \texttt{441.00} \\
      \texttt{23.3} & $\times$ & \texttt{23.3} & $=$ & \texttt{542.89} \\
      \texttt{9.4} & $\times$ & \texttt{9.4} & $=$ & \texttt{88.36} \\
      \texttt{0.0} & $\times$ & \texttt{0.0} & $=$ & \texttt{0.00} \\
      \hline
      \multicolumn{3}{r}{$\textsf{autocorrelated}_0$} & $=$ & \texttt{3455.53} \\
    \end{tabular}
  }
}
\includegraphics{figures/flac/lag0.pdf}

\subfloat{
  {\relsize{-2}
    \begin{tabular}{rrrrr}
      \texttt{0.0} & $\times$ & \texttt{8.2} & $=$ & \texttt{0.00} \\
      \texttt{8.2} & $\times$ & \texttt{25.2} & $=$ & \texttt{206.64} \\
      \texttt{25.2} & $\times$ & \texttt{24.0} & $=$ & \texttt{604.80} \\
      \texttt{24.0} & $\times$ & \texttt{24.0} & $=$ & \texttt{576.00} \\
      \texttt{24.0} & $\times$ & \texttt{23.0} & $=$ & \texttt{552.00} \\
      \texttt{23.0} & $\times$ & \texttt{21.0} & $=$ & \texttt{483.00} \\
      \texttt{21.0} & $\times$ & \texttt{23.3} & $=$ & \texttt{489.30} \\
      \texttt{23.3} & $\times$ & \texttt{9.4} & $=$ & \texttt{219.02} \\
      \texttt{9.4} & $\times$ & \texttt{0.0} & $=$ & \texttt{0.00} \\
      \hline
      \multicolumn{3}{r}{$\textsf{autocorrelated}_1$} & $=$ & \texttt{3130.76} \\
    \end{tabular}
  }
}
\includegraphics{figures/flac/lag1.pdf}

\subfloat{
  {\relsize{-2}
    \begin{tabular}{rrrrr}
      \texttt{0.0} & $\times$ & \texttt{25.2} & $=$ & \texttt{0.00} \\
      \texttt{8.2} & $\times$ & \texttt{24.0} & $=$ & \texttt{196.80} \\
      \texttt{25.2} & $\times$ & \texttt{24.0} & $=$ & \texttt{604.80} \\
      \texttt{24.0} & $\times$ & \texttt{23.0} & $=$ & \texttt{552.00} \\
      \texttt{24.0} & $\times$ & \texttt{21.0} & $=$ & \texttt{504.00} \\
      \texttt{23.0} & $\times$ & \texttt{23.3} & $=$ & \texttt{535.90} \\
      \texttt{21.0} & $\times$ & \texttt{9.4} & $=$ & \texttt{197.40} \\
      \texttt{23.3} & $\times$ & \texttt{0.0} & $=$ & \texttt{0.00} \\
      \hline
      \multicolumn{3}{r}{$\textsf{autocorrelated}_2$} & $=$ & \texttt{2590.90} \\
    \end{tabular}
  }
}
\includegraphics{figures/flac/lag2.pdf}

\subfloat{
  {\relsize{-2}
    \begin{tabular}{rrrrr}
      \texttt{0.0} & $\times$ & \texttt{24.0} & $=$ & \texttt{0.00} \\
      \texttt{8.2} & $\times$ & \texttt{24.0} & $=$ & \texttt{196.80} \\
      \texttt{25.2} & $\times$ & \texttt{23.0} & $=$ & \texttt{579.60} \\
      \texttt{24.0} & $\times$ & \texttt{21.0} & $=$ & \texttt{504.00} \\
      \texttt{24.0} & $\times$ & \texttt{23.3} & $=$ & \texttt{559.20} \\
      \texttt{23.0} & $\times$ & \texttt{9.4} & $=$ & \texttt{216.20} \\
      \texttt{21.0} & $\times$ & \texttt{0.0} & $=$ & \texttt{0.00} \\
      \hline
      \multicolumn{3}{r}{$\textsf{autocorrelated}_3$} & $=$ & \texttt{2055.80} \\
    \end{tabular}
  }
}
\includegraphics{figures/flac/lag3.pdf}
\end{figure}
\par
\noindent
Note that the total number of autocorrelation values equals
the maximum LPC order + 1.

\clearpage

\subsubsection{LP Coefficient Calculation}
\label{flac:compute_lp_coeffs}
{\relsize{-1}
\ALGORITHM{a list of autocorrelation floats, the maximum LPC order}{a list of LP coefficient lists, a list of error values}
\SetKwData{MAXLPCORDER}{max LPC order}
\SetKwData{LPCOEFF}{LP coefficient}
\SetKwData{ERROR}{error}
\SetKwData{AUTOCORRELATION}{autocorrelated}
\begin{tabular}{rcl}
$\kappa_0$ &$\leftarrow$ & $ \AUTOCORRELATION_1 \div \AUTOCORRELATION_0$ \\
$\LPCOEFF_{0~0}$ &$\leftarrow$ & $ \kappa_0$ \\
$\ERROR_0$ &$\leftarrow$ & $ \AUTOCORRELATION_0 \times (1 - {\kappa_0} ^ 2)$ \\
\end{tabular}\;
\For{$i \leftarrow 1$ \emph{\KwTo}\MAXLPCORDER}{
  \tcc{"zip" all of the previous row's LP coefficients
    \newline
    and the reversed autocorrelation values from 1 to i + 1
    \newline
    into ($c$,$a$) pairs
    \newline
    $q_i$ is $\AUTOCORRELATION_{i + 1}$ minus the sum of those multiplied ($c$,$a$) pairs}
  $q_i \leftarrow \AUTOCORRELATION_{i + 1}$\;
  \For{$j \leftarrow 0$ \emph{\KwTo}i}{
    $q_i \leftarrow q_i - (\LPCOEFF_{(i - 1)~j} \times \AUTOCORRELATION_{i - j})$\;
  }
  \BlankLine
  \tcc{"zip" all of the previous row's LP coefficients
    \newline
    and the previous row's LP coefficients reversed
    into ($c$,$r$) pairs}
  $\kappa_i = q_i \div \ERROR_{i - 1}$\;
  \For{$j \leftarrow 0$ \emph{\KwTo}i}{
    \tcc{then build a new coefficient list of $c - (\kappa_i * r)$ for each ($c$,$r$) pair}
    $\LPCOEFF_{i~j} \leftarrow \LPCOEFF_{(i - 1)~j} - (\kappa_i \times \LPCOEFF_{(i - 1)~(i - j - 1)})$\;
  }
  $\text{\LPCOEFF}_{i~i} \leftarrow \kappa_i$\tcc*[r]{and append $\kappa_i$ as the final coefficient in that list}
  \BlankLine
  $\ERROR_i \leftarrow \ERROR_{i - 1} \times (1 - {\kappa_i}^2)$\;
}
\Return $(\LPCOEFF~,~\ERROR)$\;
\EALGORITHM
}
\par
\noindent
{\relsize{-1}
Given a maximum LPC order of 3 and 4 autocorrelation values:
\begin{align*}
\kappa_0 &\leftarrow \textsf{autocorrelation}_1 \div \textsf{autocorrelation}_0 \\
\textsf{LP coefficient}_{0~0} &\leftarrow \kappa_0 \\
\textsf{error}_0 &\leftarrow \textsf{autocorrelation}_0 \times (1 - {\kappa_0} ^ 2) \\
i &= 1 \\
q_1 &\leftarrow \textsf{autocorrelation}_2 - (\textsf{LP coefficient}_{0~0} \times \textsf{autocorrelation}_{1}) \\
\kappa_1 &\leftarrow q_1 \div error_0 \\
\textsf{LP coefficient}_{1~0} &\leftarrow \textsf{LP coefficient}_{0~0} - (\kappa_1 \times \textsf{LP coefficient}_{0~0}) \\
\textsf{LP coefficient}_{1~1} &\leftarrow \kappa_1 \\
\textsf{error}_1 &\leftarrow \textsf{error}_0 \times (1 - {\kappa_1} ^ 2) \\
i &= 2 \\
q_2 &\leftarrow \textsf{autocorrelation}_3 - (\textsf{LP coefficient}_{1~0} \times \textsf{autocorrelation}_{2} + \textsf{LP coefficient}_{1~1} \times \textsf{autocorrelation}_{1}) \\
\kappa_2 &\leftarrow q_2 \div \textsf{error}_1 \\
\textsf{LP coefficient}_{2~0} &\leftarrow \textsf{LP coefficient}_{1~0} - (\kappa_2 \times \textsf{LP coefficient}_{1~1}) \\
\textsf{LP coefficient}_{2~1} &\leftarrow \textsf{LP coefficient}_{1~1} - (\kappa_2 \times \textsf{LP coefficient}_{1~0}) \\
\textsf{LP coefficient}_{2~2} &\leftarrow \kappa_2 \\
\textsf{error}_2 &\leftarrow \textsf{error}_1 \times (1 - {\kappa_2} ^ 2) \\
\end{align*}
}

\clearpage

Performing this calculation with the autocorrelation values
\texttt{3455.53, 3130.76, 2590.90, 2055.80}:
{\relsize{-1}
\begin{align*}
\kappa_0 &\leftarrow 3130.76 \div 3455.53 = 0.906 \\
\textsf{LP coefficient}_{0~0} &\leftarrow 0.906 \\
\textsf{error}_0 &\leftarrow 3455.53 \times (1 - {0.906} ^ 2) = 619.107 \\
i &= 1 \\
q_1 &\leftarrow 2590.90 - (0.906 \times 3130.76) = -245.569 \\
\kappa_1 &\leftarrow -245.569 \div 619.107 = -0.397 \\
\textsf{LP coefficient}_{1~0} &\leftarrow 0.906 - (-0.397 \times 0.906) = 1.266 \\
\textsf{LP coefficient}_{1~1} &\leftarrow -0.397 \\
\textsf{error}_1 &\leftarrow 619.107 \times (1 - {-0.397} ^ 2) = 521.530 \\
i &= 2 \\
q_2 &\leftarrow 2055.80 - (1.266 \times 2590.90 + -0.397 \times 3130.76) = 18.632 \\
\kappa_2 &\leftarrow 18.632 \div 521.53 = 0.036 \\
\textsf{LP coefficient}_{2~0} &\leftarrow 1.266 - (0.036 \times -0.397) = 1.28 \\
\textsf{LP coefficient}_{2~1} &\leftarrow -0.397 - (0.036 \times 1.266) = -0.443 \\
\textsf{LP coefficient}_{2~2} &\leftarrow 0.036 \\
\textsf{error}_2 &\leftarrow 521.53 \times (1 - {0.036} ^ 2) = 520.854 \\
\end{align*}
}
\par
\noindent
With the final result of:
\begin{table}[h]
\begin{tabular}{r|rrr}
order & \multicolumn{3}{c}{\textsf{LP coefficients}} \\
\hline
1 & \texttt{0.906} \\
2 & \texttt{1.266} & \texttt{-0.397} \\
3 & \texttt{1.280} & \texttt{-0.443} & \texttt{0.036} \\
\end{tabular}
\end{table}
\par
\noindent
and \textsf{error} values: \texttt{619.107, 521.530, 520.854}

\clearpage

\subsubsection{Estimating Best Order}
\label{flac:estimate_best_order}
\ALGORITHM{floating point error values, block size, bits per sample,\newline QLP precision and maximum LPC order from encoding parameters}{the best estimated order value to use}
\SetKwData{ORDER}{predictor order}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{MAXLPCORDER}{max LPC order}
\SetKwData{HEADERBITS}{header bits}
\SetKwData{BSIZE}{best subframe bits}
\SetKwData{QLPPREC}{QLP precision}
\SetKwData{BPS}{bits per sample}
\SetKwData{BPR}{bits per residual}
\SetKwData{ERROR}{error}
\SetKwData{ERRORSCALE}{error scale}
\SetKwData{SUBFRAMEBITS}{subframe bits}
\SetKwFunction{MAX}{max}
\ERRORSCALE $\leftarrow \frac{\log_e(2) ^ 2}{\text{\BLOCKSIZE} \times 2}$\;
\BSIZE $\leftarrow$ maximum floating point\;
\For{$i \leftarrow 0$ \emph{\KwTo}\MAXLPCORDER}{
  $o \leftarrow i + 1$\tcc*[r]{current order}
  \uIf{$\text{\ERROR}_i > 0.0$}{
    $\text{\HEADERBITS}_o \leftarrow \ORDER \times (\text{\BPS} + \text{\QLPPREC})$\;
    $\text{\BPR}_o \leftarrow \MAX\left(\frac{\log_e(\text{\ERROR}_i \times \text{\ERRORSCALE})}{\log_e(2) \times 2}~,~0.0\right)$\;
    $\text{\SUBFRAMEBITS}_o \leftarrow \text{\HEADERBITS}_o + \text{\BPR}_o \times (\text{\BLOCKSIZE} - \text{\ORDER})$\;
  }
  \ElseIf{$\text{\ERROR}_i = 0.0$}{
    \Return $o$\;
  }
}
\BlankLine
\Return $o$ such as $\text{\SUBFRAMEBITS}_o$ is smallest\;
\EALGORITHM

\clearpage

\subsubsection{Quantizing LP Coefficients}
\label{flac:quantize_lp_coeffs}
\ALGORITHM{LP coefficients, a positive order value,\newline QLP precision from encoding parameters}{QLP coefficients as a list of integers,\newline QLP shift needed as a non-negative integer}
\SetKwData{LPCOEFF}{LP coefficient}
\SetKwData{QLPSHIFT}{QLP shift}
\SetKwData{QLPPREC}{QLP precision}
\SetKwData{ORDER}{order}
\SetKwData{QLPMAX}{QLP max}
\SetKwData{QLPMIN}{QLP min}
\SetKwData{ERROR}{error}
\SetKwData{QLPCOEFF}{QLP coefficient}
\SetKwFunction{MIN}{min}
\SetKwFunction{MAX}{max}
\SetKwFunction{ROUND}{round}
$l \leftarrow $ maximum $|c|$ for $c$ in $\text{\LPCOEFF}_{(\ORDER - 1)~0}$ to $\text{\LPCOEFF}_{(\ORDER - 1)~\ORDER}$\;
$\QLPSHIFT \leftarrow (\text{\QLPPREC} - 1) - (\lfloor \log_2(l) \rfloor - 1) - 1$\;
\uIf(\tcc*[f]{must fit into signed 5 bit field}){$\QLPSHIFT > 2 ^ 4 - 1$}{
  $\QLPSHIFT \leftarrow 2 ^ 4 - 1$\;
}
\ElseIf{$\QLPSHIFT < -(2 ^ 4)$}{
  \Return error\tcc*[r]{too much shift required for coefficients}
}

\BlankLine
\tcc{QLP min and max are the smallest and largest QLP coefficients that fit in a signed field that's "QLP precision" bits wide}
$\QLPMAX \leftarrow 2 ^ {\text{\QLPPREC} - 1} - 1$\;
$\QLPMIN \leftarrow -(2 ^ {\text{\QLPPREC} - 1})$\;
$\ERROR \leftarrow 0.0$\;
\eIf{$\text{\QLPSHIFT} \geq 0$}{
  \For{$i \leftarrow 0$ \emph{\KwTo}\ORDER}{
    $\ERROR \leftarrow \ERROR + \text{\LPCOEFF}_{\ORDER - 1~i} \times 2 ^ \text{\QLPSHIFT}$\;
    $\text{\QLPCOEFF}_i \leftarrow \MIN(\MAX(\ROUND(\ERROR)~,~\text{\QLPMIN})~,~\text{\QLPMAX})$\;
    $\ERROR \leftarrow \ERROR - \text{\QLPCOEFF}_i$\;
  }
  \Return $(\QLPCOEFF~,~\QLPSHIFT)$\;
}(\tcc*[f]{negative shifts are not allowed, so shrink coefficients}){
  \For{$i \leftarrow 0$ \emph{\KwTo}\ORDER}{
    $\ERROR \leftarrow \ERROR + \text{\LPCOEFF}_{\ORDER - 1~i} \div 2 ^ {-\text{\QLPSHIFT}}$\;
    $\text{\QLPCOEFF}_i \leftarrow \MIN(\MAX(\ROUND(\ERROR)~,~\text{\QLPMIN})~,~\text{\QLPMAX})$\;
    $\ERROR \leftarrow \ERROR - \text{\QLPCOEFF}_i$\;
  }
  \Return $(\QLPCOEFF~,~0)$\;
}
\EALGORITHM

\clearpage

For example, given the $\textsf{LP coefficient}_3$ \texttt{[1.280, -0.443, 0.036]},
an \textsf{order} of \texttt{3} and a \textsf{QLP precision} \texttt{12}:
\begin{align*}
l &\leftarrow 1.280 \\
\textsf{QLP shift} &\leftarrow 12 - \lfloor \log_2(1.280) \rfloor - 2 = 10 \\
\textsf{QLP max} &\leftarrow 2047 \\
\textsf{QLP min} &\leftarrow -2048 \\
\textsf{error} &\leftarrow 0.0 \\
i &= 0 \\
\textsf{error} &\leftarrow 0.0 + 1.280 \times 2 ^ {10} = 1310.72 \\
\textsf{QLP coefficient}_0 &\leftarrow 1311 \\
\textsf{error} &\leftarrow 1310.72 - 1311 = -0.28 \\
i &= 1 \\
\textsf{error} &\leftarrow -0.28 + -0.443 \times 2 ^ {10} = -453.912 \\
\textsf{QLP coefficient}_1 &\leftarrow -454 \\
\textsf{error} &\leftarrow -453.912 - -454 = 0.088 \\
i &= 2 \\
\textsf{error} &\leftarrow 0.088 + 0.036 \times 2 ^ {10} = 36.952 \\
\textsf{QLP coefficient}_2 &\leftarrow 37 \\
\textsf{error} &\leftarrow 36.952 - 37 = -0.048 \\
\end{align*}
\par
\noindent
Resulting in the QLP coefficients \texttt{1311, -454, 37}
and a QLP shift of \texttt{10}.
These values, in addition to QLP precision,
are inserted directly into a desired QLP subframe header
and are also used to calculate its residuals.

\clearpage

\subsection{Encoding an LPC Subframe}
\label{flac:encode_lpc_subframe}
\ALGORITHM{signed subframe samples, subframe order, QLP coefficients, QLP precision, QLP shift needed, subframe's bits per sample, wasted BPS}{an LPC subframe}
\SetKwData{ORDER}{predictor order}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{WASTEDBPS}{wasted BPS}
\SetKwData{BPS}{bits per sample}
\SetKwData{SAMPLE}{sample}
\SetKwData{RESIDUAL}{residual}
\SetKwData{QLPPREC}{QLP precision}
\SetKwData{QLPSHIFT}{QLP shift}
\SetKwData{QLPCOEFF}{QLP coefficient}
$0 \rightarrow$ \WRITE 1 unsigned bit\tcc*[r]{pad}
$1 \rightarrow$ \WRITE 1 unsigned bit\tcc*[r]{subframe type}
$(\text{\ORDER} - 1) \rightarrow$ \WRITE 5 unsigned bits\;
\eIf{$\WASTEDBPS > 0$}{
  $1 \rightarrow$ \WRITE 1 unsigned bit\;
  $(\text{\WASTEDBPS} - 1) \rightarrow$ \WUNARY with stop bit 1\;
}{
  $0 \rightarrow$ \WRITE 1 unsigned bit\;
}
\For(\tcc*[f]{warm-up samples}){$i \leftarrow 0$ \emph{\KwTo}\ORDER}{
  $\text{\SAMPLE}_i \rightarrow$ \WRITE $(\BPS)$ signed bits\;
}
$(\text{\QLPPREC} - 1) \rightarrow$ \WRITE 4 unsigned bits\;
$\text{\QLPSHIFT} \rightarrow$ \WRITE 5 signed bits\;
\For(\tcc*[f]{QLP coefficients}){$i \leftarrow 0$ \emph{\KwTo}\ORDER}{
  $\text{\QLPCOEFF}_i \rightarrow$ \WRITE $(\QLPPREC)$ signed bits\;
}
\BlankLine
\For(\tcc*[f]{calculate signed residuals}){$i \leftarrow 0$ \emph{\KwTo}$\BLOCKSIZE - \ORDER$}{
  $\text{\RESIDUAL}_i \leftarrow \text{\SAMPLE}_{i + \ORDER} - \left \lfloor \frac{\overset{\ORDER - 1}{\underset{j = 0}{\sum}} \text{\QLPCOEFF}_j \times \text{\SAMPLE}_{i + \ORDER - j - 1} }{2 ^ \text{\QLPSHIFT}} \right \rfloor$
}
write encoded residual block based on signed residual values\;
\Return LPC subframe\;
\EALGORITHM
\begin{figure}[h]
\includegraphics{figures/flac/lpc2.pdf}
\end{figure}

\clearpage

\subsubsection{LPC Subframe Residuals Calculation Example}
\begin{tabular}{rl}
\textsf{samples} : & \texttt{18, 20, 26, 24, 24, 23, 21, 24, 23, 20} \\
\textsf{order} : & \texttt{3} \\
\textsf{QLP precision} : &\texttt{12} \\
\textsf{QLP shift} : & \texttt{10} \\
\text{QLP coefficients} : & \texttt{1311, -454, 37} \\
\end{tabular}
\newline
\begin{align*}
\textsf{residual}_0 &\leftarrow 24 - \left\lfloor\frac{1311 \times 26 + -454 \times 20 + 37 \times 18}{2 ^ {10}}\right\rfloor = 24 - \left\lfloor\frac{25672}{1024}\right\rfloor = 24 - 25 = -1 \\
\textsf{residual}_1 &\leftarrow 24 - \left\lfloor\frac{1311 \times 24 + -454 \times 26 + 37 \times 20}{2 ^ {10}}\right\rfloor = 24 - \left\lfloor\frac{20400}{1024}\right\rfloor = 24 - 19 = 5 \\
\textsf{residual}_2 &\leftarrow 23 - \left\lfloor\frac{1311 \times 24 + -454 \times 24 + 37 \times 26}{2 ^ {10}}\right\rfloor = 23 - \left\lfloor\frac{21530}{1024}\right\rfloor = 23 - 21 = 2 \\
\textsf{residual}_3 &\leftarrow 21 - \left\lfloor\frac{1311 \times 23 + -454 \times 24 + 37 \times 24}{2 ^ {10}}\right\rfloor = 21 - \left\lfloor\frac{20145}{1024}\right\rfloor = 21 - 19 = 2 \\
\textsf{residual}_4 &\leftarrow 24 - \left\lfloor\frac{1311 \times 21 + -454 \times 23 + 37 \times 24}{2 ^ {10}}\right\rfloor = 24 - \left\lfloor\frac{17977}{1024}\right\rfloor = 24 - 17 = 7 \\
\textsf{residual}_5 &\leftarrow 23 - \left\lfloor\frac{1311 \times 24 + -454 \times 21 + 37 \times 23}{2 ^ {10}}\right\rfloor = 23 - \left\lfloor\frac{22781}{1024}\right\rfloor = 23 - 22 = 1 \\
\textsf{residual}_6 &\leftarrow 20 - \left\lfloor\frac{1311 \times 23 + -454 \times 24 + 37 \times 21}{2 ^ {10}}\right\rfloor = 20 - \left\lfloor\frac{20034}{1024}\right\rfloor = 20 - 19 = 1
\end{align*}
Leading to a final set of 7 residual values: \texttt{-1, 5, 2, 2, 7, 1, 1}.
Encoding them to a residual block, our final LPC subframe is:
\begin{figure}[h]
\includegraphics{figures/flac/lpc-parse2.pdf}
\end{figure}

\clearpage

\subsection{Calculating Frame CRC-16}
\label{flac:calculate_crc16}
CRC-16 is used to checksum the entire FLAC frame, including the header
and any padding bits after the final subframe.
Given a byte of input and the previous CRC-16 checksum,
or 0 as an initial value, the current checksum can be calculated as follows:
\begin{equation}
\text{checksum}_i = \texttt{CRC16}(byte\xor(\text{checksum}_{i - 1} \gg 8 ))\xor(\text{checksum}_{i - 1} \ll 8)
\end{equation}
\par
\noindent
and the checksum is always truncated to 16-bits.
\begin{table}[h]
{\relsize{-3}\ttfamily
\begin{tabular}{|r||r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|}
\hline
 & 0x?0 & 0x?1 & 0x?2 & 0x?3 & 0x?4 & 0x?5 & 0x?6 & 0x?7 & 0x?8 & 0x?9 & 0x?A & 0x?B & 0x?C & 0x?D & 0x?E & 0x?F \\
\hline
0x0? & 0000 & 8005 & 800f & 000a & 801b & 001e & 0014 & 8011 & 8033 & 0036 & 003c & 8039 & 0028 & 802d & 8027 & 0022 \\
0x1? & 8063 & 0066 & 006c & 8069 & 0078 & 807d & 8077 & 0072 & 0050 & 8055 & 805f & 005a & 804b & 004e & 0044 & 8041 \\
0x2? & 80c3 & 00c6 & 00cc & 80c9 & 00d8 & 80dd & 80d7 & 00d2 & 00f0 & 80f5 & 80ff & 00fa & 80eb & 00ee & 00e4 & 80e1 \\
0x3? & 00a0 & 80a5 & 80af & 00aa & 80bb & 00be & 00b4 & 80b1 & 8093 & 0096 & 009c & 8099 & 0088 & 808d & 8087 & 0082 \\
0x4? & 8183 & 0186 & 018c & 8189 & 0198 & 819d & 8197 & 0192 & 01b0 & 81b5 & 81bf & 01ba & 81ab & 01ae & 01a4 & 81a1 \\
0x5? & 01e0 & 81e5 & 81ef & 01ea & 81fb & 01fe & 01f4 & 81f1 & 81d3 & 01d6 & 01dc & 81d9 & 01c8 & 81cd & 81c7 & 01c2 \\
0x6? & 0140 & 8145 & 814f & 014a & 815b & 015e & 0154 & 8151 & 8173 & 0176 & 017c & 8179 & 0168 & 816d & 8167 & 0162 \\
0x7? & 8123 & 0126 & 012c & 8129 & 0138 & 813d & 8137 & 0132 & 0110 & 8115 & 811f & 011a & 810b & 010e & 0104 & 8101 \\
0x8? & 8303 & 0306 & 030c & 8309 & 0318 & 831d & 8317 & 0312 & 0330 & 8335 & 833f & 033a & 832b & 032e & 0324 & 8321 \\
0x9? & 0360 & 8365 & 836f & 036a & 837b & 037e & 0374 & 8371 & 8353 & 0356 & 035c & 8359 & 0348 & 834d & 8347 & 0342 \\
0xA? & 03c0 & 83c5 & 83cf & 03ca & 83db & 03de & 03d4 & 83d1 & 83f3 & 03f6 & 03fc & 83f9 & 03e8 & 83ed & 83e7 & 03e2 \\
0xB? & 83a3 & 03a6 & 03ac & 83a9 & 03b8 & 83bd & 83b7 & 03b2 & 0390 & 8395 & 839f & 039a & 838b & 038e & 0384 & 8381 \\
0xC? & 0280 & 8285 & 828f & 028a & 829b & 029e & 0294 & 8291 & 82b3 & 02b6 & 02bc & 82b9 & 02a8 & 82ad & 82a7 & 02a2 \\
0xD? & 82e3 & 02e6 & 02ec & 82e9 & 02f8 & 82fd & 82f7 & 02f2 & 02d0 & 82d5 & 82df & 02da & 82cb & 02ce & 02c4 & 82c1 \\
0xE? & 8243 & 0246 & 024c & 8249 & 0258 & 825d & 8257 & 0252 & 0270 & 8275 & 827f & 027a & 826b & 026e & 0264 & 8261 \\
0xF? & 0220 & 8225 & 822f & 022a & 823b & 023e & 0234 & 8231 & 8213 & 0216 & 021c & 8219 & 0208 & 820d & 8207 & 0202 \\
\hline
\end{tabular}
}
\end{table}
\par
\noindent
For example, given the frame bytes:
\texttt{FF F8 CC 1C 00 C0 EB 00 00 00 00 00 00 00 00},
the frame's CRC-16 can be calculated:
{\relsize{-2}
\begin{align*}
\CRCSIXTEEN{0}{0xFF}{0x0000}{0xFF}{0x0000}{0x0202} \\
\CRCSIXTEEN{1}{0xF8}{0x0202}{0xFA}{0x0200}{0x001C} \\
\CRCSIXTEEN{2}{0xCC}{0x001C}{0xCC}{0x1C00}{0x1EA8} \\
\CRCSIXTEEN{3}{0x1C}{0x1EA8}{0x02}{0xA800}{0x280F} \\
\CRCSIXTEEN{4}{0x00}{0x280F}{0x28}{0x0F00}{0x0FF0} \\
\CRCSIXTEEN{5}{0xC0}{0x0FF0}{0xCF}{0xF000}{0xF2A2} \\
\CRCSIXTEEN{6}{0xEB}{0xF2A2}{0x19}{0xA200}{0x2255} \\
\CRCSIXTEEN{7}{0x00}{0x2255}{0x22}{0x5500}{0x55CC} \\
\CRCSIXTEEN{8}{0x00}{0x55CC}{0x55}{0xCC00}{0xCDFE} \\
\CRCSIXTEEN{9}{0x00}{0xCDFE}{0xCD}{0xFE00}{0x7CAD} \\
\CRCSIXTEEN{10}{0x00}{0x7CAD}{0x7C}{0xAD00}{0x2C0B} \\
\CRCSIXTEEN{11}{0x00}{0x2C0B}{0x2C}{0x0B00}{0x8BEB} \\
\CRCSIXTEEN{12}{0x00}{0x8BEB}{0x8B}{0xEB00}{0xE83A} \\
\CRCSIXTEEN{13}{0x00}{0xE83A}{0xE8}{0x3A00}{0x3870} \\
\CRCSIXTEEN{14}{0x00}{0x3870}{0x38}{0x7000}{0xF093} \\
\intertext{Thus, the next two bytes after the final subframe should be
\texttt{0xF0} and \texttt{0x93}.
Again, when the checksum bytes are run through the checksumming procedure:}
\CRCSIXTEEN{15}{0xF0}{0xF093}{0x00}{0x9300}{0x9300} \\
\CRCSIXTEEN{16}{0x93}{0x9300}{0x00}{0x0000}{0x0000}
\end{align*}
the result will also always be 0, just as in the CRC-8.
}
