#!/usr/bin/python

#Audio Tools, a module and set of tools for manipulating audio data
#Copyright (C) 2007-2012  Brian Langenberger

#This program is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA


import sys
import os
import audiotools
import audiotools.ui
from audiotools.text import (USAGE_CD2TRACK,
                             OPT_VERBOSE,
                             OPT_CAT_EXTRACTION,
                             OPT_CAT_CD_LOOKUP,
                             OPT_CAT_METADATA,
                             OPT_TYPE,
                             OPT_QUALITY,
                             OPT_DIR,
                             OPT_FORMAT,
                             OPT_NO_MUSICBRAINZ,
                             OPT_NO_FREEDB,
                             OPT_INTERACTIVE_METADATA,
                             OPT_DEFAULT,
                             OPT_ALBUM_NUMBER,
                             OPT_ALBUM_TOTAL,
                             OPT_REPLAY_GAIN,
                             OPT_NO_REPLAY_GAIN,
                             LAB_AVAILABLE_COMPRESSION_TYPES,
                             ERR_NO_COMPRESSION_MODES,
                             ERR_UNSUPPORTED_COMPRESSION_MODE,
                             ERR_INVALID_CDDA,
                             ERR_NO_CDDA,
                             ERR_DUPLICATE_OUTPUT_FILE,
                             ERR_ENCODING_ERROR,
                             LAB_CD2TRACK_PROGRESS,
                             LAB_CD2TRACK_LOG)


if (__name__ == '__main__'):
    parser = audiotools.OptionParser(
        usage=USAGE_CD2TRACK,
        version="Python Audio Tools %s" % (audiotools.VERSION))

    parser.add_option(
        '-V', '--verbose',
        action='store',
        dest='verbosity',
        choices=audiotools.VERBOSITY_LEVELS,
        default=audiotools.DEFAULT_VERBOSITY,
        help=OPT_VERBOSE)

    parser.add_option(
        '-c', '--cdrom', action='store',
        type='string', dest='cdrom',
        default=audiotools.DEFAULT_CDROM)

    parser.add_option(
        '-s', '--speed', action='store',
        type='int', dest='speed')

    conversion = audiotools.OptionGroup(parser, OPT_CAT_EXTRACTION)

    conversion.add_option(
        '-t', '--type',
        action='store',
        dest='type',
        choices=audiotools.TYPE_MAP.keys(),
        default=audiotools.DEFAULT_TYPE,
        help=OPT_TYPE)

    conversion.add_option(
        '-q', '--quality',
        action='store',
        type='string',
        dest='quality',
        help=OPT_QUALITY)

    conversion.add_option(
        "-d", "--dir", action='store', default='.',
        dest='dir',
        help=OPT_DIR)

    conversion.add_option(
        '--format',
        action='store',
        type='string',
        default=None,
        dest='format',
        help=OPT_FORMAT)

    parser.add_option_group(conversion)

    lookup = audiotools.OptionGroup(parser, OPT_CAT_CD_LOOKUP)

    lookup.add_option(
        '--musicbrainz-server', action='store',
        type='string', dest='musicbrainz_server',
        default=audiotools.MUSICBRAINZ_SERVER,
        metavar='HOSTNAME')
    lookup.add_option(
        '--musicbrainz-port', action='store',
        type='int', dest='musicbrainz_port',
        default=audiotools.MUSICBRAINZ_PORT,
        metavar='PORT')
    lookup.add_option(
        '--no-musicbrainz', action='store_false',
        dest='use_musicbrainz',
        default=audiotools.MUSICBRAINZ_SERVICE,
        help=OPT_NO_MUSICBRAINZ)

    lookup.add_option(
        '--freedb-server', action='store',
        type='string', dest='freedb_server',
        default=audiotools.FREEDB_SERVER,
        metavar='HOSTNAME')
    lookup.add_option(
        '--freedb-port', action='store',
        type='int', dest='freedb_port',
        default=audiotools.FREEDB_PORT,
        metavar='PORT')
    lookup.add_option(
        '--no-freedb', action='store_false',
        dest='use_freedb',
        default=audiotools.FREEDB_SERVICE,
        help=OPT_NO_FREEDB)

    lookup.add_option(
        '-I', '--interactive',
        action='store_true',
        default=False,
        dest='interactive',
        help=OPT_INTERACTIVE_METADATA)

    lookup.add_option(
        '-D', '--default',
        dest='use_default', action='store_true', default=False,
        help=OPT_DEFAULT)

    parser.add_option_group(lookup)

    metadata = audiotools.OptionGroup(parser, OPT_CAT_METADATA)

    metadata.add_option(
        '--album-number',
        dest='album_number',
        action='store',
        type='int',
        default=0,
        help=OPT_ALBUM_NUMBER)

    metadata.add_option(
        '--album-total',
        dest='album_total',
        action='store',
        type='int',
        default=0,
        help=OPT_ALBUM_TOTAL)

    #if adding ReplayGain is a lossless process
    #(i.e. added as tags rather than modifying track data)
    #add_replay_gain should default to True
    #if not, add_replay_gain should default to False
    #which is which depends on the track type
    metadata.add_option(
        '--replay-gain',
        action='store_true',
        dest='add_replay_gain',
        help=OPT_REPLAY_GAIN)

    metadata.add_option(
        '--no-replay-gain',
        action='store_false',
        dest='add_replay_gain',
        help=OPT_NO_REPLAY_GAIN)

    parser.add_option_group(metadata)

    (options, args) = parser.parse_args()
    msg = audiotools.Messenger("cd2track", options)

    #ensure interactive mode is available, if selected
    if (options.interactive and (not audiotools.ui.AVAILABLE)):
        audiotools.ui.not_available_message(msg)
        sys.exit(1)

    #get the AudioFile class we are converted to
    AudioType = audiotools.TYPE_MAP[options.type]

    if (options.add_replay_gain is None):
        options.add_replay_gain = AudioType.lossless_replay_gain()

    #ensure the selected compression is compatible with that class
    if (options.quality == 'help'):
        if (len(AudioType.COMPRESSION_MODES) > 1):
            msg.info(LAB_AVAILABLE_COMPRESSION_TYPES % (AudioType.NAME))
            for mode in AudioType.COMPRESSION_MODES:
                msg.new_row()
                if (mode == audiotools.__default_quality__(AudioType.NAME)):
                    msg.output_column(msg.ansi(mode.decode('ascii'),
                                               [msg.BOLD,
                                                msg.UNDERLINE]), True)
                else:
                    msg.output_column(mode.decode('ascii'), True)
                if (mode in AudioType.COMPRESSION_DESCRIPTIONS):
                    msg.output_column(u" : ")
                else:
                    msg.output_column(u"   ")
                msg.output_column(
                    AudioType.COMPRESSION_DESCRIPTIONS.get(mode, u""))
            msg.info_rows()
        else:
            msg.error(ERR_NO_COMPRESSION_MODES % (AudioType.NAME))
        sys.exit(0)
    elif (options.quality is None):
        options.quality = audiotools.__default_quality__(AudioType.NAME)
    elif (options.quality not in AudioType.COMPRESSION_MODES):
        msg.error(ERR_UNSUPPORTED_COMPRESSION_MODE %
                  {"quality": options.quality,
                   "type": AudioType.NAME})
        sys.exit(1)

    quality = options.quality
    base_directory = options.dir

    try:
        cdda = audiotools.CDDA(options.cdrom, options.speed)
    except IOError, err:
        msg.error(unicode(err) + ERR_INVALID_CDDA)
        sys.exit(-1)

    if (len(cdda) == 0):
        msg.error(ERR_NO_CDDA)
        sys.exit(1)

    #use CDDA object to query metadata services for metadata choices
    metadata_choices = cdda.metadata_lookup(
        musicbrainz_server=options.musicbrainz_server,
        musicbrainz_port=options.musicbrainz_port,
        freedb_server=options.freedb_server,
        freedb_port=options.freedb_port,
        use_musicbrainz=options.use_musicbrainz,
        use_freedb=options.use_freedb)

    #update MetaData with command-line album-number/total, if given
    if (options.album_number != 0):
        for c in metadata_choices:
            for m in c:
                m.album_number = options.album_number

    if (options.album_total != 0):
        for c in metadata_choices:
            for m in c:
                m.album_total = options.album_total

    #decide which metadata to use to tag extracted tracks
    if (options.interactive):
        #pick choice using interactive widget
        metadata_widget = audiotools.ui.MetaDataFiller(metadata_choices)
        loop = audiotools.ui.urwid.MainLoop(
            metadata_widget,
            [('key', 'white', 'dark blue'),
             ('label', 'default,bold', 'default')],
            unhandled_input=metadata_widget.handle_text)
        loop.run()

        if (not metadata_widget.canceled):
            track_metadatas = dict([(m.track_number, m) for m in
                                    metadata_widget.populated_metadata()])
        else:
            sys.exit(0)
    else:
        if ((len(metadata_choices) == 1) or options.use_default):
            #use default choice
            track_metadatas = dict([(m.track_number, m) for m in
                                    metadata_choices[0]])
        else:
            #pick choice using raw stdin/stdout
            track_metadatas = \
                dict([(m.track_number, m) for m in
                      audiotools.ui.select_metadata(metadata_choices, msg)])

    #determine tracks to be ripped, their output filename and metadata
    if (len(args) == 0):
        tracks_to_rip = set(range(1, len(cdda) + 1))
    else:
        tracks_to_rip = set([])
        for arg in args:
            try:
                tracks_to_rip.add(int(arg))
            except ValueError:
                continue

    output_filenames = set([])
    to_rip = []
    for cd_track in cdda:
        if (cd_track.track_number in tracks_to_rip):
            basename = "track%2d%2.2d" % (options.album_number,
                                          cd_track.track_number)
            try:
                metadata = track_metadatas.get(cd_track.track_number, None)

                output_filename = audiotools.Filename(
                    os.path.join(
                        base_directory,
                        AudioType.track_name(file_path=basename,
                                             track_metadata=metadata,
                                             format=options.format)))

                if (output_filename not in output_filenames):
                    output_filenames.add(output_filename)
                    to_rip.append((cd_track, output_filename, metadata))
                else:
                    msg.error(ERR_DUPLICATE_OUTPUT_FILE %
                              (output_filename,))
                    sys.exit(1)

            except audiotools.UnsupportedTracknameField, err:
                err.error_msg(msg)
                sys.exit(1)
            except audiotools.InvalidFormat, err:
                msg.error(unicode(err))
                sys.exit(1)

    #perform actual ripping of tracks from CDDA
    encoded = []
    rip_log = {}
    for (i, (cd_track, output_filename, metadata)) in enumerate(to_rip):
        try:
            audiotools.make_dirs(str(output_filename))
        except OSError, err:
            msg.os_error(err)
            sys.exit(1)

        progress = audiotools.SingleProgressDisplay(
            msg, unicode(output_filename))

        try:
            track = AudioType.from_pcm(
                str(output_filename),
                audiotools.PCMReaderProgress(
                    cd_track,
                    cd_track.length() * (44100 / 75),
                    progress.update),
                quality)
        except audiotools.EncodingError, err:
            msg.error(ERR_ENCODING_ERROR % (output_filename,))
            sys.exit(1)

        track.set_metadata(metadata)
        progress.clear()

        encoded.append(track)

        rip_log[cd_track.track_number] = cd_track.rip_log

        msg.info(audiotools.output_progress(
                LAB_CD2TRACK_PROGRESS %
                {"track_number": cd_track.track_number,
                 "filename": output_filename}, i + 1, len(to_rip)))

    cdda.close()

    #add ReplayGain to ripped tracks, if necessary
    if (audiotools.ADD_REPLAYGAIN and
        options.add_replay_gain and
        AudioType.can_add_replay_gain(encoded)):
        rg_progress = audiotools.ReplayGainProgressDisplay(
            msg, AudioType.lossless_replay_gain())
        rg_progress.initial_message()
        try:
            #all audio files must belong to the same album, by definition
            AudioType.add_replay_gain([f.filename for f in encoded],
                                      rg_progress.update)
        except ValueError, err:
            rg_progress.clear()
            msg.error(unicode(err))
            sys.exit(1)
        rg_progress.final_message()

    #display ripping log
    msg.output(LAB_CD2TRACK_LOG)
    msg.new_row()
    headers = [u"track", u"rderr", u"skip", u"atom",
               u"edge", u"drop", u"dup", u"drift"]
    keys = ["rderr", "skip", "atom", "edge", "drop", "dup", "drift"]

    dividers = []
    for header in headers:
        msg.output_column(header, True)
        dividers.append(u'-')
        if (header != headers[-1]):
            msg.output_column(u" ")
            dividers.append(u" ")
    msg.divider_row(dividers)
    for track_number in sorted(rip_log.keys()):
        msg.new_row()
        msg.output_column(unicode(track_number), True)
        msg.output_column(u" ")
        log = rip_log[track_number]
        for key in keys:
            msg.output_column(unicode(log.get(key, 0)), True)
            if (key != keys[-1]):
                msg.output_column(u" ")
    msg.output_rows()
